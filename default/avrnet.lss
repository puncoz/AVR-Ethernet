
avrnet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002144  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000006a  00800060  00002144  000021f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000021  008000ca  008000ca  00002262  2**0
                  ALLOC
  3 .eeprom       00000008  00810000  00810000  00002262  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000001a0  00000000  00000000  0000226a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000006a7  00000000  00000000  0000240a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003e02  00000000  00000000  00002ab1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011fc  00000000  00000000  000068b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001eed  00000000  00000000  00007aaf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000480  00000000  00000000  0000999c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000829  00000000  00000000  00009e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001337  00000000  00000000  0000a645  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  0000b97c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 88 04 	jmp	0x910	; 0x910 <__ctors_end>
       4:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
       8:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
       c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      10:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      14:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      18:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      1c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      20:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      24:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      28:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      2c:	0c 94 9a 0f 	jmp	0x1f34	; 0x1f34 <__vector_11>
      30:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      34:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      38:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      3c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      40:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      44:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      48:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      4c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      50:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>

00000054 <__c.2460>:
      54:	3c 2f 66 6f 6f 74 65 72 3e 3c 2f 73 65 63 74 69     </footer></secti
      64:	6f 6e 3e 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c     on></body></html
      74:	3e 00                                               >.

00000076 <__c.2458>:
      76:	43 6f 70 79 72 69 67 68 74 20 26 63 6f 70 79 3b     Copyright &copy;
      86:	20 32 30 31 34 20 65 6d 42 61 6e 6b 2e 20 41 6c      2014 emBank. Al
      96:	6c 20 72 69 67 68 74 73 20 72 65 73 65 72 76 65     l rights reserve
      a6:	64 2e 00                                            d..

000000a9 <__c.2456>:
      a9:	3c 2f 64 69 76 3e 3c 2f 64 69 76 3e 3c 2f 73 65     </div></div></se
      b9:	63 74 69 6f 6e 3e 3c 2f 73 65 63 74 69 6f 6e 3e     ction></section>
      c9:	3c 66 6f 6f 74 65 72 3e 00                          <footer>.

000000d2 <__c.2454>:
      d2:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
      e2:	3e 3c 2f 64 69 76 3e 00                             ></div>.

000000ea <__c.2452>:
      ea:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
      fa:	6c 3d 31 26 66 61 6e 3d 31 3e 3c 69 6d 67 20 63     l=1&fan=1><img c
     10a:	6c 61 73 73 3d 73 77 69 74 63 68 20 73 72 63 3d     lass=switch src=
     11a:	68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 35     http://192.168.5
     12a:	33 2e 33 2f 61 2f 69 2f 73 2d 66 2e 70 6e 67 3e     3.3/a/i/s-f.png>
     13a:	3c 2f 61 3e 00                                      </a>.

0000013f <__c.2450>:
     13f:	3c 69 6d 67 20 63 6c 61 73 73 3d 22 66 61 6e 22     <img class="fan"
     14f:	20 73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e      src=http://192.
     15f:	31 36 38 2e 35 33 2e 33 2f 61 2f 69 2f 66 61 6e     168.53.3/a/i/fan
     16f:	2e 70 6e 67 20 2f 3e 00                             .png />.

00000177 <__c.2448>:
     177:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     187:	6c 3d 31 26 66 61 6e 3d 30 3e 3c 69 6d 67 20 63     l=1&fan=0><img c
     197:	6c 61 73 73 3d 73 77 69 74 63 68 20 73 72 63 3d     lass=switch src=
     1a7:	68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 35     http://192.168.5
     1b7:	33 2e 33 2f 61 2f 69 2f 73 2d 6e 2e 70 6e 67 3e     3.3/a/i/s-n.png>
     1c7:	3c 2f 61 3e 00                                      </a>.

000001cc <__c.2446>:
     1cc:	3c 69 6d 67 20 63 6c 61 73 73 3d 22 66 61 6e 20     <img class="fan 
     1dc:	72 6f 74 61 74 69 6e 67 22 20 73 72 63 3d 68 74     rotating" src=ht
     1ec:	74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 35 33 2e     tp://192.168.53.
     1fc:	33 2f 61 2f 69 2f 66 61 6e 2e 70 6e 67 20 2f 3e     3/a/i/fan.png />
	...

0000020d <__c.2444>:
     20d:	3c 2f 64 69 76 3e 3c 64 69 76 20 63 6c 61 73 73     </div><div class
     21d:	3d 63 49 74 65 6d 3e 00                             =cItem>.

00000225 <__c.2442>:
     225:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
     235:	3e 3c 2f 64 69 76 3e 00                             ></div>.

0000023d <__c.2440>:
     23d:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     24d:	6c 3d 31 26 62 75 6c 62 32 3d 31 3e 3c 69 6d 67     l=1&bulb2=1><img
     25d:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     26d:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     27d:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 66 2e 70 6e     .53.3/a/i/s-f.pn
     28d:	67 3e 3c 2f 61 3e 00                                g></a>.

00000294 <__c.2438>:
     294:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     2a4:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     2b4:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 66 2e     68.53.3/a/i/b-f.
     2c4:	70 6e 67 20 2f 3e 00                                png />.

000002cb <__c.2436>:
     2cb:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     2db:	6c 3d 31 26 62 75 6c 62 32 3d 30 3e 3c 69 6d 67     l=1&bulb2=0><img
     2eb:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     2fb:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     30b:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 6e 2e 70 6e     .53.3/a/i/s-n.pn
     31b:	67 3e 3c 2f 61 3e 00                                g></a>.

00000322 <__c.2434>:
     322:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     332:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     342:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 6e 2e     68.53.3/a/i/b-n.
     352:	70 6e 67 20 2f 3e 00                                png />.

00000359 <__c.2432>:
     359:	3c 2f 64 69 76 3e 3c 64 69 76 20 63 6c 61 73 73     </div><div class
     369:	3d 63 49 74 65 6d 3e 00                             =cItem>.

00000371 <__c.2430>:
     371:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
     381:	3e 3c 2f 64 69 76 3e 00                             ></div>.

00000389 <__c.2428>:
     389:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     399:	6c 3d 31 26 62 75 6c 62 31 3d 31 3e 3c 69 6d 67     l=1&bulb1=1><img
     3a9:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     3b9:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     3c9:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 66 2e 70 6e     .53.3/a/i/s-f.pn
     3d9:	67 3e 3c 2f 61 3e 00                                g></a>.

000003e0 <__c.2426>:
     3e0:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     3f0:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     400:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 66 2e     68.53.3/a/i/b-f.
     410:	70 6e 67 20 2f 3e 00                                png />.

00000417 <__c.2424>:
     417:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     427:	6c 3d 31 26 62 75 6c 62 31 3d 30 3e 3c 69 6d 67     l=1&bulb1=0><img
     437:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     447:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     457:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 6e 2e 70 6e     .53.3/a/i/s-n.pn
     467:	67 3e 3c 2f 61 3e 00                                g></a>.

0000046e <__c.2422>:
     46e:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     47e:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     48e:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 6e 2e     68.53.3/a/i/b-n.
     49e:	70 6e 67 20 2f 3e 00                                png />.

000004a5 <__c.2420>:
     4a5:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6f 6e 74 72     <div class=contr
     4b5:	6f 6c 3e 3c 64 69 76 20 63 6c 61 73 73 3d 63 49     ol><div class=cI
     4c5:	74 65 6d 3e 00                                      tem>.

000004ca <__c.2418>:
     4ca:	3c 73 65 63 74 69 6f 6e 20 69 64 3d 75 73 65 72     <section id=user
     4da:	2d 72 65 67 20 63 6c 61 73 73 3d 22 73 70 6c 61     -reg class="spla
     4ea:	73 68 2d 63 6f 6e 74 65 6e 74 20 72 65 67 69 73     sh-content regis
     4fa:	74 65 72 22 3e 00                                   ter">.

00000500 <__c.2416>:
     500:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
     510:	3e 3c 2f 64 69 76 3e 3c 2f 68 65 61 64 65 72 3e     ></div></header>
	...

00000521 <__c.2414>:
     521:	3c 2f 75 6c 3e 3c 2f 6e 61 76 3e 00                 </ul></nav>.

0000052d <__c.2412>:
     52d:	3c 6c 69 3e 3c 61 20 68 72 65 66 3d 68 74 74 70     <li><a href=http
     53d:	3a 2f 2f 31 39 32 2e 31 36 38 2e 35 33 2e 33 2f     ://192.168.53.3/
     54d:	3e 61 63 63 6f 75 6e 74 3c 2f 61 3e 3c 2f 6c 69     >account</a></li
     55d:	3e 00                                               >.

0000055f <__c.2410>:
     55f:	3c 6c 69 3e 3c 61 20 68 72 65 66 3d 68 74 74 70     <li><a href=http
     56f:	3a 2f 2f 31 39 32 2e 31 36 38 2e 35 33 2e 33 2f     ://192.168.53.3/
     57f:	3e 68 6f 6d 65 3c 2f 61 3e 3c 2f 6c 69 3e 00        >home</a></li>.

0000058e <__c.2408>:
     58e:	3c 6e 61 76 3e 3c 75 6c 3e 00                       <nav><ul>.

00000598 <__c.2406>:
     598:	3c 64 69 76 20 63 6c 61 73 73 3d 22 74 61 67 2d     <div class="tag-
     5a8:	6c 69 6e 65 22 3e 3c 73 70 61 6e 3e 45 6d 62 65     line"><span>Embe
     5b8:	64 64 65 64 20 53 65 72 76 65 72 20 62 61 73 65     dded Server base
     5c8:	64 20 54 61 6e 73 61 63 74 69 6f 6e 20 53 79 73     d Tansaction Sys
     5d8:	74 65 6d 3c 2f 73 70 61 6e 3e 3c 2f 64 69 76 3e     tem</span></div>
	...

000005e9 <__c.2404>:
     5e9:	3c 64 69 76 20 63 6c 61 73 73 3d 6c 6f 67 6f 3e     <div class=logo>
     5f9:	3c 61 20 68 72 65 66 3d 68 74 74 70 3a 2f 2f 31     <a href=http://1
     609:	39 32 2e 31 36 38 2e 35 33 2e 33 2f 20 3e 3c 2f     92.168.53.3/ ></
     619:	61 3e 3c 2f 64 69 76 3e 00                          a></div>.

00000622 <__c.2402>:
     622:	3c 68 65 61 64 65 72 3e 00                          <header>.

0000062b <__c.2400>:
     62b:	3c 73 65 63 74 69 6f 6e 20 63 6c 61 73 73 3d 22     <section class="
     63b:	68 6f 6d 65 22 3e 00                                home">.

00000642 <__c.2398>:
     642:	3c 73 65 63 74 69 6f 6e 20 69 64 3d 6c 61 79 6f     <section id=layo
     652:	75 74 3e 00                                         ut>.

00000656 <__c.2396>:
     656:	3c 2f 68 65 61 64 3e 3c 62 6f 64 79 3e 00           </head><body>.

00000664 <__c.2394>:
     664:	3c 6c 69 6e 6b 20 72 65 6c 3d 73 74 79 6c 65 73     <link rel=styles
     674:	68 65 65 74 20 74 79 70 65 3d 74 65 78 74 2f 63     heet type=text/c
     684:	73 73 20 68 72 65 66 3d 68 74 74 70 3a 2f 2f 31     ss href=http://1
     694:	39 32 2e 31 36 38 2e 35 33 2e 33 2f 61 2f 63 2f     92.168.53.3/a/c/
     6a4:	73 2e 63 73 73 20 2f 3e 00                          s.css />.

000006ad <__c.2392>:
     6ad:	3c 74 69 74 6c 65 3e 43 6f 6e 74 72 6f 6c 20 52     <title>Control R
     6bd:	6f 6f 6d 20 7c 7c 20 65 6d 42 61 6e 6b 3c 2f 74     oom || emBank</t
     6cd:	69 74 6c 65 3e 00                                   itle>.

000006d3 <__c.2390>:
     6d3:	3c 74 69 74 6c 65 3e 43 6f 6e 74 72 6f 6c 20 52     <title>Control R
     6e3:	6f 6f 6d 20 7c 7c 20 65 6d 42 61 6e 6b 3c 2f 74     oom || emBank</t
     6f3:	69 74 6c 65 3e 00                                   itle>.

000006f9 <__c.2388>:
     6f9:	3c 68 74 6d 6c 3e 3c 68 65 61 64 3e 00              <html><head>.

00000706 <__c.2386>:
     706:	3c 21 44 4f 43 54 59 50 45 20 68 74 6d 6c 3e 00     <!DOCTYPE html>.

00000716 <__c.2384>:
     716:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     726:	0a 41 63 63 65 73 73 2d 43 6f 6e 74 72 6f 6c 2d     .Access-Control-
     736:	41 6c 6c 6f 77 2d 4f 72 69 67 69 6e 3a 20 2a 0d     Allow-Origin: *.
     746:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     756:	65 78 74 2f 68 74 6d 6c 0d 0a 43 6f 6e 6e 65 63     ext/html..Connec
     766:	74 69 6f 6e 3a 20 6b 65 65 70 2d 61 6c 69 76 65     tion: keep-alive
     776:	0d 0a 0d 0a 00                                      .....

0000077b <__c.2375>:
     77b:	73 75 63 63 65 73 73 00                             success.

00000783 <__c.2373>:
     783:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     793:	0a 41 63 63 65 73 73 2d 43 6f 6e 74 72 6f 6c 2d     .Access-Control-
     7a3:	41 6c 6c 6f 77 2d 4f 72 69 67 69 6e 3a 20 2a 0d     Allow-Origin: *.
     7b3:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     7c3:	65 78 74 2f 68 74 6d 6c 0d 0a 43 6f 6e 6e 65 63     ext/html..Connec
     7d3:	74 69 6f 6e 3a 20 6b 65 65 70 2d 61 6c 69 76 65     tion: keep-alive
     7e3:	0d 0a 0d 0a 00                                      .....

000007e8 <__c.2365>:
     7e8:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     7f8:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     808:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00              ext/html.....

00000815 <__c.2349>:
     815:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 70     Connection: keep
     825:	2d 61 6c 69 76 65 0d 0a 0d 0a 00                    -alive.....

00000830 <__c.2347>:
     830:	4b 65 65 70 2d 41 6c 69 76 65 3a 20 33 30 30 0d     Keep-Alive: 300.
     840:	0a 00                                               ..

00000842 <__c.2345>:
     842:	41 63 63 65 70 74 3a 20 74 65 78 74 2f 68 74 6d     Accept: text/htm
     852:	6c 0d 0a 00                                         l...

00000856 <__c.2343>:
     856:	55 73 65 72 2d 41 67 65 6e 74 3a 20 41 56 52 20     User-Agent: AVR 
     866:	65 74 68 65 72 6e 65 74 0d 0a 00                    ethernet...

00000871 <__c.2341>:
     871:	48 6f 73 74 3a 20 31 30 2e 31 2e 31 2e 37 36 0d     Host: 10.1.1.76.
     881:	0a 00                                               ..

00000883 <__c.2339>:
     883:	20 48 54 54 50 2f 31 2e 30 0d 0a 00                  HTTP/1.0...

0000088f <__c.2337>:
     88f:	47 45 54 20 2f 61 76 72 6e 65 74 2f 73 61 76 65     GET /avrnet/save
     89f:	2e 70 68 70 3f 70 77 64 3d 73 65 63 72 65 74 26     .php?pwd=secret&
     8af:	74 65 6d 70 3d 00                                   temp=.

000008b5 <__c.2196>:
     8b5:	66 61 6e 00                                         fan.

000008b9 <__c.2194>:
     8b9:	62 75 6c 62 32 00                                   bulb2.

000008bf <__c.2192>:
     8bf:	62 75 6c 62 31 00                                   bulb1.

000008c5 <__c.2190>:
     8c5:	63 6f 6e 74 72 6f 6c 00                             control.

000008cd <__c.2188>:
     8cd:	63 68 65 63 6b 00                                   check.

000008d3 <__c.2185>:
     8d3:	61 6d 6d 6f 75 6e 74 00                             ammount.

000008db <__c.2183>:
     8db:	72 65 63 65 69 76 65 72 00                          receiver.

000008e4 <__c.2181>:
     8e4:	62 61 6c 5f 74 72 66 00                             bal_trf.

000008ec <__c.2179>:
     8ec:	73 65 63 43 6f 64 65 00                             secCode.

000008f4 <__c.2177>:
     8f4:	6d 6f 62 4e 75 6d 00                                mobNum.

000008fb <__c.2175>:
     8fb:	72 65 67 5f 73 65 6e 64 5f 6d 73 67 00              reg_send_msg.

00000908 <__c.2214>:
     908:	45 52 52 4f 52 0d 0a 00                             ERROR...

00000910 <__ctors_end>:
     910:	11 24       	eor	r1, r1
     912:	1f be       	out	0x3f, r1	; 63
     914:	cf e5       	ldi	r28, 0x5F	; 95
     916:	d8 e0       	ldi	r29, 0x08	; 8
     918:	de bf       	out	0x3e, r29	; 62
     91a:	cd bf       	out	0x3d, r28	; 61

0000091c <__do_copy_data>:
     91c:	10 e0       	ldi	r17, 0x00	; 0
     91e:	a0 e6       	ldi	r26, 0x60	; 96
     920:	b0 e0       	ldi	r27, 0x00	; 0
     922:	e4 e4       	ldi	r30, 0x44	; 68
     924:	f1 e2       	ldi	r31, 0x21	; 33
     926:	02 c0       	rjmp	.+4      	; 0x92c <.do_copy_data_start>

00000928 <.do_copy_data_loop>:
     928:	05 90       	lpm	r0, Z+
     92a:	0d 92       	st	X+, r0

0000092c <.do_copy_data_start>:
     92c:	aa 3c       	cpi	r26, 0xCA	; 202
     92e:	b1 07       	cpc	r27, r17
     930:	d9 f7       	brne	.-10     	; 0x928 <.do_copy_data_loop>

00000932 <__do_clear_bss>:
     932:	10 e0       	ldi	r17, 0x00	; 0
     934:	aa ec       	ldi	r26, 0xCA	; 202
     936:	b0 e0       	ldi	r27, 0x00	; 0
     938:	01 c0       	rjmp	.+2      	; 0x93c <.do_clear_bss_start>

0000093a <.do_clear_bss_loop>:
     93a:	1d 92       	st	X+, r1

0000093c <.do_clear_bss_start>:
     93c:	ab 3e       	cpi	r26, 0xEB	; 235
     93e:	b1 07       	cpc	r27, r17
     940:	e1 f7       	brne	.-8      	; 0x93a <.do_clear_bss_loop>
     942:	0e 94 61 07 	call	0xec2	; 0xec2 <main>
     946:	0c 94 a0 10 	jmp	0x2140	; 0x2140 <_exit>

0000094a <__bad_interrupt>:
     94a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000094e <enc28j60ReadOp>:
//
//*******************************************************************************************
BYTE enc28j60ReadOp(BYTE op, BYTE address)
{
	// activate CS
	CSACTIVE;
     94e:	c4 98       	cbi	0x18, 4	; 24
	// issue read command
	SPDR = op | (address & ADDR_MASK);
     950:	96 2f       	mov	r25, r22
     952:	9f 71       	andi	r25, 0x1F	; 31
     954:	98 2b       	or	r25, r24
     956:	9f b9       	out	0x0f, r25	; 15
	waitspi();
     958:	77 9b       	sbis	0x0e, 7	; 14
     95a:	fe cf       	rjmp	.-4      	; 0x958 <enc28j60ReadOp+0xa>
	// read data
	SPDR = 0x00;
     95c:	1f b8       	out	0x0f, r1	; 15
	waitspi();
     95e:	77 9b       	sbis	0x0e, 7	; 14
     960:	fe cf       	rjmp	.-4      	; 0x95e <enc28j60ReadOp+0x10>
	// do dummy read if needed (for mac and mii, see datasheet page 29)
	if(address & 0x80)
     962:	67 ff       	sbrs	r22, 7
     964:	03 c0       	rjmp	.+6      	; 0x96c <enc28j60ReadOp+0x1e>
	{
		SPDR = 0x00;
     966:	1f b8       	out	0x0f, r1	; 15
		waitspi();
     968:	77 9b       	sbis	0x0e, 7	; 14
     96a:	fe cf       	rjmp	.-4      	; 0x968 <enc28j60ReadOp+0x1a>
	}
	// release CS
	CSPASSIVE;
     96c:	c4 9a       	sbi	0x18, 4	; 24
	return(SPDR);
     96e:	8f b1       	in	r24, 0x0f	; 15
}
     970:	08 95       	ret

00000972 <enc28j60WriteOp>:
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     972:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     974:	6f 71       	andi	r22, 0x1F	; 31
     976:	68 2b       	or	r22, r24
     978:	6f b9       	out	0x0f, r22	; 15
	waitspi();
     97a:	77 9b       	sbis	0x0e, 7	; 14
     97c:	fe cf       	rjmp	.-4      	; 0x97a <enc28j60WriteOp+0x8>
	// write data
	SPDR = data;
     97e:	4f b9       	out	0x0f, r20	; 15
	waitspi();
     980:	77 9b       	sbis	0x0e, 7	; 14
     982:	fe cf       	rjmp	.-4      	; 0x980 <enc28j60WriteOp+0xe>
	CSPASSIVE;
     984:	c4 9a       	sbi	0x18, 4	; 24
}
     986:	08 95       	ret

00000988 <enc28j60SetBank>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60SetBank(BYTE address)
{
     988:	48 2f       	mov	r20, r24
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
     98a:	28 2f       	mov	r18, r24
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	20 76       	andi	r18, 0x60	; 96
     990:	30 70       	andi	r19, 0x00	; 0
     992:	80 91 ca 00 	lds	r24, 0x00CA
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	28 17       	cp	r18, r24
     99a:	39 07       	cpc	r19, r25
     99c:	d9 f0       	breq	.+54     	; 0x9d4 <enc28j60SetBank+0x4c>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     99e:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     9a0:	8f eb       	ldi	r24, 0xBF	; 191
     9a2:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     9a4:	77 9b       	sbis	0x0e, 7	; 14
     9a6:	fe cf       	rjmp	.-4      	; 0x9a4 <enc28j60SetBank+0x1c>
	// write data
	SPDR = data;
     9a8:	83 e0       	ldi	r24, 0x03	; 3
     9aa:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     9ac:	77 9b       	sbis	0x0e, 7	; 14
     9ae:	fe cf       	rjmp	.-4      	; 0x9ac <enc28j60SetBank+0x24>
	CSPASSIVE;
     9b0:	c4 9a       	sbi	0x18, 4	; 24
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     9b2:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     9b4:	8f e9       	ldi	r24, 0x9F	; 159
     9b6:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     9b8:	77 9b       	sbis	0x0e, 7	; 14
     9ba:	fe cf       	rjmp	.-4      	; 0x9b8 <enc28j60SetBank+0x30>
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
     9bc:	85 e0       	ldi	r24, 0x05	; 5
     9be:	35 95       	asr	r19
     9c0:	27 95       	ror	r18
     9c2:	8a 95       	dec	r24
     9c4:	e1 f7       	brne	.-8      	; 0x9be <enc28j60SetBank+0x36>
	CSACTIVE;
	// issue write command
	SPDR = op | (address & ADDR_MASK);
	waitspi();
	// write data
	SPDR = data;
     9c6:	2f b9       	out	0x0f, r18	; 15
	waitspi();
     9c8:	77 9b       	sbis	0x0e, 7	; 14
     9ca:	fe cf       	rjmp	.-4      	; 0x9c8 <enc28j60SetBank+0x40>
	CSPASSIVE;
     9cc:	c4 9a       	sbi	0x18, 4	; 24
	if((address & BANK_MASK) != Enc28j60Bank)
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
		Enc28j60Bank = (address & BANK_MASK);
     9ce:	40 76       	andi	r20, 0x60	; 96
     9d0:	40 93 ca 00 	sts	0x00CA, r20
     9d4:	08 95       	ret

000009d6 <enc28j60Read>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
BYTE enc28j60Read(BYTE address)
{
     9d6:	1f 93       	push	r17
     9d8:	18 2f       	mov	r17, r24
	// select bank to read
	enc28j60SetBank(address);
     9da:	0e 94 c4 04 	call	0x988	; 0x988 <enc28j60SetBank>
	
	// do the read
	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
     9de:	80 e0       	ldi	r24, 0x00	; 0
     9e0:	61 2f       	mov	r22, r17
     9e2:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
}
     9e6:	1f 91       	pop	r17
     9e8:	08 95       	ret

000009ea <enc28j60Write>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60Write(BYTE address, BYTE data)
{
     9ea:	0f 93       	push	r16
     9ec:	1f 93       	push	r17
     9ee:	18 2f       	mov	r17, r24
     9f0:	06 2f       	mov	r16, r22
	// select bank to write
	enc28j60SetBank(address);
     9f2:	0e 94 c4 04 	call	0x988	; 0x988 <enc28j60SetBank>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     9f6:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     9f8:	1f 71       	andi	r17, 0x1F	; 31
     9fa:	10 64       	ori	r17, 0x40	; 64
     9fc:	1f b9       	out	0x0f, r17	; 15
	waitspi();
     9fe:	77 9b       	sbis	0x0e, 7	; 14
     a00:	fe cf       	rjmp	.-4      	; 0x9fe <enc28j60Write+0x14>
	// write data
	SPDR = data;
     a02:	0f b9       	out	0x0f, r16	; 15
	waitspi();
     a04:	77 9b       	sbis	0x0e, 7	; 14
     a06:	fe cf       	rjmp	.-4      	; 0xa04 <enc28j60Write+0x1a>
	CSPASSIVE;
     a08:	c4 9a       	sbi	0x18, 4	; 24
	// select bank to write
	enc28j60SetBank(address);

	// do the write
	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <enc28j60_read_phyreg>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
WORD enc28j60_read_phyreg(BYTE address)
{
     a10:	0f 93       	push	r16
     a12:	1f 93       	push	r17
     a14:	68 2f       	mov	r22, r24
	WORD data;
	
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
     a16:	84 ed       	ldi	r24, 0xD4	; 212
     a18:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
     a1c:	82 ed       	ldi	r24, 0xD2	; 210
     a1e:	61 e0       	ldi	r22, 0x01	; 1
     a20:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Loop to wait until the PHY register has been read through the MII
	// This requires 10.24us
	while( (enc28j60Read(MISTAT) & MISTAT_BUSY) );
     a24:	8a ee       	ldi	r24, 0xEA	; 234
     a26:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     a2a:	80 fd       	sbrc	r24, 0
     a2c:	fb cf       	rjmp	.-10     	; 0xa24 <enc28j60_read_phyreg+0x14>
	
	// Stop reading
	enc28j60Write(MICMD, MICMD_MIIRD);
     a2e:	82 ed       	ldi	r24, 0xD2	; 210
     a30:	61 e0       	ldi	r22, 0x01	; 1
     a32:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Obtain results and return
	data = enc28j60Read ( MIRDL );
     a36:	88 ed       	ldi	r24, 0xD8	; 216
     a38:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     a3c:	08 2f       	mov	r16, r24
     a3e:	10 e0       	ldi	r17, 0x00	; 0
	data |= enc28j60Read ( MIRDH );
     a40:	89 ed       	ldi	r24, 0xD9	; 217
     a42:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     a46:	28 2f       	mov	r18, r24
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	20 2b       	or	r18, r16
     a4c:	31 2b       	or	r19, r17

	return data;
}
     a4e:	c9 01       	movw	r24, r18
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	08 95       	ret

00000a56 <enc28j60getrev>:
// Description : read the revision of the chip.
//
//*******************************************************************************************
BYTE enc28j60getrev(void)
{
	return(enc28j60Read(EREVID));
     a56:	82 e7       	ldi	r24, 0x72	; 114
     a58:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
}
     a5c:	08 95       	ret

00000a5e <enc28j60_packet_send>:
// Function : enc28j60_packet_send
// Description : Send packet to network.
//
//*******************************************************************************************
void enc28j60_packet_send ( BYTE *buffer, WORD length )
{
     a5e:	0f 93       	push	r16
     a60:	1f 93       	push	r17
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	8c 01       	movw	r16, r24
     a68:	eb 01       	movw	r28, r22
	//Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, LOW(TXSTART_INIT) );
     a6a:	82 e0       	ldi	r24, 0x02	; 2
     a6c:	64 e2       	ldi	r22, 0x24	; 36
     a6e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EWRPTH, HIGH(TXSTART_INIT) );
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	6a e1       	ldi	r22, 0x1A	; 26
     a76:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, LOW((TXSTART_INIT+length)) );
     a7a:	ce 01       	movw	r24, r28
     a7c:	8c 5d       	subi	r24, 0xDC	; 220
     a7e:	68 2f       	mov	r22, r24
     a80:	86 e0       	ldi	r24, 0x06	; 6
     a82:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ETXNDH, HIGH((TXSTART_INIT+length)) );
     a86:	9e 01       	movw	r18, r28
     a88:	2c 5d       	subi	r18, 0xDC	; 220
     a8a:	35 4e       	sbci	r19, 0xE5	; 229
     a8c:	87 e0       	ldi	r24, 0x07	; 7
     a8e:	63 2f       	mov	r22, r19
     a90:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     a94:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     a96:	8a e7       	ldi	r24, 0x7A	; 122
     a98:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     a9a:	77 9b       	sbis	0x0e, 7	; 14
     a9c:	fe cf       	rjmp	.-4      	; 0xa9a <enc28j60_packet_send+0x3c>
	// write data
	SPDR = data;
     a9e:	1f b8       	out	0x0f, r1	; 15
	waitspi();
     aa0:	77 9b       	sbis	0x0e, 7	; 14
     aa2:	fe cf       	rjmp	.-4      	; 0xaa0 <enc28j60_packet_send+0x42>
	CSPASSIVE;
     aa4:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60Write(ETXNDH, HIGH((TXSTART_INIT+length)) );

	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);

	CSACTIVE;
     aa6:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
     aa8:	8a e7       	ldi	r24, 0x7A	; 122
     aaa:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     aac:	77 9b       	sbis	0x0e, 7	; 14
     aae:	fe cf       	rjmp	.-4      	; 0xaac <enc28j60_packet_send+0x4e>
     ab0:	08 c0       	rjmp	.+16     	; 0xac2 <enc28j60_packet_send+0x64>
	while(length)
	{
		length--;
		// write data
		SPDR = *buffer++;
     ab2:	f8 01       	movw	r30, r16
     ab4:	80 81       	ld	r24, Z
     ab6:	8f b9       	out	0x0f, r24	; 15
		waitspi();
     ab8:	77 9b       	sbis	0x0e, 7	; 14
     aba:	fe cf       	rjmp	.-4      	; 0xab8 <enc28j60_packet_send+0x5a>
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
	waitspi();
	while(length)
	{
		length--;
     abc:	21 97       	sbiw	r28, 0x01	; 1
		// write data
		SPDR = *buffer++;
     abe:	0f 5f       	subi	r16, 0xFF	; 255
     ac0:	1f 4f       	sbci	r17, 0xFF	; 255

	CSACTIVE;
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
	waitspi();
	while(length)
     ac2:	20 97       	sbiw	r28, 0x00	; 0
     ac4:	b1 f7       	brne	.-20     	; 0xab2 <enc28j60_packet_send+0x54>
		length--;
		// write data
		SPDR = *buffer++;
		waitspi();
	}
	CSPASSIVE;
     ac6:	c4 9a       	sbi	0x18, 4	; 24
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     ac8:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     aca:	8f e9       	ldi	r24, 0x9F	; 159
     acc:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     ace:	77 9b       	sbis	0x0e, 7	; 14
     ad0:	fe cf       	rjmp	.-4      	; 0xace <enc28j60_packet_send+0x70>
	// write data
	SPDR = data;
     ad2:	88 e0       	ldi	r24, 0x08	; 8
     ad4:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     ad6:	77 9b       	sbis	0x0e, 7	; 14
     ad8:	fe cf       	rjmp	.-4      	; 0xad6 <enc28j60_packet_send+0x78>
	CSPASSIVE;
     ada:	c4 9a       	sbi	0x18, 4	; 24
	
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);

	// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) )
     adc:	8c e1       	ldi	r24, 0x1C	; 28
     ade:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     ae2:	81 ff       	sbrs	r24, 1
     ae4:	0a c0       	rjmp	.+20     	; 0xafa <enc28j60_packet_send+0x9c>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     ae6:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     ae8:	8f eb       	ldi	r24, 0xBF	; 191
     aea:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     aec:	77 9b       	sbis	0x0e, 7	; 14
     aee:	fe cf       	rjmp	.-4      	; 0xaec <enc28j60_packet_send+0x8e>
	// write data
	SPDR = data;
     af0:	88 e0       	ldi	r24, 0x08	; 8
     af2:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     af4:	77 9b       	sbis	0x0e, 7	; 14
     af6:	fe cf       	rjmp	.-4      	; 0xaf4 <enc28j60_packet_send+0x96>
	CSPASSIVE;
     af8:	c4 9a       	sbi	0x18, 4	; 24
	// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) )
	{
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
	}
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	08 95       	ret

00000b04 <enc28j60_packet_receive>:
// Description : check received packet and return length of data
//
//*******************************************************************************************
//WORD data_length;
WORD enc28j60_packet_receive ( BYTE *rxtx_buffer, WORD max_length )
{
     b04:	cf 92       	push	r12
     b06:	df 92       	push	r13
     b08:	ef 92       	push	r14
     b0a:	ff 92       	push	r15
     b0c:	0f 93       	push	r16
     b0e:	1f 93       	push	r17
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	6c 01       	movw	r12, r24
     b16:	7b 01       	movw	r14, r22
	WORD_BYTES rx_status, data_length;
	
	// check if a packet has been received and buffered
	// if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
	// The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) == 0 )
     b18:	89 e3       	ldi	r24, 0x39	; 57
     b1a:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     b1e:	88 23       	and	r24, r24
     b20:	19 f4       	brne	.+6      	; 0xb28 <enc28j60_packet_receive+0x24>
     b22:	20 e0       	ldi	r18, 0x00	; 0
     b24:	30 e0       	ldi	r19, 0x00	; 0
     b26:	5f c0       	rjmp	.+190    	; 0xbe6 <enc28j60_packet_receive+0xe2>
	{
		return 0;
	}

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, next_packet_ptr.bytes[0]);
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	60 91 cb 00 	lds	r22, 0x00CB
     b2e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERDPTH, next_packet_ptr.bytes[1]);
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	60 91 cc 00 	lds	r22, 0x00CC
     b38:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// read the next packet pointer
	next_packet_ptr.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b3c:	8a e3       	ldi	r24, 0x3A	; 58
     b3e:	60 e0       	ldi	r22, 0x00	; 0
     b40:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b44:	80 93 cb 00 	sts	0x00CB, r24
	next_packet_ptr.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b48:	8a e3       	ldi	r24, 0x3A	; 58
     b4a:	60 e0       	ldi	r22, 0x00	; 0
     b4c:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b50:	08 2f       	mov	r16, r24
     b52:	80 93 cc 00 	sts	0x00CC, r24

	// read the packet length (see datasheet page 43)
	data_length.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b56:	8a e3       	ldi	r24, 0x3A	; 58
     b58:	60 e0       	ldi	r22, 0x00	; 0
     b5a:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b5e:	c8 2f       	mov	r28, r24
	data_length.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b60:	8a e3       	ldi	r24, 0x3A	; 58
     b62:	60 e0       	ldi	r22, 0x00	; 0
     b64:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b68:	d8 2f       	mov	r29, r24
	data_length.word -=4; //remove the CRC count
     b6a:	24 97       	sbiw	r28, 0x04	; 4
	
	// read the receive status (see datasheet page 43)
	rx_status.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b6c:	8a e3       	ldi	r24, 0x3A	; 58
     b6e:	60 e0       	ldi	r22, 0x00	; 0
     b70:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b74:	18 2f       	mov	r17, r24
	rx_status.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b76:	8a e3       	ldi	r24, 0x3A	; 58
     b78:	60 e0       	ldi	r22, 0x00	; 0
     b7a:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
	
	if ( data_length.word > (max_length-1) )
     b7e:	b7 01       	movw	r22, r14
     b80:	61 50       	subi	r22, 0x01	; 1
     b82:	70 40       	sbci	r23, 0x00	; 0
     b84:	6c 17       	cp	r22, r28
     b86:	7d 07       	cpc	r23, r29
     b88:	08 f4       	brcc	.+2      	; 0xb8c <enc28j60_packet_receive+0x88>
	{
		data_length.word = max_length-1;
     b8a:	eb 01       	movw	r28, r22
	}
	
	// check CRC and symbol errors (see datasheet page 44, table 7-3):
	// The ERXFCON.CRCEN is set by default. Normally we should not
	// need to check this.
	if ( (rx_status.word & 0x80)==0 )
     b8c:	17 fd       	sbrc	r17, 7
     b8e:	03 c0       	rjmp	.+6      	; 0xb96 <enc28j60_packet_receive+0x92>
	{
		// invalid
		data_length.word = 0;
     b90:	c0 e0       	ldi	r28, 0x00	; 0
     b92:	d0 e0       	ldi	r29, 0x00	; 0
     b94:	14 c0       	rjmp	.+40     	; 0xbbe <enc28j60_packet_receive+0xba>
	}
	else
	{
		// read data from rx buffer and save to rxtx_buffer
		rx_status.word = data_length.word;
     b96:	9e 01       	movw	r18, r28
		CSACTIVE;
     b98:	c4 98       	cbi	0x18, 4	; 24
		// issue read command
		SPDR = ENC28J60_READ_BUF_MEM;
     b9a:	8a e3       	ldi	r24, 0x3A	; 58
     b9c:	8f b9       	out	0x0f, r24	; 15
		waitspi();
     b9e:	77 9b       	sbis	0x0e, 7	; 14
     ba0:	fe cf       	rjmp	.-4      	; 0xb9e <enc28j60_packet_receive+0x9a>
     ba2:	09 c0       	rjmp	.+18     	; 0xbb6 <enc28j60_packet_receive+0xb2>
		while(rx_status.word)
		{
			rx_status.word--;
			SPDR = 0x00;
     ba4:	1f b8       	out	0x0f, r1	; 15
			waitspi();
     ba6:	77 9b       	sbis	0x0e, 7	; 14
     ba8:	fe cf       	rjmp	.-4      	; 0xba6 <enc28j60_packet_receive+0xa2>
			*rxtx_buffer++ = SPDR;
     baa:	8f b1       	in	r24, 0x0f	; 15
     bac:	f6 01       	movw	r30, r12
     bae:	81 93       	st	Z+, r24
     bb0:	6f 01       	movw	r12, r30
     bb2:	21 50       	subi	r18, 0x01	; 1
     bb4:	30 40       	sbci	r19, 0x00	; 0
		rx_status.word = data_length.word;
		CSACTIVE;
		// issue read command
		SPDR = ENC28J60_READ_BUF_MEM;
		waitspi();
		while(rx_status.word)
     bb6:	21 15       	cp	r18, r1
     bb8:	31 05       	cpc	r19, r1
     bba:	a1 f7       	brne	.-24     	; 0xba4 <enc28j60_packet_receive+0xa0>
			rx_status.word--;
			SPDR = 0x00;
			waitspi();
			*rxtx_buffer++ = SPDR;
		}
		CSPASSIVE;
     bbc:	c4 9a       	sbi	0x18, 4	; 24
	}
	
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, next_packet_ptr.bytes[0]);
     bbe:	8c e0       	ldi	r24, 0x0C	; 12
     bc0:	60 91 cb 00 	lds	r22, 0x00CB
     bc4:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXRDPTH, next_packet_ptr.bytes[1]);
     bc8:	8d e0       	ldi	r24, 0x0D	; 13
     bca:	60 2f       	mov	r22, r16
     bcc:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     bd0:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     bd2:	8e e9       	ldi	r24, 0x9E	; 158
     bd4:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     bd6:	77 9b       	sbis	0x0e, 7	; 14
     bd8:	fe cf       	rjmp	.-4      	; 0xbd6 <enc28j60_packet_receive+0xd2>
	// write data
	SPDR = data;
     bda:	80 e4       	ldi	r24, 0x40	; 64
     bdc:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     bde:	77 9b       	sbis	0x0e, 7	; 14
     be0:	fe cf       	rjmp	.-4      	; 0xbde <enc28j60_packet_receive+0xda>
	CSPASSIVE;
     be2:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60Write(ERXRDPTH, next_packet_ptr.bytes[1]);

	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);

	return( data_length.word );
     be4:	9e 01       	movw	r18, r28
}
     be6:	c9 01       	movw	r24, r18
     be8:	df 91       	pop	r29
     bea:	cf 91       	pop	r28
     bec:	1f 91       	pop	r17
     bee:	0f 91       	pop	r16
     bf0:	ff 90       	pop	r15
     bf2:	ef 90       	pop	r14
     bf4:	df 90       	pop	r13
     bf6:	cf 90       	pop	r12
     bf8:	08 95       	ret

00000bfa <enc28j60PhyWrite>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60PhyWrite(BYTE address, WORD_BYTES data)
{
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	98 2f       	mov	r25, r24
     c00:	16 2f       	mov	r17, r22
     c02:	07 2f       	mov	r16, r23
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
     c04:	84 ed       	ldi	r24, 0xD4	; 212
     c06:	69 2f       	mov	r22, r25
     c08:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// write the PHY data
	enc28j60Write(MIWRL, data.byte.low);
     c0c:	86 ed       	ldi	r24, 0xD6	; 214
     c0e:	61 2f       	mov	r22, r17
     c10:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MIWRH, data.byte.high);
     c14:	87 ed       	ldi	r24, 0xD7	; 215
     c16:	60 2f       	mov	r22, r16
     c18:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
     c1c:	04 c0       	rjmp	.+8      	; 0xc26 <enc28j60PhyWrite+0x2c>
	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY)
	{
		_delay_us(15);
     c1e:	8f e0       	ldi	r24, 0x0F	; 15
     c20:	90 e0       	ldi	r25, 0x00	; 0
     c22:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_delay_us>
	enc28j60Write(MIREGADR, address);
	// write the PHY data
	enc28j60Write(MIWRL, data.byte.low);
	enc28j60Write(MIWRH, data.byte.high);
	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY)
     c26:	8a ee       	ldi	r24, 0xEA	; 234
     c28:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     c2c:	80 fd       	sbrc	r24, 0
     c2e:	f7 cf       	rjmp	.-18     	; 0xc1e <enc28j60PhyWrite+0x24>
	{
		_delay_us(15);
	}
}
     c30:	1f 91       	pop	r17
     c32:	0f 91       	pop	r16
     c34:	08 95       	ret

00000c36 <enc28j60_init>:
	//enc28j60_flag.rx_buffer_is_free = 1;
	_delay_ms(20);
}
*/
void enc28j60_init( BYTE *avr_mac)
{
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	ec 01       	movw	r28, r24
	// initialize I/O
	//DDRB |= _BV( DDB4 );
	//CSPASSIVE;

	// enable PB0, reset as output 
	ENC28J60_DDR |= _BV(ENC28J60_RESET_PIN_DDR);
     c3c:	8b 9a       	sbi	0x11, 3	; 17

	// enable PD2/INT0, as input
	ENC28J60_DDR &= ~_BV(ENC28J60_INT_PIN_DDR);
     c3e:	8a 98       	cbi	0x11, 2	; 17
	ENC28J60_PORT |= _BV(ENC28J60_INT_PIN);
     c40:	92 9a       	sbi	0x12, 2	; 18

	// set output to gnd, reset the ethernet chip
	ENC28J60_PORT &= ~_BV(ENC28J60_RESET_PIN);
     c42:	93 98       	cbi	0x12, 3	; 18
	_delay_ms(10);
     c44:	8a e0       	ldi	r24, 0x0A	; 10
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>

	// set output to Vcc, reset inactive
	ENC28J60_PORT |= _BV(ENC28J60_RESET_PIN);
     c4c:	93 9a       	sbi	0x12, 3	; 18
	_delay_ms(200);
     c4e:	88 ec       	ldi	r24, 0xC8	; 200
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>

    //	
	DDRB  |= _BV( DDB4 ) | _BV( DDB5 ) | _BV( DDB7 ); // mosi, sck, ss output
     c56:	87 b3       	in	r24, 0x17	; 23
     c58:	80 6b       	ori	r24, 0xB0	; 176
     c5a:	87 bb       	out	0x17, r24	; 23
	//DDRB &= ~_BV( DDB6 ); // MISO is input

	CSPASSIVE;
     c5c:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~(_BV( PB5 ) | _BV( PB7 ) );
     c5e:	88 b3       	in	r24, 0x18	; 24
     c60:	8f 75       	andi	r24, 0x5F	; 95
     c62:	88 bb       	out	0x18, r24	; 24
	//
	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = _BV( SPE ) | _BV( MSTR );
     c64:	80 e5       	ldi	r24, 0x50	; 80
     c66:	8d b9       	out	0x0d, r24	; 13
    SPSR |= _BV( SPI2X );
     c68:	70 9a       	sbi	0x0e, 0	; 14
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     c6a:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     c6c:	8f ef       	ldi	r24, 0xFF	; 255
     c6e:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     c70:	77 9b       	sbis	0x0e, 7	; 14
     c72:	fe cf       	rjmp	.-4      	; 0xc70 <enc28j60_init+0x3a>
	// write data
	SPDR = data;
     c74:	8f ef       	ldi	r24, 0xFF	; 255
     c76:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     c78:	77 9b       	sbis	0x0e, 7	; 14
     c7a:	fe cf       	rjmp	.-4      	; 0xc78 <enc28j60_init+0x42>
	CSPASSIVE;
     c7c:	c4 9a       	sbi	0x18, 4	; 24
    SPCR = _BV( SPE ) | _BV( MSTR );
    SPSR |= _BV( SPI2X );

	// perform system reset
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
	_delay_ms(50);
     c7e:	82 e3       	ldi	r24, 0x32	; 50
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>
	//while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	next_packet_ptr.word = RXSTART_INIT;
     c86:	10 92 cc 00 	sts	0x00CC, r1
     c8a:	10 92 cb 00 	sts	0x00CB, r1
    // Rx start
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
     c8e:	88 e0       	ldi	r24, 0x08	; 8
     c90:	60 e0       	ldi	r22, 0x00	; 0
     c92:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
     c96:	89 e0       	ldi	r24, 0x09	; 9
     c98:	60 e0       	ldi	r22, 0x00	; 0
     c9a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
     c9e:	8c e0       	ldi	r24, 0x0C	; 12
     ca0:	60 e0       	ldi	r22, 0x00	; 0
     ca2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
     ca6:	8d e0       	ldi	r24, 0x0D	; 13
     ca8:	60 e0       	ldi	r22, 0x00	; 0
     caa:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// RX end
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
     cae:	8a e0       	ldi	r24, 0x0A	; 10
     cb0:	63 e2       	ldi	r22, 0x23	; 35
     cb2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
     cb6:	8b e0       	ldi	r24, 0x0B	; 11
     cb8:	6a e1       	ldi	r22, 0x1A	; 26
     cba:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// TX start
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
     cbe:	84 e0       	ldi	r24, 0x04	; 4
     cc0:	64 e2       	ldi	r22, 0x24	; 36
     cc2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
     cc6:	85 e0       	ldi	r24, 0x05	; 5
     cc8:	6a e1       	ldi	r22, 0x1A	; 26
     cca:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// TX end
	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
     cce:	86 e0       	ldi	r24, 0x06	; 6
     cd0:	60 e0       	ldi	r22, 0x00	; 0
     cd2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
     cd6:	87 e0       	ldi	r24, 0x07	; 7
     cd8:	60 e2       	ldi	r22, 0x20	; 32
     cda:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
     cde:	80 ec       	ldi	r24, 0xC0	; 192
     ce0:	6d e0       	ldi	r22, 0x0D	; 13
     ce2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// bring MAC out of reset
	//enc28j60Write(MACON2, 0x00);

	// enable automatic padding to 60bytes and CRC operations
	enc28j60Write(MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
     ce6:	82 ec       	ldi	r24, 0xC2	; 194
     ce8:	62 e3       	ldi	r22, 0x32	; 50
     cea:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// Allow infinite deferals if the medium is continuously busy 
    // (do not time out a transmission if the half duplex medium is 
    // completely saturated with other people's data)
    enc28j60Write(MACON4, MACON4_DEFER);
     cee:	83 ec       	ldi	r24, 0xC3	; 195
     cf0:	60 e4       	ldi	r22, 0x40	; 64
     cf2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter)
	// 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
	// collisions will occur less often with a larger number.
    enc28j60Write(MACLCON2, 63);
     cf6:	89 ec       	ldi	r24, 0xC9	; 201
     cf8:	6f e3       	ldi	r22, 0x3F	; 63
     cfa:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
	// later.
	enc28j60Write(MAIPGL, 0x12);
     cfe:	86 ec       	ldi	r24, 0xC6	; 198
     d00:	62 e1       	ldi	r22, 0x12	; 18
     d02:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
     d06:	87 ec       	ldi	r24, 0xC7	; 199
     d08:	6c e0       	ldi	r22, 0x0C	; 12
     d0a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Set the maximum packet size which the controller will accept
    // Do not send packets longer than MAX_FRAMELEN:
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
     d0e:	8a ec       	ldi	r24, 0xCA	; 202
     d10:	6e ee       	ldi	r22, 0xEE	; 238
     d12:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
     d16:	8b ec       	ldi	r24, 0xCB	; 203
     d18:	65 e0       	ldi	r22, 0x05	; 5
     d1a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// do bank 3 stuff
    // write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	// ENC28J60 is big-endian avr gcc is little-endian
	enc28j60Write(MAADR5, avr_mac[0]);
     d1e:	84 ee       	ldi	r24, 0xE4	; 228
     d20:	68 81       	ld	r22, Y
     d22:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR4, avr_mac[1]);
     d26:	85 ee       	ldi	r24, 0xE5	; 229
     d28:	69 81       	ldd	r22, Y+1	; 0x01
     d2a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR3, avr_mac[2]);
     d2e:	82 ee       	ldi	r24, 0xE2	; 226
     d30:	6a 81       	ldd	r22, Y+2	; 0x02
     d32:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR2, avr_mac[3]);
     d36:	83 ee       	ldi	r24, 0xE3	; 227
     d38:	6b 81       	ldd	r22, Y+3	; 0x03
     d3a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR1, avr_mac[4]);
     d3e:	80 ee       	ldi	r24, 0xE0	; 224
     d40:	6c 81       	ldd	r22, Y+4	; 0x04
     d42:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR0, avr_mac[5]);
     d46:	81 ee       	ldi	r24, 0xE1	; 225
     d48:	6d 81       	ldd	r22, Y+5	; 0x05
     d4a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, (WORD_BYTES){PHCON2_HDLDIS});
     d4e:	80 e1       	ldi	r24, 0x10	; 16
     d50:	60 e0       	ldi	r22, 0x00	; 0
     d52:	71 e0       	ldi	r23, 0x01	; 1
     d54:	0e 94 fd 05 	call	0xbfa	; 0xbfa <enc28j60PhyWrite>
	
	// Magjack leds configuration, see enc28j60 datasheet, page 11
	// 0x476 is PHLCON LEDA=links status, LEDB=receive/transmit
	// enc28j60PhyWrite(PHLCON,0b0000 0100 0111 00 10);
	enc28j60PhyWrite(PHLCON,(WORD_BYTES){0x0472});
     d58:	84 e1       	ldi	r24, 0x14	; 20
     d5a:	62 e7       	ldi	r22, 0x72	; 114
     d5c:	74 e0       	ldi	r23, 0x04	; 4
     d5e:	0e 94 fd 05 	call	0xbfa	; 0xbfa <enc28j60PhyWrite>
	// Type     ETH.DST
	// ARP      BROADCAST
 	// 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
	// in binary these poitions are:11 0000 0011 1111
	// This is hex 303F->EPMM0=0x3f,EPMM1=0x30
	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
     d62:	88 e3       	ldi	r24, 0x38	; 56
     d64:	60 eb       	ldi	r22, 0xB0	; 176
     d66:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMM0, 0x3f);
     d6a:	88 e2       	ldi	r24, 0x28	; 40
     d6c:	6f e3       	ldi	r22, 0x3F	; 63
     d6e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMM1, 0x30);
     d72:	89 e2       	ldi	r24, 0x29	; 41
     d74:	60 e3       	ldi	r22, 0x30	; 48
     d76:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMCSL, 0xf9);
     d7a:	80 e3       	ldi	r24, 0x30	; 48
     d7c:	69 ef       	ldi	r22, 0xF9	; 249
     d7e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMCSH, 0xf7);
     d82:	81 e3       	ldi	r24, 0x31	; 49
     d84:	67 ef       	ldi	r22, 0xF7	; 247
     d86:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
     d8a:	84 ec       	ldi	r24, 0xC4	; 196
     d8c:	62 e1       	ldi	r22, 0x12	; 18
     d8e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// switch to bank 0
	enc28j60SetBank(ECON1);
     d92:	8f e1       	ldi	r24, 0x1F	; 31
     d94:	0e 94 c4 04 	call	0x988	; 0x988 <enc28j60SetBank>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     d98:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     d9a:	8b e9       	ldi	r24, 0x9B	; 155
     d9c:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     d9e:	77 9b       	sbis	0x0e, 7	; 14
     da0:	fe cf       	rjmp	.-4      	; 0xd9e <enc28j60_init+0x168>
	// write data
	SPDR = data;
     da2:	80 ec       	ldi	r24, 0xC0	; 192
     da4:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     da6:	77 9b       	sbis	0x0e, 7	; 14
     da8:	fe cf       	rjmp	.-4      	; 0xda6 <enc28j60_init+0x170>
	CSPASSIVE;
     daa:	c4 9a       	sbi	0x18, 4	; 24
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     dac:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     dae:	8f e9       	ldi	r24, 0x9F	; 159
     db0:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     db2:	77 9b       	sbis	0x0e, 7	; 14
     db4:	fe cf       	rjmp	.-4      	; 0xdb2 <enc28j60_init+0x17c>
	// write data
	SPDR = data;
     db6:	84 e0       	ldi	r24, 0x04	; 4
     db8:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     dba:	77 9b       	sbis	0x0e, 7	; 14
     dbc:	fe cf       	rjmp	.-4      	; 0xdba <enc28j60_init+0x184>
	CSPASSIVE;
     dbe:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);

	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);

	_delay_ms(20);
     dc0:	84 e1       	ldi	r24, 0x14	; 20
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>
}
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	08 95       	ret

00000dce <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     dce:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     dd0:	e1 99       	sbic	0x1c, 1	; 28
     dd2:	fe cf       	rjmp	.-4      	; 0xdd0 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     dd4:	3f bb       	out	0x1f, r19	; 31
     dd6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     dd8:	e0 9a       	sbi	0x1c, 0	; 28
     dda:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     ddc:	08 95       	ret

00000dde <server_process>:
// Function : server_process
// Description : Run web server and listen on port 80
//
//*****************************************************************************************
void server_process ( void )
{
     dde:	cf 92       	push	r12
     de0:	df 92       	push	r13
     de2:	ef 92       	push	r14
     de4:	ff 92       	push	r15
     de6:	0f 93       	push	r16
     de8:	1f 93       	push	r17
     dea:	df 93       	push	r29
     dec:	cf 93       	push	r28
     dee:	cd b7       	in	r28, 0x3d	; 61
     df0:	de b7       	in	r29, 0x3e	; 62
     df2:	c6 5e       	subi	r28, 0xE6	; 230
     df4:	d5 40       	sbci	r29, 0x05	; 5
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
	IP_ADDR client_ip;
	// you can change rx,tx buffer size in includes.h
	BYTE rxtx_buffer[MAX_RXTX_BUFFER];
	WORD plen;
	
	if ( flag1.bits.syn_is_sent )
     e00:	80 91 d4 00 	lds	r24, 0x00D4
     e04:	85 fd       	sbrc	r24, 5
     e06:	4d c0       	rjmp	.+154    	; 0xea2 <server_process+0xc4>
		return;
	// get new packet
	plen = enc28j60_packet_receive( (BYTE*)&rxtx_buffer, MAX_RXTX_BUFFER );
     e08:	ce 01       	movw	r24, r28
     e0a:	0b 96       	adiw	r24, 0x0b	; 11
     e0c:	6c ed       	ldi	r22, 0xDC	; 220
     e0e:	75 e0       	ldi	r23, 0x05	; 5
     e10:	0e 94 82 05 	call	0xb04	; 0xb04 <enc28j60_packet_receive>
	
	//plen will ne unequal to zero if there is a valid packet (without crc error)
	if(plen==0)
     e14:	89 2b       	or	r24, r25
     e16:	09 f4       	brne	.+2      	; 0xe1a <server_process+0x3c>
     e18:	44 c0       	rjmp	.+136    	; 0xea2 <server_process+0xc4>
		return;

	// copy client mac address from buffer to client mac variable
	memcpy ( (BYTE*)&client_mac, &rxtx_buffer[ ETH_SRC_MAC_P ], sizeof(MAC_ADDR) );
     e1a:	de 01       	movw	r26, r28
     e1c:	15 96       	adiw	r26, 0x05	; 5
     e1e:	fe 01       	movw	r30, r28
     e20:	71 96       	adiw	r30, 0x11	; 17
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	01 90       	ld	r0, Z+
     e26:	0d 92       	st	X+, r0
     e28:	81 50       	subi	r24, 0x01	; 1
     e2a:	e1 f7       	brne	.-8      	; 0xe24 <server_process+0x46>
	
	// check arp packet if match with avr ip let's send reply
	if ( arp_packet_is_arp( rxtx_buffer, (WORD_BYTES){ARP_OPCODE_REQUEST_V} ) )
     e2c:	9b e0       	ldi	r25, 0x0B	; 11
     e2e:	c9 2e       	mov	r12, r25
     e30:	d1 2c       	mov	r13, r1
     e32:	cc 0e       	add	r12, r28
     e34:	dd 1e       	adc	r13, r29
     e36:	c6 01       	movw	r24, r12
     e38:	61 e0       	ldi	r22, 0x01	; 1
     e3a:	70 e0       	ldi	r23, 0x00	; 0
     e3c:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <arp_packet_is_arp>
     e40:	88 23       	and	r24, r24
     e42:	39 f0       	breq	.+14     	; 0xe52 <server_process+0x74>
	{
		arp_send_reply ( (BYTE*)&rxtx_buffer, (BYTE*)&client_mac );
     e44:	c6 01       	movw	r24, r12
     e46:	be 01       	movw	r22, r28
     e48:	6b 5f       	subi	r22, 0xFB	; 251
     e4a:	7f 4f       	sbci	r23, 0xFF	; 255
     e4c:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <arp_send_reply>
     e50:	28 c0       	rjmp	.+80     	; 0xea2 <server_process+0xc4>
		return;
	}

	// get client ip address
	memcpy ( (BYTE*)&client_ip, &rxtx_buffer[ IP_SRC_IP_P ], sizeof(IP_ADDR) );
     e52:	8d a1       	ldd	r24, Y+37	; 0x25
     e54:	9e a1       	ldd	r25, Y+38	; 0x26
     e56:	af a1       	ldd	r26, Y+39	; 0x27
     e58:	b8 a5       	ldd	r27, Y+40	; 0x28
     e5a:	89 83       	std	Y+1, r24	; 0x01
     e5c:	9a 83       	std	Y+2, r25	; 0x02
     e5e:	ab 83       	std	Y+3, r26	; 0x03
     e60:	bc 83       	std	Y+4, r27	; 0x04
	// check ip packet send to avr or not?
	if ( ip_packet_is_ip ( (BYTE*)&rxtx_buffer ) == 0 )
     e62:	c6 01       	movw	r24, r12
     e64:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <ip_packet_is_ip>
     e68:	88 23       	and	r24, r24
     e6a:	d9 f0       	breq	.+54     	; 0xea2 <server_process+0xc4>
	{
		return;
	}

	// check ICMP packet, if packet is icmp packet let's send icmp echo reply
	if ( icmp_send_reply ( (BYTE*)&rxtx_buffer, (BYTE*)&client_mac, (BYTE*)&client_ip ) )
     e6c:	85 e0       	ldi	r24, 0x05	; 5
     e6e:	e8 2e       	mov	r14, r24
     e70:	f1 2c       	mov	r15, r1
     e72:	ec 0e       	add	r14, r28
     e74:	fd 1e       	adc	r15, r29
     e76:	c6 01       	movw	r24, r12
     e78:	b7 01       	movw	r22, r14
     e7a:	8e 01       	movw	r16, r28
     e7c:	0f 5f       	subi	r16, 0xFF	; 255
     e7e:	1f 4f       	sbci	r17, 0xFF	; 255
     e80:	a8 01       	movw	r20, r16
     e82:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <icmp_send_reply>
     e86:	88 23       	and	r24, r24
     e88:	61 f4       	brne	.+24     	; 0xea2 <server_process+0xc4>
	{
		return;
	}

	// check UDP packet
	if (udp_receive ( (BYTE *)&rxtx_buffer, (BYTE *)&client_mac, (BYTE *)&client_ip ))
     e8a:	c6 01       	movw	r24, r12
     e8c:	b7 01       	movw	r22, r14
     e8e:	a8 01       	movw	r20, r16
     e90:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <udp_receive>
     e94:	88 23       	and	r24, r24
     e96:	29 f4       	brne	.+10     	; 0xea2 <server_process+0xc4>
		return;
	}
	
	// tcp start here
	// start web server at port 80, see http.c
	http_webserver_process ( (BYTE*)rxtx_buffer, (BYTE*)&client_mac, (BYTE*)&client_ip );
     e98:	c6 01       	movw	r24, r12
     e9a:	b7 01       	movw	r22, r14
     e9c:	a8 01       	movw	r20, r16
     e9e:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <http_webserver_process>
}
     ea2:	ca 51       	subi	r28, 0x1A	; 26
     ea4:	da 4f       	sbci	r29, 0xFA	; 250
     ea6:	0f b6       	in	r0, 0x3f	; 63
     ea8:	f8 94       	cli
     eaa:	de bf       	out	0x3e, r29	; 62
     eac:	0f be       	out	0x3f, r0	; 63
     eae:	cd bf       	out	0x3d, r28	; 61
     eb0:	cf 91       	pop	r28
     eb2:	df 91       	pop	r29
     eb4:	1f 91       	pop	r17
     eb6:	0f 91       	pop	r16
     eb8:	ff 90       	pop	r15
     eba:	ef 90       	pop	r14
     ebc:	df 90       	pop	r13
     ebe:	cf 90       	pop	r12
     ec0:	08 95       	ret

00000ec2 <main>:
//
//*****************************************************************************************
int main (void)
{
	// Initializing heartbeat of the system
	initTimer_heartBeat();
     ec2:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <initTimer_heartBeat>
	
	// Initializing USART
	Init_USART(BAUD_PRESCALE);
     ec6:	8d e4       	ldi	r24, 0x4D	; 77
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <Init_USART>

	// Initializing GSM Modem
	Init_GSM();
     ece:	0e 94 44 10 	call	0x2088	; 0x2088 <Init_GSM>

	//USART_SendString("program initialized");

	// change your mac address here
	avr_mac.byte[0] = 'AA';
     ed2:	81 e4       	ldi	r24, 0x41	; 65
     ed4:	80 93 d5 00 	sts	0x00D5, r24
	avr_mac.byte[1] = 'FE';
     ed8:	85 e4       	ldi	r24, 0x45	; 69
     eda:	80 93 d6 00 	sts	0x00D6, r24
	avr_mac.byte[2] = '56';
     ede:	96 e3       	ldi	r25, 0x36	; 54
     ee0:	90 93 d7 00 	sts	0x00D7, r25
	avr_mac.byte[3] = 'D4';
     ee4:	84 e3       	ldi	r24, 0x34	; 52
     ee6:	80 93 d8 00 	sts	0x00D8, r24
	avr_mac.byte[4] = '76';
     eea:	90 93 d9 00 	sts	0x00D9, r25
	avr_mac.byte[5] = '87';
     eee:	87 e3       	ldi	r24, 0x37	; 55
     ef0:	80 93 da 00 	sts	0x00DA, r24

	// Changing the status of bulb and fan into initial states	
	CONTROL_DDR |= (1<<BULB_1_PIN);
     ef4:	a3 9a       	sbi	0x14, 3	; 20
	CONTROL_DDR |= (1<<BULB_2_PIN);
     ef6:	a4 9a       	sbi	0x14, 4	; 20
	CONTROL_DDR |= (1<<FAN_PIN);
     ef8:	a5 9a       	sbi	0x14, 5	; 20
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     efa:	8f ed       	ldi	r24, 0xDF	; 223
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	60 e0       	ldi	r22, 0x00	; 0
     f00:	70 e0       	ldi	r23, 0x00	; 0
     f02:	44 e0       	ldi	r20, 0x04	; 4
     f04:	50 e0       	ldi	r21, 0x00	; 0
     f06:	27 ee       	ldi	r18, 0xE7	; 231
     f08:	36 e0       	ldi	r19, 0x06	; 6
     f0a:	0e 94 4d 10 	call	0x209a	; 0x209a <__eerd_block>
	eeprom_read_block ( &avr_ip, ee_avr_ip, 4 );
	eeprom_read_block ( &server_ip, ee_server_ip, 4 );
	

	// initialiing enc28j60/Ehternet IC
	enc28j60_init( (BYTE*)&avr_mac );
     f0e:	8b ed       	ldi	r24, 0xDB	; 219
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	64 e0       	ldi	r22, 0x04	; 4
     f14:	70 e0       	ldi	r23, 0x00	; 0
     f16:	44 e0       	ldi	r20, 0x04	; 4
     f18:	50 e0       	ldi	r21, 0x00	; 0
     f1a:	27 ee       	ldi	r18, 0xE7	; 231
     f1c:	36 e0       	ldi	r19, 0x06	; 6
     f1e:	0e 94 4d 10 	call	0x209a	; 0x209a <__eerd_block>
     f22:	85 ed       	ldi	r24, 0xD5	; 213
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	0e 94 1b 06 	call	0xc36	; 0xc36 <enc28j60_init>
	// loop forever
	// Infinite looping for continuous process
	for(;;)
	{
		// server process response for arp, icmp, http
		server_process ();
     f2a:	0e 94 ef 06 	call	0xdde	; 0xdde <server_process>
     f2e:	fd cf       	rjmp	.-6      	; 0xf2a <main+0x68>

00000f30 <http_get_ip>:
// 10.1.1.1 (ascii), http_get_ip function convert ip address in ascii to binary and stored
// in BYTE *dest
//
//********************************************************************************************
unsigned char http_get_ip ( unsigned char *buf, BYTE *dest )
{
     f30:	dc 01       	movw	r26, r24
     f32:	40 e0       	ldi	r20, 0x00	; 0
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	21 e0       	ldi	r18, 0x01	; 1

		if ( ch >= '0' && ch <= '9' )
		{
			ch = ch - '0';
			temp = (temp * digit) + ch;
			digit *= 10;
     f38:	5a e0       	ldi	r21, 0x0A	; 10
	digit = 1;
	temp = 0;

	while ( 1 )
	{
		ch = *buf++;
     f3a:	9d 91       	ld	r25, X+

		if ( ch >= '0' && ch <= '9' )
     f3c:	39 2f       	mov	r19, r25
     f3e:	30 53       	subi	r19, 0x30	; 48
     f40:	3a 30       	cpi	r19, 0x0A	; 10
     f42:	40 f4       	brcc	.+16     	; 0xf54 <http_get_ip+0x24>
		{
			ch = ch - '0';
			temp = (temp * digit) + ch;
     f44:	24 9f       	mul	r18, r20
     f46:	40 2d       	mov	r20, r0
     f48:	11 24       	eor	r1, r1
     f4a:	43 0f       	add	r20, r19
			digit *= 10;
     f4c:	25 9f       	mul	r18, r21
     f4e:	20 2d       	mov	r18, r0
     f50:	11 24       	eor	r1, r1
     f52:	0d c0       	rjmp	.+26     	; 0xf6e <http_get_ip+0x3e>
		}
		else if ( ch == '.' || ch == '\0' )
     f54:	9e 32       	cpi	r25, 0x2E	; 46
     f56:	21 f0       	breq	.+8      	; 0xf60 <http_get_ip+0x30>
     f58:	99 23       	and	r25, r25
     f5a:	11 f0       	breq	.+4      	; 0xf60 <http_get_ip+0x30>
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	08 95       	ret
		{
			dest[ i ] = temp;
     f60:	fb 01       	movw	r30, r22
     f62:	e8 0f       	add	r30, r24
     f64:	f1 1d       	adc	r31, r1
     f66:	40 83       	st	Z, r20
			i++;
     f68:	8f 5f       	subi	r24, 0xFF	; 255
     f6a:	40 e0       	ldi	r20, 0x00	; 0
     f6c:	21 e0       	ldi	r18, 0x01	; 1
		}
		else
		{
			return 0;
		}
		if ( i == 4 )
     f6e:	84 30       	cpi	r24, 0x04	; 4
     f70:	21 f7       	brne	.-56     	; 0xf3a <http_get_ip+0xa>
			return i;
	}
}
     f72:	08 95       	ret

00000f74 <hex2int>:
// Function : hex2int
// Description : convert a single hex digit character to its integer value
//
//********************************************************************************************
unsigned char hex2int(char c)
{
     f74:	98 2f       	mov	r25, r24
	if (c >= '0' && c <='9')
     f76:	80 53       	subi	r24, 0x30	; 48
     f78:	8a 30       	cpi	r24, 0x0A	; 10
     f7a:	68 f0       	brcs	.+26     	; 0xf96 <hex2int+0x22>
		return((unsigned char)c - '0');

	if (c >= 'a' && c <='f')
     f7c:	81 53       	subi	r24, 0x31	; 49
     f7e:	86 30       	cpi	r24, 0x06	; 6
     f80:	10 f4       	brcc	.+4      	; 0xf86 <hex2int+0x12>
		return((unsigned char)c - 'a' + 10);
     f82:	86 5f       	subi	r24, 0xF6	; 246
     f84:	08 95       	ret
	
	if (c >= 'A' && c <='F')
     f86:	89 2f       	mov	r24, r25
     f88:	81 54       	subi	r24, 0x41	; 65
     f8a:	86 30       	cpi	r24, 0x06	; 6
     f8c:	10 f0       	brcs	.+4      	; 0xf92 <hex2int+0x1e>
     f8e:	80 e0       	ldi	r24, 0x00	; 0
     f90:	08 95       	ret
		return((unsigned char)c - 'A' + 10);
     f92:	89 2f       	mov	r24, r25
     f94:	87 53       	subi	r24, 0x37	; 55

	return 0;
}
     f96:	08 95       	ret

00000f98 <urldecode>:
// Function : urldecode
// Description : decode a url string e.g "hello%20joe" or "hello+joe" becomes "hello joe"
//
//********************************************************************************************
void urldecode(unsigned char *urlbuf)
{
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	fc 01       	movw	r30, r24
     f9e:	ec 01       	movw	r28, r24
     fa0:	37 c0       	rjmp	.+110    	; 0x1010 <urldecode+0x78>
	unsigned char *dst;

	dst=urlbuf;
	while ((c = *urlbuf))
	{
		if (c == '+') c = ' ';
     fa2:	8b 32       	cpi	r24, 0x2B	; 43
     fa4:	11 f4       	brne	.+4      	; 0xfaa <urldecode+0x12>
     fa6:	80 e2       	ldi	r24, 0x20	; 32
     fa8:	31 c0       	rjmp	.+98     	; 0x100c <urldecode+0x74>
		if (c == '%')
     faa:	85 32       	cpi	r24, 0x25	; 37
     fac:	79 f5       	brne	.+94     	; 0x100c <urldecode+0x74>
		{
			urlbuf++;
     fae:	df 01       	movw	r26, r30
     fb0:	11 96       	adiw	r26, 0x01	; 1
			c = *urlbuf;
     fb2:	91 81       	ldd	r25, Z+1	; 0x01
			urlbuf++;
     fb4:	fd 01       	movw	r30, r26
     fb6:	31 96       	adiw	r30, 0x01	; 1
// Description : convert a single hex digit character to its integer value
//
//********************************************************************************************
unsigned char hex2int(char c)
{
	if (c >= '0' && c <='9')
     fb8:	39 2f       	mov	r19, r25
     fba:	30 53       	subi	r19, 0x30	; 48
     fbc:	3a 30       	cpi	r19, 0x0A	; 10
     fbe:	70 f0       	brcs	.+28     	; 0xfdc <urldecode+0x44>
		return((unsigned char)c - '0');

	if (c >= 'a' && c <='f')
     fc0:	89 2f       	mov	r24, r25
     fc2:	81 56       	subi	r24, 0x61	; 97
     fc4:	86 30       	cpi	r24, 0x06	; 6
     fc6:	10 f4       	brcc	.+4      	; 0xfcc <urldecode+0x34>
		return((unsigned char)c - 'a' + 10);
     fc8:	37 52       	subi	r19, 0x27	; 39
     fca:	08 c0       	rjmp	.+16     	; 0xfdc <urldecode+0x44>
	
	if (c >= 'A' && c <='F')
     fcc:	89 2f       	mov	r24, r25
     fce:	81 54       	subi	r24, 0x41	; 65
     fd0:	86 30       	cpi	r24, 0x06	; 6
     fd2:	10 f0       	brcs	.+4      	; 0xfd8 <urldecode+0x40>
     fd4:	30 e0       	ldi	r19, 0x00	; 0
     fd6:	02 c0       	rjmp	.+4      	; 0xfdc <urldecode+0x44>
		return((unsigned char)c - 'A' + 10);
     fd8:	39 2f       	mov	r19, r25
     fda:	37 53       	subi	r19, 0x37	; 55
		if (c == '%')
		{
			urlbuf++;
			c = *urlbuf;
			urlbuf++;
			c = (hex2int(c) << 4) | hex2int(*urlbuf);
     fdc:	11 96       	adiw	r26, 0x01	; 1
     fde:	2c 91       	ld	r18, X
// Description : convert a single hex digit character to its integer value
//
//********************************************************************************************
unsigned char hex2int(char c)
{
	if (c >= '0' && c <='9')
     fe0:	92 2f       	mov	r25, r18
     fe2:	90 53       	subi	r25, 0x30	; 48
     fe4:	9a 30       	cpi	r25, 0x0A	; 10
     fe6:	70 f0       	brcs	.+28     	; 0x1004 <urldecode+0x6c>
		return((unsigned char)c - '0');

	if (c >= 'a' && c <='f')
     fe8:	82 2f       	mov	r24, r18
     fea:	81 56       	subi	r24, 0x61	; 97
     fec:	86 30       	cpi	r24, 0x06	; 6
     fee:	10 f4       	brcc	.+4      	; 0xff4 <urldecode+0x5c>
		return((unsigned char)c - 'a' + 10);
     ff0:	97 52       	subi	r25, 0x27	; 39
     ff2:	08 c0       	rjmp	.+16     	; 0x1004 <urldecode+0x6c>
	
	if (c >= 'A' && c <='F')
     ff4:	82 2f       	mov	r24, r18
     ff6:	81 54       	subi	r24, 0x41	; 65
     ff8:	86 30       	cpi	r24, 0x06	; 6
     ffa:	10 f0       	brcs	.+4      	; 0x1000 <urldecode+0x68>
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	02 c0       	rjmp	.+4      	; 0x1004 <urldecode+0x6c>
		return((unsigned char)c - 'A' + 10);
    1000:	92 2f       	mov	r25, r18
    1002:	97 53       	subi	r25, 0x37	; 55
		if (c == '%')
		{
			urlbuf++;
			c = *urlbuf;
			urlbuf++;
			c = (hex2int(c) << 4) | hex2int(*urlbuf);
    1004:	83 2f       	mov	r24, r19
    1006:	82 95       	swap	r24
    1008:	80 7f       	andi	r24, 0xF0	; 240
    100a:	89 2b       	or	r24, r25
		}
		*dst = c;
    100c:	89 93       	st	Y+, r24
		dst++;
		urlbuf++;
    100e:	31 96       	adiw	r30, 0x01	; 1
{
	unsigned char c;
	unsigned char *dst;

	dst=urlbuf;
	while ((c = *urlbuf))
    1010:	80 81       	ld	r24, Z
    1012:	88 23       	and	r24, r24
    1014:	31 f6       	brne	.-116    	; 0xfa2 <urldecode+0xa>
		}
		*dst = c;
		dst++;
		urlbuf++;
	}
	*dst = '\0';
    1016:	18 82       	st	Y, r1
}
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	08 95       	ret

0000101e <http_control>:
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nContent-Type: text/html\r\nConnection: keep-alive\r\n\r\n"), 0 );
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("success"), dlen );
	return (dlen);
}

WORD http_control( BYTE *rxtx_buffer ) {
    101e:	cf 93       	push	r28
    1020:	df 93       	push	r29
    1022:	ec 01       	movw	r28, r24
	WORD dlen;
	
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nContent-Type: text/html\r\nConnection: keep-alive\r\n\r\n"), 0 );
    1024:	66 e1       	ldi	r22, 0x16	; 22
    1026:	77 e0       	ldi	r23, 0x07	; 7
    1028:	40 e0       	ldi	r20, 0x00	; 0
    102a:	50 e0       	ldi	r21, 0x00	; 0
    102c:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1030:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<!DOCTYPE html>"), dlen );
    1032:	ce 01       	movw	r24, r28
    1034:	66 e0       	ldi	r22, 0x06	; 6
    1036:	77 e0       	ldi	r23, 0x07	; 7
    1038:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    103c:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<html><head>"), dlen );
    103e:	ce 01       	movw	r24, r28
    1040:	69 ef       	ldi	r22, 0xF9	; 249
    1042:	76 e0       	ldi	r23, 0x06	; 6
    1044:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1048:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<title>Control Room || emBank</title>"), dlen );
    104a:	ce 01       	movw	r24, r28
    104c:	63 ed       	ldi	r22, 0xD3	; 211
    104e:	76 e0       	ldi	r23, 0x06	; 6
    1050:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1054:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<title>Control Room || emBank</title>"), dlen );
    1056:	ce 01       	movw	r24, r28
    1058:	6d ea       	ldi	r22, 0xAD	; 173
    105a:	76 e0       	ldi	r23, 0x06	; 6
    105c:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1060:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<link rel=stylesheet type=text/css href=http://192.168.53.3/a/c/s.css />"), dlen );
    1062:	ce 01       	movw	r24, r28
    1064:	64 e6       	ldi	r22, 0x64	; 100
    1066:	76 e0       	ldi	r23, 0x06	; 6
    1068:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    106c:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</head><body>"), dlen );
    106e:	ce 01       	movw	r24, r28
    1070:	66 e5       	ldi	r22, 0x56	; 86
    1072:	76 e0       	ldi	r23, 0x06	; 6
    1074:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1078:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<section id=layout>"), dlen );
    107a:	ce 01       	movw	r24, r28
    107c:	62 e4       	ldi	r22, 0x42	; 66
    107e:	76 e0       	ldi	r23, 0x06	; 6
    1080:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1084:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<section class=\"home\">"), dlen );
    1086:	ce 01       	movw	r24, r28
    1088:	6b e2       	ldi	r22, 0x2B	; 43
    108a:	76 e0       	ldi	r23, 0x06	; 6
    108c:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1090:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<header>"), dlen );
    1092:	ce 01       	movw	r24, r28
    1094:	62 e2       	ldi	r22, 0x22	; 34
    1096:	76 e0       	ldi	r23, 0x06	; 6
    1098:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    109c:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=logo><a href=http://192.168.53.3/ ></a></div>"), dlen );
    109e:	ce 01       	movw	r24, r28
    10a0:	69 ee       	ldi	r22, 0xE9	; 233
    10a2:	75 e0       	ldi	r23, 0x05	; 5
    10a4:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10a8:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=\"tag-line\"><span>Embedded Server based Tansaction System</span></div>"), dlen );
    10aa:	ce 01       	movw	r24, r28
    10ac:	68 e9       	ldi	r22, 0x98	; 152
    10ae:	75 e0       	ldi	r23, 0x05	; 5
    10b0:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10b4:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<nav><ul>"), dlen );
    10b6:	ce 01       	movw	r24, r28
    10b8:	6e e8       	ldi	r22, 0x8E	; 142
    10ba:	75 e0       	ldi	r23, 0x05	; 5
    10bc:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10c0:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<li><a href=http://192.168.53.3/>home</a></li>"), dlen );
    10c2:	ce 01       	movw	r24, r28
    10c4:	6f e5       	ldi	r22, 0x5F	; 95
    10c6:	75 e0       	ldi	r23, 0x05	; 5
    10c8:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10cc:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<li><a href=http://192.168.53.3/>account</a></li>"), dlen );
    10ce:	ce 01       	movw	r24, r28
    10d0:	6d e2       	ldi	r22, 0x2D	; 45
    10d2:	75 e0       	ldi	r23, 0x05	; 5
    10d4:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10d8:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</ul></nav>"), dlen );
    10da:	ce 01       	movw	r24, r28
    10dc:	61 e2       	ldi	r22, 0x21	; 33
    10de:	75 e0       	ldi	r23, 0x05	; 5
    10e0:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10e4:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div></header>"), dlen );
    10e6:	ce 01       	movw	r24, r28
    10e8:	60 e0       	ldi	r22, 0x00	; 0
    10ea:	75 e0       	ldi	r23, 0x05	; 5
    10ec:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10f0:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<section id=user-reg class=\"splash-content register\">"), dlen );
    10f2:	ce 01       	movw	r24, r28
    10f4:	6a ec       	ldi	r22, 0xCA	; 202
    10f6:	74 e0       	ldi	r23, 0x04	; 4
    10f8:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    10fc:	ac 01       	movw	r20, r24
	
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=control><div class=cItem>"), dlen );
    10fe:	ce 01       	movw	r24, r28
    1100:	65 ea       	ldi	r22, 0xA5	; 165
    1102:	74 e0       	ldi	r23, 0x04	; 4
    1104:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1108:	ac 01       	movw	r20, r24

	if(bulb_1 == 1) {
    110a:	80 91 cd 00 	lds	r24, 0x00CD
    110e:	90 91 ce 00 	lds	r25, 0x00CE
    1112:	81 30       	cpi	r24, 0x01	; 1
    1114:	91 05       	cpc	r25, r1
    1116:	51 f4       	brne	.+20     	; 0x112c <http_control+0x10e>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-n.png />"), dlen );
    1118:	ce 01       	movw	r24, r28
    111a:	6e e6       	ldi	r22, 0x6E	; 110
    111c:	74 e0       	ldi	r23, 0x04	; 4
    111e:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1122:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb1=0><img class=switch src=http://192.168.53.3/a/i/s-n.png></a>"), dlen );
    1124:	ce 01       	movw	r24, r28
    1126:	67 e1       	ldi	r22, 0x17	; 23
    1128:	74 e0       	ldi	r23, 0x04	; 4
    112a:	0b c0       	rjmp	.+22     	; 0x1142 <http_control+0x124>
	} else if(bulb_1 == 0) {
    112c:	89 2b       	or	r24, r25
    112e:	61 f4       	brne	.+24     	; 0x1148 <http_control+0x12a>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-f.png />"), dlen );
    1130:	ce 01       	movw	r24, r28
    1132:	60 ee       	ldi	r22, 0xE0	; 224
    1134:	73 e0       	ldi	r23, 0x03	; 3
    1136:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    113a:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb1=1><img class=switch src=http://192.168.53.3/a/i/s-f.png></a>"), dlen );
    113c:	ce 01       	movw	r24, r28
    113e:	69 e8       	ldi	r22, 0x89	; 137
    1140:	73 e0       	ldi	r23, 0x03	; 3
    1142:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1146:	ac 01       	movw	r20, r24
	}

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div>"), dlen );
    1148:	ce 01       	movw	r24, r28
    114a:	61 e7       	ldi	r22, 0x71	; 113
    114c:	73 e0       	ldi	r23, 0x03	; 3
    114e:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1152:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</div><div class=cItem>"), dlen );
    1154:	ce 01       	movw	r24, r28
    1156:	69 e5       	ldi	r22, 0x59	; 89
    1158:	73 e0       	ldi	r23, 0x03	; 3
    115a:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    115e:	ac 01       	movw	r20, r24

	if(bulb_2 == 1) {
    1160:	80 91 cf 00 	lds	r24, 0x00CF
    1164:	90 91 d0 00 	lds	r25, 0x00D0
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	91 05       	cpc	r25, r1
    116c:	51 f4       	brne	.+20     	; 0x1182 <http_control+0x164>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-n.png />"), dlen );
    116e:	ce 01       	movw	r24, r28
    1170:	62 e2       	ldi	r22, 0x22	; 34
    1172:	73 e0       	ldi	r23, 0x03	; 3
    1174:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1178:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb2=0><img class=switch src=http://192.168.53.3/a/i/s-n.png></a>"), dlen );
    117a:	ce 01       	movw	r24, r28
    117c:	6b ec       	ldi	r22, 0xCB	; 203
    117e:	72 e0       	ldi	r23, 0x02	; 2
    1180:	0b c0       	rjmp	.+22     	; 0x1198 <http_control+0x17a>
	} else if(bulb_2 == 0) {
    1182:	89 2b       	or	r24, r25
    1184:	61 f4       	brne	.+24     	; 0x119e <http_control+0x180>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-f.png />"), dlen );
    1186:	ce 01       	movw	r24, r28
    1188:	64 e9       	ldi	r22, 0x94	; 148
    118a:	72 e0       	ldi	r23, 0x02	; 2
    118c:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1190:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb2=1><img class=switch src=http://192.168.53.3/a/i/s-f.png></a>"), dlen );
    1192:	ce 01       	movw	r24, r28
    1194:	6d e3       	ldi	r22, 0x3D	; 61
    1196:	72 e0       	ldi	r23, 0x02	; 2
    1198:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    119c:	ac 01       	movw	r20, r24
	}

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div>"), dlen );
    119e:	ce 01       	movw	r24, r28
    11a0:	65 e2       	ldi	r22, 0x25	; 37
    11a2:	72 e0       	ldi	r23, 0x02	; 2
    11a4:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    11a8:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</div><div class=cItem>"), dlen );
    11aa:	ce 01       	movw	r24, r28
    11ac:	6d e0       	ldi	r22, 0x0D	; 13
    11ae:	72 e0       	ldi	r23, 0x02	; 2
    11b0:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    11b4:	ac 01       	movw	r20, r24

	if(fan == 1) {
    11b6:	80 91 d1 00 	lds	r24, 0x00D1
    11ba:	90 91 d2 00 	lds	r25, 0x00D2
    11be:	81 30       	cpi	r24, 0x01	; 1
    11c0:	91 05       	cpc	r25, r1
    11c2:	51 f4       	brne	.+20     	; 0x11d8 <http_control+0x1ba>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=\"fan rotating\" src=http://192.168.53.3/a/i/fan.png />"), dlen );
    11c4:	ce 01       	movw	r24, r28
    11c6:	6c ec       	ldi	r22, 0xCC	; 204
    11c8:	71 e0       	ldi	r23, 0x01	; 1
    11ca:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    11ce:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&fan=0><img class=switch src=http://192.168.53.3/a/i/s-n.png></a>"), dlen );
    11d0:	ce 01       	movw	r24, r28
    11d2:	67 e7       	ldi	r22, 0x77	; 119
    11d4:	71 e0       	ldi	r23, 0x01	; 1
    11d6:	0b c0       	rjmp	.+22     	; 0x11ee <http_control+0x1d0>
	} else if(fan == 0) {
    11d8:	89 2b       	or	r24, r25
    11da:	61 f4       	brne	.+24     	; 0x11f4 <http_control+0x1d6>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=\"fan\" src=http://192.168.53.3/a/i/fan.png />"), dlen );
    11dc:	ce 01       	movw	r24, r28
    11de:	6f e3       	ldi	r22, 0x3F	; 63
    11e0:	71 e0       	ldi	r23, 0x01	; 1
    11e2:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    11e6:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&fan=1><img class=switch src=http://192.168.53.3/a/i/s-f.png></a>"), dlen );
    11e8:	ce 01       	movw	r24, r28
    11ea:	6a ee       	ldi	r22, 0xEA	; 234
    11ec:	70 e0       	ldi	r23, 0x00	; 0
    11ee:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    11f2:	ac 01       	movw	r20, r24
	}

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div>"), dlen );
    11f4:	ce 01       	movw	r24, r28
    11f6:	62 ed       	ldi	r22, 0xD2	; 210
    11f8:	70 e0       	ldi	r23, 0x00	; 0
    11fa:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    11fe:	ac 01       	movw	r20, r24

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</div></div></section></section><footer>"), dlen );
    1200:	ce 01       	movw	r24, r28
    1202:	69 ea       	ldi	r22, 0xA9	; 169
    1204:	70 e0       	ldi	r23, 0x00	; 0
    1206:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    120a:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("Copyright &copy; 2014 emBank. All rights reserved."), dlen );
    120c:	ce 01       	movw	r24, r28
    120e:	66 e7       	ldi	r22, 0x76	; 118
    1210:	70 e0       	ldi	r23, 0x00	; 0
    1212:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1216:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</footer></section></body></html>"), dlen );
    1218:	ce 01       	movw	r24, r28
    121a:	64 e5       	ldi	r22, 0x54	; 84
    121c:	70 e0       	ldi	r23, 0x00	; 0
    121e:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>

	return (dlen);
}
    1222:	df 91       	pop	r29
    1224:	cf 91       	pop	r28
    1226:	08 95       	ret

00001228 <http_test>:
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR ( "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n" ), 0 );
	
	return (dlen);
}

WORD http_test( BYTE *rxtx_buffer ) {
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	8c 01       	movw	r16, r24
	WORD dlen;
	
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nContent-Type: text/html\r\nConnection: keep-alive\r\n\r\n"), 0 );
    122e:	63 e8       	ldi	r22, 0x83	; 131
    1230:	77 e0       	ldi	r23, 0x07	; 7
    1232:	40 e0       	ldi	r20, 0x00	; 0
    1234:	50 e0       	ldi	r21, 0x00	; 0
    1236:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    123a:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("success"), dlen );
    123c:	c8 01       	movw	r24, r16
    123e:	6b e7       	ldi	r22, 0x7B	; 123
    1240:	77 e0       	ldi	r23, 0x07	; 7
    1242:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
	return (dlen);
}
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	08 95       	ret

0000124c <http_home>:
WORD http_home( BYTE *rxtx_buffer )
{
	WORD dlen;
	BYTE generic_buf[64];

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR ( "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n" ), 0 );
    124c:	68 ee       	ldi	r22, 0xE8	; 232
    124e:	77 e0       	ldi	r23, 0x07	; 7
    1250:	40 e0       	ldi	r20, 0x00	; 0
    1252:	50 e0       	ldi	r21, 0x00	; 0
    1254:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
	
	return (dlen);
}
    1258:	08 95       	ret

0000125a <http_put_request>:
// Description : put http request to tx buffer contain 2-variables pwd and temp.
// webserver receive pwd, temp and save to text file by PHP script on webserver.
//
//*****************************************************************************************
WORD http_put_request ( BYTE *rxtx_buffer )
{
    125a:	0f 93       	push	r16
    125c:	1f 93       	push	r17
    125e:	df 93       	push	r29
    1260:	cf 93       	push	r28
    1262:	cd b7       	in	r28, 0x3d	; 61
    1264:	de b7       	in	r29, 0x3e	; 62
    1266:	c0 54       	subi	r28, 0x40	; 64
    1268:	d0 40       	sbci	r29, 0x00	; 0
    126a:	0f b6       	in	r0, 0x3f	; 63
    126c:	f8 94       	cli
    126e:	de bf       	out	0x3e, r29	; 62
    1270:	0f be       	out	0x3f, r0	; 63
    1272:	cd bf       	out	0x3d, r28	; 61
    1274:	8c 01       	movw	r16, r24
	BYTE temp_value;
	WORD dlength;
	BYTE generic_buf[64];
	

	generic_buf[ 2 ] = '\0';
    1276:	1b 82       	std	Y+3, r1	; 0x03

	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "GET /avrnet/save.php?pwd=secret&temp=" ), 0 );
    1278:	6f e8       	ldi	r22, 0x8F	; 143
    127a:	78 e0       	ldi	r23, 0x08	; 8
    127c:	40 e0       	ldi	r20, 0x00	; 0
    127e:	50 e0       	ldi	r21, 0x00	; 0
    1280:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1284:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data ( rxtx_buffer, (BYTE *)generic_buf, dlength );
    1286:	c8 01       	movw	r24, r16
    1288:	be 01       	movw	r22, r28
    128a:	6f 5f       	subi	r22, 0xFF	; 255
    128c:	7f 4f       	sbci	r23, 0xFF	; 255
    128e:	0e 94 c0 0c 	call	0x1980	; 0x1980 <tcp_puts_data>
    1292:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( " HTTP/1.0\r\n" ), dlength );
    1294:	c8 01       	movw	r24, r16
    1296:	63 e8       	ldi	r22, 0x83	; 131
    1298:	78 e0       	ldi	r23, 0x08	; 8
    129a:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    129e:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Host: 10.1.1.76\r\n" ), dlength );
    12a0:	c8 01       	movw	r24, r16
    12a2:	61 e7       	ldi	r22, 0x71	; 113
    12a4:	78 e0       	ldi	r23, 0x08	; 8
    12a6:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    12aa:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "User-Agent: AVR ethernet\r\n" ), dlength );
    12ac:	c8 01       	movw	r24, r16
    12ae:	66 e5       	ldi	r22, 0x56	; 86
    12b0:	78 e0       	ldi	r23, 0x08	; 8
    12b2:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    12b6:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Accept: text/html\r\n" ), dlength );
    12b8:	c8 01       	movw	r24, r16
    12ba:	62 e4       	ldi	r22, 0x42	; 66
    12bc:	78 e0       	ldi	r23, 0x08	; 8
    12be:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    12c2:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Keep-Alive: 300\r\n" ), dlength );
    12c4:	c8 01       	movw	r24, r16
    12c6:	60 e3       	ldi	r22, 0x30	; 48
    12c8:	78 e0       	ldi	r23, 0x08	; 8
    12ca:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    12ce:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Connection: keep-alive\r\n\r\n" ), dlength );
    12d0:	c8 01       	movw	r24, r16
    12d2:	65 e1       	ldi	r22, 0x15	; 21
    12d4:	78 e0       	ldi	r23, 0x08	; 8
    12d6:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>

	return dlength;
}
    12da:	c0 5c       	subi	r28, 0xC0	; 192
    12dc:	df 4f       	sbci	r29, 0xFF	; 255
    12de:	0f b6       	in	r0, 0x3f	; 63
    12e0:	f8 94       	cli
    12e2:	de bf       	out	0x3e, r29	; 62
    12e4:	0f be       	out	0x3f, r0	; 63
    12e6:	cd bf       	out	0x3d, r28	; 61
    12e8:	cf 91       	pop	r28
    12ea:	df 91       	pop	r29
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	08 95       	ret

000012f2 <http_get_variable>:
//		when you call http_get_variable with val_key="pwd", then function stored "123456"
//		to dest buffer.
//
//********************************************************************************************
BYTE http_get_variable ( BYTE *rxtx_buffer, WORD dlength, PGM_P val_key, BYTE *dest )
{
    12f2:	cf 92       	push	r12
    12f4:	df 92       	push	r13
    12f6:	ef 92       	push	r14
    12f8:	ff 92       	push	r15
    12fa:	0f 93       	push	r16
    12fc:	1f 93       	push	r17
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	ec 01       	movw	r28, r24
    1304:	8b 01       	movw	r16, r22
    1306:	6a 01       	movw	r12, r20
    1308:	79 01       	movw	r14, r18
	BYTE match=0, temp;

	key = val_key;
	
	// get data position
	data_p = tcp_get_hlength( rxtx_buffer ) + sizeof(ETH_HEADER) + sizeof(IP_HEADER);
    130a:	0e 94 a6 0c 	call	0x194c	; 0x194c <tcp_get_hlength>
    130e:	28 2f       	mov	r18, r24
    1310:	30 e0       	ldi	r19, 0x00	; 0
    1312:	2e 5d       	subi	r18, 0xDE	; 222
    1314:	3f 4f       	sbci	r19, 0xFF	; 255
    1316:	fe 01       	movw	r30, r28
    1318:	e2 0f       	add	r30, r18
    131a:	f3 1f       	adc	r31, r19
    131c:	05 c0       	rjmp	.+10     	; 0x1328 <http_get_variable+0x36>

	// Find '?' in rx buffer, if found '?' in rx buffer then let's find variable key (val_key)
	for ( ; data_p<dlength; data_p++ )
	{
		if ( rxtx_buffer [ data_p ] == '?' )
    131e:	81 91       	ld	r24, Z+
    1320:	8f 33       	cpi	r24, 0x3F	; 63
    1322:	29 f0       	breq	.+10     	; 0x132e <http_get_variable+0x3c>
	
	// get data position
	data_p = tcp_get_hlength( rxtx_buffer ) + sizeof(ETH_HEADER) + sizeof(IP_HEADER);

	// Find '?' in rx buffer, if found '?' in rx buffer then let's find variable key (val_key)
	for ( ; data_p<dlength; data_p++ )
    1324:	2f 5f       	subi	r18, 0xFF	; 255
    1326:	3f 4f       	sbci	r19, 0xFF	; 255
    1328:	20 17       	cp	r18, r16
    132a:	31 07       	cpc	r19, r17
    132c:	c0 f3       	brcs	.-16     	; 0x131e <http_get_variable+0x2c>
	{
		if ( rxtx_buffer [ data_p ] == '?' )
			break;
	}
	// not found '?' in buffer
	if ( data_p == dlength )
    132e:	20 17       	cp	r18, r16
    1330:	31 07       	cpc	r19, r17
    1332:	a9 f1       	breq	.+106    	; 0x139e <http_get_variable+0xac>
    1334:	de 01       	movw	r26, r28
    1336:	a2 0f       	add	r26, r18
    1338:	b3 1f       	adc	r27, r19
    133a:	f6 01       	movw	r30, r12
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	15 c0       	rjmp	.+42     	; 0x136a <http_get_variable+0x78>
		return 0;
	
	// find variable key in buffer 
	for ( ; data_p<dlength; data_p++ )
	{
		temp = pgm_read_byte ( key );
    1340:	44 91       	lpm	r20, Z+

		// end of variable keyword
		if ( rxtx_buffer [ data_p ] == '=' && match != 0 )
    1342:	9c 91       	ld	r25, X
    1344:	9d 33       	cpi	r25, 0x3D	; 61
    1346:	39 f4       	brne	.+14     	; 0x1356 <http_get_variable+0x64>
    1348:	88 23       	and	r24, r24
    134a:	29 f0       	breq	.+10     	; 0x1356 <http_get_variable+0x64>
		{
			if ( temp == '\0' )
    134c:	44 23       	and	r20, r20
    134e:	19 f4       	brne	.+6      	; 0x1356 <http_get_variable+0x64>
			{
				data_p++;
    1350:	2f 5f       	subi	r18, 0xFF	; 255
    1352:	3f 4f       	sbci	r19, 0xFF	; 255
    1354:	0f c0       	rjmp	.+30     	; 0x1374 <http_get_variable+0x82>
				break;
			}
		}
		// variable keyword match with rx buffer
		if ( rxtx_buffer [ data_p ] == temp )
    1356:	94 17       	cp	r25, r20
    1358:	19 f0       	breq	.+6      	; 0x1360 <http_get_variable+0x6e>
    135a:	f6 01       	movw	r30, r12
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	02 c0       	rjmp	.+4      	; 0x1364 <http_get_variable+0x72>
		{
			key++;
    1360:	31 96       	adiw	r30, 0x01	; 1
			match++;
    1362:	8f 5f       	subi	r24, 0xFF	; 255
	// not found '?' in buffer
	if ( data_p == dlength )
		return 0;
	
	// find variable key in buffer 
	for ( ; data_p<dlength; data_p++ )
    1364:	2f 5f       	subi	r18, 0xFF	; 255
    1366:	3f 4f       	sbci	r19, 0xFF	; 255
    1368:	11 96       	adiw	r26, 0x01	; 1
    136a:	20 17       	cp	r18, r16
    136c:	31 07       	cpc	r19, r17
    136e:	40 f3       	brcs	.-48     	; 0x1340 <http_get_variable+0x4e>
			match = 0;
		}
	}
	
	// if found variable keyword, then store variable value in destination buffer ( dest )
	if ( match != 0 )
    1370:	88 23       	and	r24, r24
    1372:	b1 f0       	breq	.+44     	; 0x13a0 <http_get_variable+0xae>
    1374:	de 01       	movw	r26, r28
    1376:	a2 0f       	add	r26, r18
    1378:	b3 1f       	adc	r27, r19
    137a:	80 e0       	ldi	r24, 0x00	; 0
		match = 0;

		for ( ;; )
		{
			// end of variable value break from loop
			if ( rxtx_buffer [ data_p ] == '&' || rxtx_buffer [ data_p ] == ' ' )
    137c:	9c 91       	ld	r25, X
    137e:	96 32       	cpi	r25, 0x26	; 38
    1380:	19 f0       	breq	.+6      	; 0x1388 <http_get_variable+0x96>
    1382:	11 96       	adiw	r26, 0x01	; 1
    1384:	90 32       	cpi	r25, 0x20	; 32
    1386:	29 f4       	brne	.+10     	; 0x1392 <http_get_variable+0xa0>
			{
				dest [ match ] = '\0';
    1388:	e8 0e       	add	r14, r24
    138a:	f1 1c       	adc	r15, r1
    138c:	f7 01       	movw	r30, r14
    138e:	10 82       	st	Z, r1
    1390:	07 c0       	rjmp	.+14     	; 0x13a0 <http_get_variable+0xae>
				break;
			}
			dest [ match ] = rxtx_buffer [ data_p ];
    1392:	f7 01       	movw	r30, r14
    1394:	e8 0f       	add	r30, r24
    1396:	f1 1d       	adc	r31, r1
    1398:	90 83       	st	Z, r25
			match++;
    139a:	8f 5f       	subi	r24, 0xFF	; 255
    139c:	ef cf       	rjmp	.-34     	; 0x137c <http_get_variable+0x8a>
			data_p++;
		}
    139e:	80 e0       	ldi	r24, 0x00	; 0
	}

	// return with variable value length
	return match;
}
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	1f 91       	pop	r17
    13a6:	0f 91       	pop	r16
    13a8:	ff 90       	pop	r15
    13aa:	ef 90       	pop	r14
    13ac:	df 90       	pop	r13
    13ae:	cf 90       	pop	r12
    13b0:	08 95       	ret

000013b2 <http_webserver_process>:
// Function : http_webserver_process
// Description : Initial connection to web server
//
//********************************************************************************************
void http_webserver_process ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    13b2:	2f 92       	push	r2
    13b4:	3f 92       	push	r3
    13b6:	4f 92       	push	r4
    13b8:	5f 92       	push	r5
    13ba:	6f 92       	push	r6
    13bc:	7f 92       	push	r7
    13be:	8f 92       	push	r8
    13c0:	9f 92       	push	r9
    13c2:	af 92       	push	r10
    13c4:	bf 92       	push	r11
    13c6:	cf 92       	push	r12
    13c8:	df 92       	push	r13
    13ca:	ef 92       	push	r14
    13cc:	0f 93       	push	r16
    13ce:	1f 93       	push	r17
    13d0:	df 93       	push	r29
    13d2:	cf 93       	push	r28
    13d4:	cd b7       	in	r28, 0x3d	; 61
    13d6:	de b7       	in	r29, 0x3e	; 62
    13d8:	c4 54       	subi	r28, 0x44	; 68
    13da:	d1 40       	sbci	r29, 0x01	; 1
    13dc:	0f b6       	in	r0, 0x3f	; 63
    13de:	f8 94       	cli
    13e0:	de bf       	out	0x3e, r29	; 62
    13e2:	0f be       	out	0x3f, r0	; 63
    13e4:	cd bf       	out	0x3d, r28	; 61
    13e6:	2c 01       	movw	r4, r24
    13e8:	cf 5b       	subi	r28, 0xBF	; 191
    13ea:	de 4f       	sbci	r29, 0xFE	; 254
    13ec:	79 83       	std	Y+1, r23	; 0x01
    13ee:	68 83       	st	Y, r22
    13f0:	c1 54       	subi	r28, 0x41	; 65
    13f2:	d1 40       	sbci	r29, 0x01	; 1
    13f4:	cd 5b       	subi	r28, 0xBD	; 189
    13f6:	de 4f       	sbci	r29, 0xFE	; 254
    13f8:	59 83       	std	Y+1, r21	; 0x01
    13fa:	48 83       	st	Y, r20
    13fc:	c3 54       	subi	r28, 0x43	; 67
    13fe:	d1 40       	sbci	r29, 0x01	; 1

	static unsigned int numCount = 0;

	unsigned char page;
	
	dest_port = (rxtx_buffer[TCP_SRC_PORT_H_P]<<8)|rxtx_buffer[TCP_SRC_PORT_L_P];
    1400:	fc 01       	movw	r30, r24
    1402:	22 a1       	ldd	r18, Z+34	; 0x22
    1404:	63 a1       	ldd	r22, Z+35	; 0x23
	// tcp port 80 start for web server
	if ( rxtx_buffer [ IP_PROTO_P ] == IP_PROTO_TCP_V && rxtx_buffer[ TCP_DST_PORT_H_P ] == 0 && rxtx_buffer[ TCP_DST_PORT_L_P ] == 80 )
    1406:	87 89       	ldd	r24, Z+23	; 0x17
    1408:	86 30       	cpi	r24, 0x06	; 6
    140a:	09 f0       	breq	.+2      	; 0x140e <http_webserver_process+0x5c>
    140c:	73 c1       	rjmp	.+742    	; 0x16f4 <http_webserver_process+0x342>
    140e:	84 a1       	ldd	r24, Z+36	; 0x24
    1410:	88 23       	and	r24, r24
    1412:	09 f0       	breq	.+2      	; 0x1416 <http_webserver_process+0x64>
    1414:	6f c1       	rjmp	.+734    	; 0x16f4 <http_webserver_process+0x342>
    1416:	85 a1       	ldd	r24, Z+37	; 0x25
    1418:	80 35       	cpi	r24, 0x50	; 80
    141a:	09 f0       	breq	.+2      	; 0x141e <http_webserver_process+0x6c>
    141c:	6b c1       	rjmp	.+726    	; 0x16f4 <http_webserver_process+0x342>

	static unsigned int numCount = 0;

	unsigned char page;
	
	dest_port = (rxtx_buffer[TCP_SRC_PORT_H_P]<<8)|rxtx_buffer[TCP_SRC_PORT_L_P];
    141e:	92 2f       	mov	r25, r18
    1420:	80 e0       	ldi	r24, 0x00	; 0
    1422:	26 2e       	mov	r2, r22
    1424:	33 24       	eor	r3, r3
    1426:	28 2a       	or	r2, r24
    1428:	39 2a       	or	r3, r25
	// tcp port 80 start for web server
	if ( rxtx_buffer [ IP_PROTO_P ] == IP_PROTO_TCP_V && rxtx_buffer[ TCP_DST_PORT_H_P ] == 0 && rxtx_buffer[ TCP_DST_PORT_L_P ] == 80 )
	{
		// received packet with flags "SYN", let's send "SYNACK"
		if ( (rxtx_buffer[ TCP_FLAGS_P ] & TCP_FLAG_SYN_V) )
    142a:	87 a5       	ldd	r24, Z+47	; 0x2f
    142c:	81 ff       	sbrs	r24, 1
    142e:	1d c0       	rjmp	.+58     	; 0x146a <http_webserver_process+0xb8>
		{
//			tcp_send_synack ( rxtx_buffer, dest_mac, dest_ip );
			tcp_send_packet (
    1430:	00 d0       	rcall	.+0      	; 0x1432 <http_webserver_process+0x80>
    1432:	ed b7       	in	r30, 0x3d	; 61
    1434:	fe b7       	in	r31, 0x3e	; 62
    1436:	52 83       	std	Z+2, r21	; 0x02
    1438:	41 83       	std	Z+1, r20	; 0x01
    143a:	c2 01       	movw	r24, r4
    143c:	b1 01       	movw	r22, r2
    143e:	40 e5       	ldi	r20, 0x50	; 80
    1440:	50 e0       	ldi	r21, 0x00	; 0
    1442:	22 e1       	ldi	r18, 0x12	; 18
    1444:	01 e0       	ldi	r16, 0x01	; 1
    1446:	ee 24       	eor	r14, r14
    1448:	f1 e0       	ldi	r31, 0x01	; 1
    144a:	cf 2e       	mov	r12, r31
    144c:	d1 2c       	mov	r13, r1
    144e:	aa 24       	eor	r10, r10
    1450:	bb 24       	eor	r11, r11
    1452:	cf 5b       	subi	r28, 0xBF	; 191
    1454:	de 4f       	sbci	r29, 0xFE	; 254
    1456:	88 80       	ld	r8, Y
    1458:	99 80       	ldd	r9, Y+1	; 0x01
    145a:	c1 54       	subi	r28, 0x41	; 65
    145c:	d1 40       	sbci	r29, 0x01	; 1
    145e:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <tcp_send_packet>
				0,						// (bool)clear sequence ack number
				1,						// (bool)calculate new seq and seqack number
				0,						// tcp data length
				dest_mac,		// server mac address
				dest_ip );		// server ip address
			flag1.bits.syn_is_received = 1;
    1462:	80 91 d4 00 	lds	r24, 0x00D4
    1466:	80 64       	ori	r24, 0x40	; 64
    1468:	41 c1       	rjmp	.+642    	; 0x16ec <http_webserver_process+0x33a>
			return;
		}

		if ( (rxtx_buffer [ TCP_FLAGS_P ] & TCP_FLAG_ACK_V) )
    146a:	84 ff       	sbrs	r24, 4
    146c:	43 c1       	rjmp	.+646    	; 0x16f4 <http_webserver_process+0x342>
		{
			// get tcp data length
			dlength = tcp_get_dlength( rxtx_buffer );
    146e:	c2 01       	movw	r24, r4
    1470:	0e 94 8d 0c 	call	0x191a	; 0x191a <tcp_get_dlength>
    1474:	3c 01       	movw	r6, r24
			if ( dlength == 0 )
    1476:	00 97       	sbiw	r24, 0x00	; 0
    1478:	21 f5       	brne	.+72     	; 0x14c2 <http_webserver_process+0x110>
			{
				// finack, answer with ack
				if ( (rxtx_buffer[TCP_FLAGS_P] & TCP_FLAG_FIN_V) )
    147a:	f2 01       	movw	r30, r4
    147c:	87 a5       	ldd	r24, Z+47	; 0x2f
    147e:	80 ff       	sbrs	r24, 0
    1480:	39 c1       	rjmp	.+626    	; 0x16f4 <http_webserver_process+0x342>
				{
//					tcp_send_ack ( rxtx_buffer, dest_mac, dest_ip );
					tcp_send_packet (
    1482:	00 d0       	rcall	.+0      	; 0x1484 <http_webserver_process+0xd2>
    1484:	cd 5b       	subi	r28, 0xBD	; 189
    1486:	de 4f       	sbci	r29, 0xFE	; 254
    1488:	88 81       	ld	r24, Y
    148a:	99 81       	ldd	r25, Y+1	; 0x01
    148c:	c3 54       	subi	r28, 0x43	; 67
    148e:	d1 40       	sbci	r29, 0x01	; 1
    1490:	ed b7       	in	r30, 0x3d	; 61
    1492:	fe b7       	in	r31, 0x3e	; 62
    1494:	92 83       	std	Z+2, r25	; 0x02
    1496:	81 83       	std	Z+1, r24	; 0x01
    1498:	c2 01       	movw	r24, r4
    149a:	b1 01       	movw	r22, r2
    149c:	40 e5       	ldi	r20, 0x50	; 80
    149e:	50 e0       	ldi	r21, 0x00	; 0
    14a0:	20 e1       	ldi	r18, 0x10	; 16
    14a2:	00 e0       	ldi	r16, 0x00	; 0
    14a4:	ee 24       	eor	r14, r14
    14a6:	e1 e0       	ldi	r30, 0x01	; 1
    14a8:	ce 2e       	mov	r12, r30
    14aa:	d1 2c       	mov	r13, r1
    14ac:	aa 24       	eor	r10, r10
    14ae:	bb 24       	eor	r11, r11
    14b0:	cf 5b       	subi	r28, 0xBF	; 191
    14b2:	de 4f       	sbci	r29, 0xFE	; 254
    14b4:	88 80       	ld	r8, Y
    14b6:	99 80       	ldd	r9, Y+1	; 0x01
    14b8:	c1 54       	subi	r28, 0x41	; 65
    14ba:	d1 40       	sbci	r29, 0x01	; 1
    14bc:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <tcp_send_packet>
    14c0:	17 c1       	rjmp	.+558    	; 0x16f0 <http_webserver_process+0x33e>
						dest_ip );		// server ip address
				}
				return;
			}

			if ( http_get_variable ( rxtx_buffer, dlength, PSTR( "reg_send_msg" ), generic_buf ) ) {
    14c2:	c2 01       	movw	r24, r4
    14c4:	b3 01       	movw	r22, r6
    14c6:	4b ef       	ldi	r20, 0xFB	; 251
    14c8:	58 e0       	ldi	r21, 0x08	; 8
    14ca:	6e 01       	movw	r12, r28
    14cc:	08 94       	sec
    14ce:	c1 1c       	adc	r12, r1
    14d0:	d1 1c       	adc	r13, r1
    14d2:	96 01       	movw	r18, r12
    14d4:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    14d8:	88 23       	and	r24, r24
    14da:	29 f1       	breq	.+74     	; 0x1526 <http_webserver_process+0x174>
			//	USART_SendString("data received");
				if(generic_buf[0] == '1') {
    14dc:	89 81       	ldd	r24, Y+1	; 0x01
    14de:	81 33       	cpi	r24, 0x31	; 49
    14e0:	09 f0       	breq	.+2      	; 0x14e4 <http_webserver_process+0x132>
    14e2:	c8 c0       	rjmp	.+400    	; 0x1674 <http_webserver_process+0x2c2>
					if( http_get_variable ( rxtx_buffer, dlength, PSTR( "mobNum" ), mob_num ) ) {
    14e4:	c2 01       	movw	r24, r4
    14e6:	b3 01       	movw	r22, r6
    14e8:	44 ef       	ldi	r20, 0xF4	; 244
    14ea:	58 e0       	ldi	r21, 0x08	; 8
    14ec:	9e 01       	movw	r18, r28
    14ee:	2f 5b       	subi	r18, 0xBF	; 191
    14f0:	3f 4f       	sbci	r19, 0xFF	; 255
    14f2:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    14f6:	88 23       	and	r24, r24
    14f8:	09 f4       	brne	.+2      	; 0x14fc <http_webserver_process+0x14a>
    14fa:	4d c0       	rjmp	.+154    	; 0x1596 <http_webserver_process+0x1e4>
						if( http_get_variable ( rxtx_buffer, dlength, PSTR( "secCode" ), sec_code ) ) {
    14fc:	c2 01       	movw	r24, r4
    14fe:	b3 01       	movw	r22, r6
    1500:	4c ee       	ldi	r20, 0xEC	; 236
    1502:	58 e0       	ldi	r21, 0x08	; 8
    1504:	9e 01       	movw	r18, r28
    1506:	2f 57       	subi	r18, 0x7F	; 127
    1508:	3f 4f       	sbci	r19, 0xFF	; 255
    150a:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    150e:	88 23       	and	r24, r24
    1510:	09 f4       	brne	.+2      	; 0x1514 <http_webserver_process+0x162>
    1512:	41 c0       	rjmp	.+130    	; 0x1596 <http_webserver_process+0x1e4>
							//USART_SendString("sms sending");
							//sprintf(msg,"emBank verification code: %s",sec_code);
							GSM_SendMessage(mob_num,sec_code);
    1514:	ce 01       	movw	r24, r28
    1516:	8f 5b       	subi	r24, 0xBF	; 191
    1518:	9f 4f       	sbci	r25, 0xFF	; 255
    151a:	be 01       	movw	r22, r28
    151c:	6f 57       	subi	r22, 0x7F	; 127
    151e:	7f 4f       	sbci	r23, 0xFF	; 255
    1520:	0e 94 1f 10 	call	0x203e	; 0x203e <GSM_SendMessage>
    1524:	38 c0       	rjmp	.+112    	; 0x1596 <http_webserver_process+0x1e4>
						}
					}

					dlength = http_test( rxtx_buffer );
				}
			} else if ( http_get_variable ( rxtx_buffer, dlength, PSTR( "bal_trf" ), generic_buf ) ) {
    1526:	c2 01       	movw	r24, r4
    1528:	b3 01       	movw	r22, r6
    152a:	44 ee       	ldi	r20, 0xE4	; 228
    152c:	58 e0       	ldi	r21, 0x08	; 8
    152e:	96 01       	movw	r18, r12
    1530:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    1534:	88 23       	and	r24, r24
    1536:	11 f1       	breq	.+68     	; 0x157c <http_webserver_process+0x1ca>
			//	USART_SendString("data received");
				if(generic_buf[0] == '1') {
    1538:	89 81       	ldd	r24, Y+1	; 0x01
    153a:	81 33       	cpi	r24, 0x31	; 49
    153c:	09 f0       	breq	.+2      	; 0x1540 <http_webserver_process+0x18e>
    153e:	9a c0       	rjmp	.+308    	; 0x1674 <http_webserver_process+0x2c2>
					if( http_get_variable ( rxtx_buffer, dlength, PSTR( "receiver" ), receiver ) ) {
    1540:	c2 01       	movw	r24, r4
    1542:	b3 01       	movw	r22, r6
    1544:	4b ed       	ldi	r20, 0xDB	; 219
    1546:	58 e0       	ldi	r21, 0x08	; 8
    1548:	9e 01       	movw	r18, r28
    154a:	2f 53       	subi	r18, 0x3F	; 63
    154c:	3f 4f       	sbci	r19, 0xFF	; 255
    154e:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    1552:	88 23       	and	r24, r24
    1554:	01 f1       	breq	.+64     	; 0x1596 <http_webserver_process+0x1e4>
						if( http_get_variable ( rxtx_buffer, dlength, PSTR( "ammount" ), ammount ) ) {
    1556:	8e 01       	movw	r16, r28
    1558:	0f 5f       	subi	r16, 0xFF	; 255
    155a:	1e 4f       	sbci	r17, 0xFE	; 254
    155c:	c2 01       	movw	r24, r4
    155e:	b3 01       	movw	r22, r6
    1560:	43 ed       	ldi	r20, 0xD3	; 211
    1562:	58 e0       	ldi	r21, 0x08	; 8
    1564:	98 01       	movw	r18, r16
    1566:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    156a:	88 23       	and	r24, r24
    156c:	a1 f0       	breq	.+40     	; 0x1596 <http_webserver_process+0x1e4>
							//USART_SendString("sms sending");
							//sprintf(msg,"emBank verification code: %s",sec_code);
							GSM_TrfBalance(receiver,ammount);
    156e:	ce 01       	movw	r24, r28
    1570:	8f 53       	subi	r24, 0x3F	; 63
    1572:	9f 4f       	sbci	r25, 0xFF	; 255
    1574:	b8 01       	movw	r22, r16
    1576:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <GSM_TrfBalance>
    157a:	0d c0       	rjmp	.+26     	; 0x1596 <http_webserver_process+0x1e4>
						}
					}

					dlength = http_test( rxtx_buffer );
				}
			} else if( http_get_variable ( rxtx_buffer, dlength, PSTR( "check" ), generic_buf ) ) {
    157c:	c2 01       	movw	r24, r4
    157e:	b3 01       	movw	r22, r6
    1580:	4d ec       	ldi	r20, 0xCD	; 205
    1582:	58 e0       	ldi	r21, 0x08	; 8
    1584:	96 01       	movw	r18, r12
    1586:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    158a:	88 23       	and	r24, r24
    158c:	41 f0       	breq	.+16     	; 0x159e <http_webserver_process+0x1ec>
				if(generic_buf[0] == '1') {
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	81 33       	cpi	r24, 0x31	; 49
    1592:	09 f0       	breq	.+2      	; 0x1596 <http_webserver_process+0x1e4>
    1594:	6f c0       	rjmp	.+222    	; 0x1674 <http_webserver_process+0x2c2>
					dlength = http_test( rxtx_buffer );
    1596:	c2 01       	movw	r24, r4
    1598:	0e 94 14 09 	call	0x1228	; 0x1228 <http_test>
    159c:	6a c0       	rjmp	.+212    	; 0x1672 <http_webserver_process+0x2c0>
				}
			} else if (http_get_variable ( rxtx_buffer, dlength, PSTR( "control" ), generic_buf )) {
    159e:	c2 01       	movw	r24, r4
    15a0:	b3 01       	movw	r22, r6
    15a2:	45 ec       	ldi	r20, 0xC5	; 197
    15a4:	58 e0       	ldi	r21, 0x08	; 8
    15a6:	96 01       	movw	r18, r12
    15a8:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    15ac:	88 23       	and	r24, r24
    15ae:	09 f4       	brne	.+2      	; 0x15b2 <http_webserver_process+0x200>
    15b0:	59 c0       	rjmp	.+178    	; 0x1664 <http_webserver_process+0x2b2>
				if(generic_buf[0] == '1') {
    15b2:	89 81       	ldd	r24, Y+1	; 0x01
    15b4:	81 33       	cpi	r24, 0x31	; 49
    15b6:	09 f0       	breq	.+2      	; 0x15ba <http_webserver_process+0x208>
    15b8:	5d c0       	rjmp	.+186    	; 0x1674 <http_webserver_process+0x2c2>
					if (http_get_variable ( rxtx_buffer, dlength, PSTR( "bulb1" ), generic_buf )) {
    15ba:	c2 01       	movw	r24, r4
    15bc:	b3 01       	movw	r22, r6
    15be:	4f eb       	ldi	r20, 0xBF	; 191
    15c0:	58 e0       	ldi	r21, 0x08	; 8
    15c2:	9e 01       	movw	r18, r28
    15c4:	2f 5f       	subi	r18, 0xFF	; 255
    15c6:	3f 4f       	sbci	r19, 0xFF	; 255
    15c8:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    15cc:	88 23       	and	r24, r24
    15ce:	81 f0       	breq	.+32     	; 0x15f0 <http_webserver_process+0x23e>
						if(generic_buf[0] == '1') {
    15d0:	89 81       	ldd	r24, Y+1	; 0x01
    15d2:	81 33       	cpi	r24, 0x31	; 49
    15d4:	41 f4       	brne	.+16     	; 0x15e6 <http_webserver_process+0x234>
							bulb_1 = 1;
    15d6:	81 e0       	ldi	r24, 0x01	; 1
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	90 93 ce 00 	sts	0x00CE, r25
    15de:	80 93 cd 00 	sts	0x00CD, r24
							CONTROL_PORT |= (1<<BULB_1_PIN);
    15e2:	ab 9a       	sbi	0x15, 3	; 21
    15e4:	05 c0       	rjmp	.+10     	; 0x15f0 <http_webserver_process+0x23e>
						} else {
							bulb_1 = 0;
    15e6:	10 92 ce 00 	sts	0x00CE, r1
    15ea:	10 92 cd 00 	sts	0x00CD, r1
							CONTROL_PORT &= ~(1<<BULB_1_PIN);
    15ee:	ab 98       	cbi	0x15, 3	; 21
						}
					}
					if (http_get_variable ( rxtx_buffer, dlength, PSTR( "bulb2" ), generic_buf )) {
    15f0:	c2 01       	movw	r24, r4
    15f2:	b3 01       	movw	r22, r6
    15f4:	49 eb       	ldi	r20, 0xB9	; 185
    15f6:	58 e0       	ldi	r21, 0x08	; 8
    15f8:	9e 01       	movw	r18, r28
    15fa:	2f 5f       	subi	r18, 0xFF	; 255
    15fc:	3f 4f       	sbci	r19, 0xFF	; 255
    15fe:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    1602:	88 23       	and	r24, r24
    1604:	81 f0       	breq	.+32     	; 0x1626 <http_webserver_process+0x274>
						if(generic_buf[0] == '1') {
    1606:	89 81       	ldd	r24, Y+1	; 0x01
    1608:	81 33       	cpi	r24, 0x31	; 49
    160a:	41 f4       	brne	.+16     	; 0x161c <http_webserver_process+0x26a>
							bulb_2 = 1;
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	90 93 d0 00 	sts	0x00D0, r25
    1614:	80 93 cf 00 	sts	0x00CF, r24
							CONTROL_PORT |= (1<<BULB_2_PIN);
    1618:	ac 9a       	sbi	0x15, 4	; 21
    161a:	05 c0       	rjmp	.+10     	; 0x1626 <http_webserver_process+0x274>
						} else {
							bulb_2 = 0;
    161c:	10 92 d0 00 	sts	0x00D0, r1
    1620:	10 92 cf 00 	sts	0x00CF, r1
							CONTROL_PORT &= ~(1<<BULB_2_PIN);
    1624:	ac 98       	cbi	0x15, 4	; 21
						}
					}
					if (http_get_variable ( rxtx_buffer, dlength, PSTR( "fan" ), generic_buf )) {
    1626:	c2 01       	movw	r24, r4
    1628:	b3 01       	movw	r22, r6
    162a:	45 eb       	ldi	r20, 0xB5	; 181
    162c:	58 e0       	ldi	r21, 0x08	; 8
    162e:	9e 01       	movw	r18, r28
    1630:	2f 5f       	subi	r18, 0xFF	; 255
    1632:	3f 4f       	sbci	r19, 0xFF	; 255
    1634:	0e 94 79 09 	call	0x12f2	; 0x12f2 <http_get_variable>
    1638:	88 23       	and	r24, r24
    163a:	81 f0       	breq	.+32     	; 0x165c <http_webserver_process+0x2aa>
						if(generic_buf[0] == '1') {
    163c:	89 81       	ldd	r24, Y+1	; 0x01
    163e:	81 33       	cpi	r24, 0x31	; 49
    1640:	41 f4       	brne	.+16     	; 0x1652 <http_webserver_process+0x2a0>
							fan = 1;
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	90 93 d2 00 	sts	0x00D2, r25
    164a:	80 93 d1 00 	sts	0x00D1, r24
							CONTROL_PORT |= (1<<FAN_PIN);
    164e:	ad 9a       	sbi	0x15, 5	; 21
    1650:	05 c0       	rjmp	.+10     	; 0x165c <http_webserver_process+0x2aa>
						} else {
							fan = 0;
    1652:	10 92 d2 00 	sts	0x00D2, r1
    1656:	10 92 d1 00 	sts	0x00D1, r1
							CONTROL_PORT &= ~(1<<FAN_PIN);
    165a:	ad 98       	cbi	0x15, 5	; 21
						}
					}
					dlength = http_control( rxtx_buffer );
    165c:	c2 01       	movw	r24, r4
    165e:	0e 94 0f 08 	call	0x101e	; 0x101e <http_control>
    1662:	07 c0       	rjmp	.+14     	; 0x1672 <http_webserver_process+0x2c0>
WORD http_home( BYTE *rxtx_buffer )
{
	WORD dlen;
	BYTE generic_buf[64];

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR ( "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n" ), 0 );
    1664:	c2 01       	movw	r24, r4
    1666:	68 ee       	ldi	r22, 0xE8	; 232
    1668:	77 e0       	ldi	r23, 0x07	; 7
    166a:	40 e0       	ldi	r20, 0x00	; 0
    166c:	50 e0       	ldi	r21, 0x00	; 0
    166e:	0e 94 ad 0c 	call	0x195a	; 0x195a <tcp_puts_data_p>
    1672:	3c 01       	movw	r6, r24

			// print webpage
			//dlength = http_page( rxtx_buffer );
			// send ack before send data
//			tcp_send_ack ( rxtx_buffer, dest_mac, dest_ip );
			tcp_send_packet (
    1674:	00 d0       	rcall	.+0      	; 0x1676 <http_webserver_process+0x2c4>
    1676:	cd 5b       	subi	r28, 0xBD	; 189
    1678:	de 4f       	sbci	r29, 0xFE	; 254
    167a:	88 81       	ld	r24, Y
    167c:	99 81       	ldd	r25, Y+1	; 0x01
    167e:	c3 54       	subi	r28, 0x43	; 67
    1680:	d1 40       	sbci	r29, 0x01	; 1
    1682:	ed b7       	in	r30, 0x3d	; 61
    1684:	fe b7       	in	r31, 0x3e	; 62
    1686:	92 83       	std	Z+2, r25	; 0x02
    1688:	81 83       	std	Z+1, r24	; 0x01
    168a:	c2 01       	movw	r24, r4
    168c:	b1 01       	movw	r22, r2
    168e:	40 e5       	ldi	r20, 0x50	; 80
    1690:	50 e0       	ldi	r21, 0x00	; 0
    1692:	20 e1       	ldi	r18, 0x10	; 16
    1694:	00 e0       	ldi	r16, 0x00	; 0
    1696:	ee 24       	eor	r14, r14
    1698:	31 e0       	ldi	r19, 0x01	; 1
    169a:	c3 2e       	mov	r12, r19
    169c:	d1 2c       	mov	r13, r1
    169e:	aa 24       	eor	r10, r10
    16a0:	bb 24       	eor	r11, r11
    16a2:	cf 5b       	subi	r28, 0xBF	; 191
    16a4:	de 4f       	sbci	r29, 0xFE	; 254
    16a6:	88 80       	ld	r8, Y
    16a8:	99 80       	ldd	r9, Y+1	; 0x01
    16aa:	c1 54       	subi	r28, 0x41	; 65
    16ac:	d1 40       	sbci	r29, 0x01	; 1
    16ae:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <tcp_send_packet>
						0,						// tcp data length
						dest_mac,		// server mac address
						dest_ip );		// server ip address
			// send tcp data
//			tcp_send_data ( rxtx_buffer, dest_mac, dest_ip, dlength );
			tcp_send_packet (
    16b2:	cd 5b       	subi	r28, 0xBD	; 189
    16b4:	de 4f       	sbci	r29, 0xFE	; 254
    16b6:	88 81       	ld	r24, Y
    16b8:	99 81       	ldd	r25, Y+1	; 0x01
    16ba:	c3 54       	subi	r28, 0x43	; 67
    16bc:	d1 40       	sbci	r29, 0x01	; 1
    16be:	ed b7       	in	r30, 0x3d	; 61
    16c0:	fe b7       	in	r31, 0x3e	; 62
    16c2:	92 83       	std	Z+2, r25	; 0x02
    16c4:	81 83       	std	Z+1, r24	; 0x01
    16c6:	c2 01       	movw	r24, r4
    16c8:	b1 01       	movw	r22, r2
    16ca:	40 e5       	ldi	r20, 0x50	; 80
    16cc:	50 e0       	ldi	r21, 0x00	; 0
    16ce:	29 e1       	ldi	r18, 0x19	; 25
    16d0:	cc 24       	eor	r12, r12
    16d2:	dd 24       	eor	r13, r13
    16d4:	53 01       	movw	r10, r6
    16d6:	cf 5b       	subi	r28, 0xBF	; 191
    16d8:	de 4f       	sbci	r29, 0xFE	; 254
    16da:	88 80       	ld	r8, Y
    16dc:	99 80       	ldd	r9, Y+1	; 0x01
    16de:	c1 54       	subi	r28, 0x41	; 65
    16e0:	d1 40       	sbci	r29, 0x01	; 1
    16e2:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <tcp_send_packet>
						0,						// (bool)clear sequence ack number
						0,						// (bool)calculate new seq and seqack number
						dlength,				// tcp data length
						dest_mac,		// server mac address
						dest_ip );		// server ip address
			flag1.bits.syn_is_received = 0;
    16e6:	80 91 d4 00 	lds	r24, 0x00D4
    16ea:	8f 7b       	andi	r24, 0xBF	; 191
    16ec:	80 93 d4 00 	sts	0x00D4, r24
    16f0:	0f 90       	pop	r0
    16f2:	0f 90       	pop	r0
		}		
	}
}
    16f4:	cc 5b       	subi	r28, 0xBC	; 188
    16f6:	de 4f       	sbci	r29, 0xFE	; 254
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	de bf       	out	0x3e, r29	; 62
    16fe:	0f be       	out	0x3f, r0	; 63
    1700:	cd bf       	out	0x3d, r28	; 61
    1702:	cf 91       	pop	r28
    1704:	df 91       	pop	r29
    1706:	1f 91       	pop	r17
    1708:	0f 91       	pop	r16
    170a:	ef 90       	pop	r14
    170c:	df 90       	pop	r13
    170e:	cf 90       	pop	r12
    1710:	bf 90       	pop	r11
    1712:	af 90       	pop	r10
    1714:	9f 90       	pop	r9
    1716:	8f 90       	pop	r8
    1718:	7f 90       	pop	r7
    171a:	6f 90       	pop	r6
    171c:	5f 90       	pop	r5
    171e:	4f 90       	pop	r4
    1720:	3f 90       	pop	r3
    1722:	2f 90       	pop	r2
    1724:	08 95       	ret

00001726 <arp_generate_packet>:
// Function : arp_generate_packet
// Description : generate arp packet
//
//********************************************************************************************
void arp_generate_packet ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1726:	cf 93       	push	r28
    1728:	df 93       	push	r29
    172a:	dc 01       	movw	r26, r24
	unsigned char i;
	
	// setup hardware type to ethernet 0x0001
	rxtx_buffer[ ARP_HARDWARE_TYPE_H_P ] = ARP_HARDWARE_TYPE_H_V;
    172c:	1e 96       	adiw	r26, 0x0e	; 14
    172e:	1c 92       	st	X, r1
    1730:	1e 97       	sbiw	r26, 0x0e	; 14
	rxtx_buffer[ ARP_HARDWARE_TYPE_L_P ] = ARP_HARDWARE_TYPE_L_V;
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	1f 96       	adiw	r26, 0x0f	; 15
    1736:	8c 93       	st	X, r24
    1738:	1f 97       	sbiw	r26, 0x0f	; 15
	
	// setup protocol type to ip 0x0800
	rxtx_buffer[ ARP_PROTOCOL_H_P ] = ARP_PROTOCOL_H_V;
    173a:	88 e0       	ldi	r24, 0x08	; 8
    173c:	50 96       	adiw	r26, 0x10	; 16
    173e:	8c 93       	st	X, r24
    1740:	50 97       	sbiw	r26, 0x10	; 16
	rxtx_buffer[ ARP_PROTOCOL_L_P ] = ARP_PROTOCOL_L_V;
    1742:	51 96       	adiw	r26, 0x11	; 17
    1744:	1c 92       	st	X, r1
    1746:	51 97       	sbiw	r26, 0x11	; 17

	// setup hardware length to 0x06
	rxtx_buffer[ ARP_HARDWARE_SIZE_P ] = ARP_HARDWARE_SIZE_V;
    1748:	86 e0       	ldi	r24, 0x06	; 6
    174a:	52 96       	adiw	r26, 0x12	; 18
    174c:	8c 93       	st	X, r24
    174e:	52 97       	sbiw	r26, 0x12	; 18

	// setup protocol length to 0x04
	rxtx_buffer[ ARP_PROTOCOL_SIZE_P ] = ARP_PROTOCOL_SIZE_V;
    1750:	84 e0       	ldi	r24, 0x04	; 4
    1752:	53 96       	adiw	r26, 0x13	; 19
    1754:	8c 93       	st	X, r24
    1756:	53 97       	sbiw	r26, 0x13	; 19
    1758:	ed 01       	movw	r28, r26
    175a:	20 e0       	ldi	r18, 0x00	; 0
    175c:	30 e0       	ldi	r19, 0x00	; 0

	// setup arp destination and source mac address
	for ( i=0; i<sizeof(MAC_ADDR); i++)
	{
		rxtx_buffer[ ARP_DST_MAC_P + i ] = dest_mac[i];
    175e:	fb 01       	movw	r30, r22
    1760:	e2 0f       	add	r30, r18
    1762:	f3 1f       	adc	r31, r19
    1764:	80 81       	ld	r24, Z
    1766:	88 a3       	std	Y+32, r24	; 0x20
		rxtx_buffer[ ARP_SRC_MAC_P + i ] = avr_mac.byte[i];
    1768:	f9 01       	movw	r30, r18
    176a:	eb 52       	subi	r30, 0x2B	; 43
    176c:	ff 4f       	sbci	r31, 0xFF	; 255
    176e:	80 81       	ld	r24, Z
    1770:	8e 8b       	std	Y+22, r24	; 0x16
    1772:	2f 5f       	subi	r18, 0xFF	; 255
    1774:	3f 4f       	sbci	r19, 0xFF	; 255
    1776:	21 96       	adiw	r28, 0x01	; 1

	// setup protocol length to 0x04
	rxtx_buffer[ ARP_PROTOCOL_SIZE_P ] = ARP_PROTOCOL_SIZE_V;

	// setup arp destination and source mac address
	for ( i=0; i<sizeof(MAC_ADDR); i++)
    1778:	26 30       	cpi	r18, 0x06	; 6
    177a:	31 05       	cpc	r19, r1
    177c:	81 f7       	brne	.-32     	; 0x175e <arp_generate_packet+0x38>
    177e:	5c 96       	adiw	r26, 0x1c	; 28
    1780:	20 e0       	ldi	r18, 0x00	; 0
    1782:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	// setup arp destination and source ip address
	for ( i=0; i<sizeof(IP_ADDR); i++)
	{
		rxtx_buffer[ ARP_DST_IP_P + i ] = dest_ip[i];
    1784:	fa 01       	movw	r30, r20
    1786:	e2 0f       	add	r30, r18
    1788:	f3 1f       	adc	r31, r19
    178a:	80 81       	ld	r24, Z
    178c:	1a 96       	adiw	r26, 0x0a	; 10
    178e:	8c 93       	st	X, r24
    1790:	1a 97       	sbiw	r26, 0x0a	; 10
		rxtx_buffer[ ARP_SRC_IP_P + i ] = avr_ip.byte[i];
    1792:	f9 01       	movw	r30, r18
    1794:	e1 52       	subi	r30, 0x21	; 33
    1796:	ff 4f       	sbci	r31, 0xFF	; 255
    1798:	80 81       	ld	r24, Z
    179a:	8d 93       	st	X+, r24
    179c:	2f 5f       	subi	r18, 0xFF	; 255
    179e:	3f 4f       	sbci	r19, 0xFF	; 255
		rxtx_buffer[ ARP_DST_MAC_P + i ] = dest_mac[i];
		rxtx_buffer[ ARP_SRC_MAC_P + i ] = avr_mac.byte[i];
	}
	
	// setup arp destination and source ip address
	for ( i=0; i<sizeof(IP_ADDR); i++)
    17a0:	24 30       	cpi	r18, 0x04	; 4
    17a2:	31 05       	cpc	r19, r1
    17a4:	79 f7       	brne	.-34     	; 0x1784 <arp_generate_packet+0x5e>
	{
		rxtx_buffer[ ARP_DST_IP_P + i ] = dest_ip[i];
		rxtx_buffer[ ARP_SRC_IP_P + i ] = avr_ip.byte[i];
	}
}
    17a6:	df 91       	pop	r29
    17a8:	cf 91       	pop	r28
    17aa:	08 95       	ret

000017ac <arp_packet_is_arp>:
// Function : arp_packet_is_arp
// Description : check received packet, that packet is match with arp and avr ip or not?
//
//*******************************************************************************************
BYTE arp_packet_is_arp ( BYTE *rxtx_buffer, WORD_BYTES opcode )
{
    17ac:	fc 01       	movw	r30, r24
	BYTE i;

	// if packet type is not arp packet exit from function
	if( rxtx_buffer[ ETH_TYPE_H_P ] != ETH_TYPE_ARP_H_V || rxtx_buffer[ ETH_TYPE_L_P ] != ETH_TYPE_ARP_L_V)
    17ae:	84 85       	ldd	r24, Z+12	; 0x0c
    17b0:	88 30       	cpi	r24, 0x08	; 8
    17b2:	c9 f4       	brne	.+50     	; 0x17e6 <arp_packet_is_arp+0x3a>
    17b4:	85 85       	ldd	r24, Z+13	; 0x0d
    17b6:	86 30       	cpi	r24, 0x06	; 6
    17b8:	b1 f4       	brne	.+44     	; 0x17e6 <arp_packet_is_arp+0x3a>
		return 0;
	// check arp request opcode
	if ( rxtx_buffer[ ARP_OPCODE_H_P ] != opcode.byte.high || rxtx_buffer[ ARP_OPCODE_L_P ] != opcode.byte.low )
    17ba:	84 89       	ldd	r24, Z+20	; 0x14
    17bc:	87 17       	cp	r24, r23
    17be:	99 f4       	brne	.+38     	; 0x17e6 <arp_packet_is_arp+0x3a>
    17c0:	85 89       	ldd	r24, Z+21	; 0x15
    17c2:	86 17       	cp	r24, r22
    17c4:	81 f4       	brne	.+32     	; 0x17e6 <arp_packet_is_arp+0x3a>
    17c6:	df 01       	movw	r26, r30
    17c8:	96 96       	adiw	r26, 0x26	; 38
    17ca:	ef ed       	ldi	r30, 0xDF	; 223
    17cc:	f0 e0       	ldi	r31, 0x00	; 0
		return 0;
	// if destination ip address in arp packet not match with avr ip address
	for ( i=0; i<sizeof(IP_ADDR); i++ )
	{
		if ( rxtx_buffer[ ARP_DST_IP_P + i] != avr_ip.byte[i] )
    17ce:	9c 91       	ld	r25, X
    17d0:	80 81       	ld	r24, Z
    17d2:	98 17       	cp	r25, r24
    17d4:	41 f4       	brne	.+16     	; 0x17e6 <arp_packet_is_arp+0x3a>
    17d6:	11 96       	adiw	r26, 0x01	; 1
    17d8:	31 96       	adiw	r30, 0x01	; 1
		return 0;
	// check arp request opcode
	if ( rxtx_buffer[ ARP_OPCODE_H_P ] != opcode.byte.high || rxtx_buffer[ ARP_OPCODE_L_P ] != opcode.byte.low )
		return 0;
	// if destination ip address in arp packet not match with avr ip address
	for ( i=0; i<sizeof(IP_ADDR); i++ )
    17da:	80 e0       	ldi	r24, 0x00	; 0
    17dc:	e3 3e       	cpi	r30, 0xE3	; 227
    17de:	f8 07       	cpc	r31, r24
    17e0:	b1 f7       	brne	.-20     	; 0x17ce <arp_packet_is_arp+0x22>
    17e2:	81 e0       	ldi	r24, 0x01	; 1
    17e4:	08 95       	ret
    17e6:	80 e0       	ldi	r24, 0x00	; 0
	{
		if ( rxtx_buffer[ ARP_DST_IP_P + i] != avr_ip.byte[i] )
			return 0;
	}
	return 1;
}
    17e8:	08 95       	ret

000017ea <arp_send_reply>:
// Function : arp_send_reply
// Description : Send reply if recieved packet is ARP and IP address is match with avr_ip
//
//*******************************************************************************************
void arp_send_reply ( BYTE *rxtx_buffer, BYTE *dest_mac )
{
    17ea:	ef 92       	push	r14
    17ec:	ff 92       	push	r15
    17ee:	0f 93       	push	r16
    17f0:	1f 93       	push	r17
    17f2:	8c 01       	movw	r16, r24
    17f4:	7b 01       	movw	r14, r22
	// generate ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_ARP_V}, dest_mac );
    17f6:	66 e0       	ldi	r22, 0x06	; 6
    17f8:	78 e0       	ldi	r23, 0x08	; 8
    17fa:	a7 01       	movw	r20, r14
    17fc:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <eth_generate_header>

	// change packet type to echo reply
	rxtx_buffer[ ARP_OPCODE_H_P ] = ARP_OPCODE_REPLY_H_V;
    1800:	f8 01       	movw	r30, r16
    1802:	14 8a       	std	Z+20, r1	; 0x14
	rxtx_buffer[ ARP_OPCODE_L_P ] = ARP_OPCODE_REPLY_L_V;
    1804:	82 e0       	ldi	r24, 0x02	; 2
    1806:	85 8b       	std	Z+21, r24	; 0x15
	arp_generate_packet ( rxtx_buffer, dest_mac, &rxtx_buffer[ ARP_SRC_IP_P ] );
    1808:	a8 01       	movw	r20, r16
    180a:	44 5e       	subi	r20, 0xE4	; 228
    180c:	5f 4f       	sbci	r21, 0xFF	; 255
    180e:	c8 01       	movw	r24, r16
    1810:	b7 01       	movw	r22, r14
    1812:	0e 94 93 0b 	call	0x1726	; 0x1726 <arp_generate_packet>
	
	// send arp packet
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(ARP_PACKET) );
    1816:	c8 01       	movw	r24, r16
    1818:	6a e2       	ldi	r22, 0x2A	; 42
    181a:	70 e0       	ldi	r23, 0x00	; 0
    181c:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    1820:	1f 91       	pop	r17
    1822:	0f 91       	pop	r16
    1824:	ff 90       	pop	r15
    1826:	ef 90       	pop	r14
    1828:	08 95       	ret

0000182a <arp_send_request>:
// Function : arp_send_request
// Description : send arp request packet (who is?) to network.
//
//********************************************************************************************
void arp_send_request ( BYTE *rxtx_buffer, BYTE *dest_ip )
{
    182a:	cf 92       	push	r12
    182c:	df 92       	push	r13
    182e:	ef 92       	push	r14
    1830:	ff 92       	push	r15
    1832:	0f 93       	push	r16
    1834:	1f 93       	push	r17
    1836:	df 93       	push	r29
    1838:	cf 93       	push	r28
    183a:	00 d0       	rcall	.+0      	; 0x183c <arp_send_request+0x12>
    183c:	00 d0       	rcall	.+0      	; 0x183e <arp_send_request+0x14>
    183e:	00 d0       	rcall	.+0      	; 0x1840 <arp_send_request+0x16>
    1840:	cd b7       	in	r28, 0x3d	; 61
    1842:	de b7       	in	r29, 0x3e	; 62
    1844:	8c 01       	movw	r16, r24
    1846:	6b 01       	movw	r12, r22
	unsigned char i;
	MAC_ADDR dest_mac;

	// generate ethernet header
	for ( i=0; i<sizeof(MAC_ADDR); i++)
		dest_mac.byte[i] = 0xff;
    1848:	8f ef       	ldi	r24, 0xFF	; 255
    184a:	89 83       	std	Y+1, r24	; 0x01
    184c:	8a 83       	std	Y+2, r24	; 0x02
    184e:	8b 83       	std	Y+3, r24	; 0x03
    1850:	8c 83       	std	Y+4, r24	; 0x04
    1852:	8d 83       	std	Y+5, r24	; 0x05
    1854:	8e 83       	std	Y+6, r24	; 0x06
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_ARP_V}, (BYTE*)&dest_mac );
    1856:	c8 01       	movw	r24, r16
    1858:	66 e0       	ldi	r22, 0x06	; 6
    185a:	78 e0       	ldi	r23, 0x08	; 8
    185c:	7e 01       	movw	r14, r28
    185e:	08 94       	sec
    1860:	e1 1c       	adc	r14, r1
    1862:	f1 1c       	adc	r15, r1
    1864:	a7 01       	movw	r20, r14
    1866:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <eth_generate_header>

	// generate arp packet
	for ( i=0; i<sizeof(MAC_ADDR); i++)
		dest_mac.byte[i] = 0x00;
    186a:	19 82       	std	Y+1, r1	; 0x01
    186c:	1a 82       	std	Y+2, r1	; 0x02
    186e:	1b 82       	std	Y+3, r1	; 0x03
    1870:	1c 82       	std	Y+4, r1	; 0x04
    1872:	1d 82       	std	Y+5, r1	; 0x05
    1874:	1e 82       	std	Y+6, r1	; 0x06
	
	// set arp opcode is request
	rxtx_buffer[ ARP_OPCODE_H_P ] = ARP_OPCODE_REQUEST_H_V;
    1876:	f8 01       	movw	r30, r16
    1878:	14 8a       	std	Z+20, r1	; 0x14
	rxtx_buffer[ ARP_OPCODE_L_P ] = ARP_OPCODE_REQUEST_L_V;
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	85 8b       	std	Z+21, r24	; 0x15
	arp_generate_packet ( rxtx_buffer, (BYTE*)&dest_mac, dest_ip );
    187e:	c8 01       	movw	r24, r16
    1880:	b7 01       	movw	r22, r14
    1882:	a6 01       	movw	r20, r12
    1884:	0e 94 93 0b 	call	0x1726	; 0x1726 <arp_generate_packet>
	
	// send arp packet to network
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(ARP_PACKET) );
    1888:	c8 01       	movw	r24, r16
    188a:	6a e2       	ldi	r22, 0x2A	; 42
    188c:	70 e0       	ldi	r23, 0x00	; 0
    188e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    1892:	26 96       	adiw	r28, 0x06	; 6
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	f8 94       	cli
    1898:	de bf       	out	0x3e, r29	; 62
    189a:	0f be       	out	0x3f, r0	; 63
    189c:	cd bf       	out	0x3d, r28	; 61
    189e:	cf 91       	pop	r28
    18a0:	df 91       	pop	r29
    18a2:	1f 91       	pop	r17
    18a4:	0f 91       	pop	r16
    18a6:	ff 90       	pop	r15
    18a8:	ef 90       	pop	r14
    18aa:	df 90       	pop	r13
    18ac:	cf 90       	pop	r12
    18ae:	08 95       	ret

000018b0 <arp_who_is>:
// Description : send arp request to destination ip, and save destination mac to dest_mac.
// call this function to find the destination mac address before send other packet.
//
//*******************************************************************************************
BYTE arp_who_is ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    18b0:	ff 92       	push	r15
    18b2:	0f 93       	push	r16
    18b4:	1f 93       	push	r17
    18b6:	cf 93       	push	r28
    18b8:	df 93       	push	r29
    18ba:	ec 01       	movw	r28, r24
    18bc:	06 2f       	mov	r16, r22
    18be:	f7 2e       	mov	r15, r23
	BYTE i;
	WORD dlength;

	// send arp request packet to network
	arp_send_request ( rxtx_buffer, dest_ip );
    18c0:	ba 01       	movw	r22, r20
    18c2:	0e 94 15 0c 	call	0x182a	; 0x182a <arp_send_request>
    18c6:	10 e0       	ldi	r17, 0x00	; 0

	for ( i=0; i<10; i++ )
	{
		// Time out 10x10ms = 100ms
		_delay_ms ( 10 );
    18c8:	8a e0       	ldi	r24, 0x0A	; 10
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>
		dlength = enc28j60_packet_receive( rxtx_buffer, MAX_RXTX_BUFFER );
    18d0:	ce 01       	movw	r24, r28
    18d2:	6c ed       	ldi	r22, 0xDC	; 220
    18d4:	75 e0       	ldi	r23, 0x05	; 5
    18d6:	0e 94 82 05 	call	0xb04	; 0xb04 <enc28j60_packet_receive>

		// destination ip address was found on network
		if ( dlength )
    18da:	89 2b       	or	r24, r25
    18dc:	a1 f0       	breq	.+40     	; 0x1906 <arp_who_is+0x56>
		{
			if ( arp_packet_is_arp ( rxtx_buffer, (WORD_BYTES){ARP_OPCODE_REPLY_V} ) )
    18de:	ce 01       	movw	r24, r28
    18e0:	62 e0       	ldi	r22, 0x02	; 2
    18e2:	70 e0       	ldi	r23, 0x00	; 0
    18e4:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <arp_packet_is_arp>
    18e8:	88 23       	and	r24, r24
    18ea:	69 f0       	breq	.+26     	; 0x1906 <arp_who_is+0x56>
			{
				// copy destination mac address from arp reply packet to destination mac address
				memcpy ( dest_mac, &rxtx_buffer[ ETH_SRC_MAC_P ], sizeof(MAC_ADDR) );
    18ec:	80 2f       	mov	r24, r16
    18ee:	9f 2d       	mov	r25, r15
    18f0:	9c 01       	movw	r18, r24
    18f2:	d9 01       	movw	r26, r18
    18f4:	fe 01       	movw	r30, r28
    18f6:	36 96       	adiw	r30, 0x06	; 6
    18f8:	86 e0       	ldi	r24, 0x06	; 6
    18fa:	01 90       	ld	r0, Z+
    18fc:	0d 92       	st	X+, r0
    18fe:	81 50       	subi	r24, 0x01	; 1
    1900:	e1 f7       	brne	.-8      	; 0x18fa <arp_who_is+0x4a>
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	04 c0       	rjmp	.+8      	; 0x190e <arp_who_is+0x5e>
	WORD dlength;

	// send arp request packet to network
	arp_send_request ( rxtx_buffer, dest_ip );

	for ( i=0; i<10; i++ )
    1906:	1f 5f       	subi	r17, 0xFF	; 255
    1908:	1a 30       	cpi	r17, 0x0A	; 10
    190a:	f1 f6       	brne	.-68     	; 0x18c8 <arp_who_is+0x18>
    190c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	// destination ip was not found on network
	return 0;
}
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	1f 91       	pop	r17
    1914:	0f 91       	pop	r16
    1916:	ff 90       	pop	r15
    1918:	08 95       	ret

0000191a <tcp_get_dlength>:
// Function : tcp_get_dlength
// Description : claculate tcp received data length
//
//*****************************************************************************************
WORD tcp_get_dlength ( BYTE *rxtx_buffer )
{
    191a:	fc 01       	movw	r30, r24
	int dlength, hlength;

	dlength = ( rxtx_buffer[ IP_TOTLEN_H_P ] <<8 ) | ( rxtx_buffer[ IP_TOTLEN_L_P ] );
	dlength -= sizeof(IP_HEADER);
    191c:	90 89       	ldd	r25, Z+16	; 0x10
    191e:	80 e0       	ldi	r24, 0x00	; 0
    1920:	21 89       	ldd	r18, Z+17	; 0x11
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	28 2b       	or	r18, r24
    1926:	39 2b       	or	r19, r25
    1928:	24 51       	subi	r18, 0x14	; 20
    192a:	30 40       	sbci	r19, 0x00	; 0
	hlength = (rxtx_buffer[ TCP_HEADER_LEN_P ]>>4) * 4; // generate len in bytes;
	dlength -= hlength;
    192c:	86 a5       	ldd	r24, Z+46	; 0x2e
    192e:	82 95       	swap	r24
    1930:	8f 70       	andi	r24, 0x0F	; 15
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	88 0f       	add	r24, r24
    1936:	99 1f       	adc	r25, r25
    1938:	88 0f       	add	r24, r24
    193a:	99 1f       	adc	r25, r25
    193c:	28 1b       	sub	r18, r24
    193e:	39 0b       	sbc	r19, r25
    1940:	37 ff       	sbrs	r19, 7
    1942:	02 c0       	rjmp	.+4      	; 0x1948 <tcp_get_dlength+0x2e>
    1944:	20 e0       	ldi	r18, 0x00	; 0
    1946:	30 e0       	ldi	r19, 0x00	; 0
	if ( dlength <= 0 )
		dlength=0;
	
	return ((WORD)dlength);
}
    1948:	c9 01       	movw	r24, r18
    194a:	08 95       	ret

0000194c <tcp_get_hlength>:
// Function : tcp_get_hlength
// Description : claculate tcp received header length
//
//*****************************************************************************************
BYTE tcp_get_hlength ( BYTE *rxtx_buffer )
{
    194c:	fc 01       	movw	r30, r24
    194e:	86 a5       	ldd	r24, Z+46	; 0x2e
    1950:	82 95       	swap	r24
    1952:	8f 70       	andi	r24, 0x0F	; 15
	return ((rxtx_buffer[ TCP_HEADER_LEN_P ]>>4) * 4); // generate len in bytes;
}
    1954:	88 0f       	add	r24, r24
    1956:	88 0f       	add	r24, r24
    1958:	08 95       	ret

0000195a <tcp_puts_data_p>:
// Function : tcp_puts_data_p
// Description : puts data from program memory to tx buffer
//
//********************************************************************************************
WORD tcp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
    195a:	4a 5c       	subi	r20, 0xCA	; 202
    195c:	5f 4f       	sbci	r21, 0xFF	; 255
    195e:	dc 01       	movw	r26, r24
    1960:	a4 0f       	add	r26, r20
    1962:	b5 1f       	adc	r27, r21
    1964:	46 53       	subi	r20, 0x36	; 54
    1966:	50 40       	sbci	r21, 0x00	; 0
    1968:	03 c0       	rjmp	.+6      	; 0x1970 <tcp_puts_data_p+0x16>
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
	{
		rxtx_buffer[ TCP_DATA_P + offset ] = ch;
    196a:	8d 93       	st	X+, r24
		offset++;
    196c:	4f 5f       	subi	r20, 0xFF	; 255
    196e:	5f 4f       	sbci	r21, 0xFF	; 255
    1970:	fb 01       	movw	r30, r22
//********************************************************************************************
WORD tcp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
    1972:	6f 5f       	subi	r22, 0xFF	; 255
    1974:	7f 4f       	sbci	r23, 0xFF	; 255
    1976:	84 91       	lpm	r24, Z+
    1978:	88 23       	and	r24, r24
    197a:	b9 f7       	brne	.-18     	; 0x196a <tcp_puts_data_p+0x10>
		rxtx_buffer[ TCP_DATA_P + offset ] = ch;
		offset++;
	}

	return offset;
}
    197c:	ca 01       	movw	r24, r20
    197e:	08 95       	ret

00001980 <tcp_puts_data>:
// Function : tcp_puts_data
// Description : puts data from RAM to tx buffer
//
//********************************************************************************************
WORD tcp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
    1980:	fb 01       	movw	r30, r22
    1982:	4a 5c       	subi	r20, 0xCA	; 202
    1984:	5f 4f       	sbci	r21, 0xFF	; 255
    1986:	dc 01       	movw	r26, r24
    1988:	a4 0f       	add	r26, r20
    198a:	b5 1f       	adc	r27, r21
    198c:	46 53       	subi	r20, 0x36	; 54
    198e:	50 40       	sbci	r21, 0x00	; 0
    1990:	04 c0       	rjmp	.+8      	; 0x199a <tcp_puts_data+0x1a>
	while( *data )
	{
		rxtx_buffer[ TCP_DATA_P + offset ] = *data++;
    1992:	8d 93       	st	X+, r24
    1994:	31 96       	adiw	r30, 0x01	; 1
		offset++;
    1996:	4f 5f       	subi	r20, 0xFF	; 255
    1998:	5f 4f       	sbci	r21, 0xFF	; 255
// Description : puts data from RAM to tx buffer
//
//********************************************************************************************
WORD tcp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
	while( *data )
    199a:	80 81       	ld	r24, Z
    199c:	88 23       	and	r24, r24
    199e:	c9 f7       	brne	.-14     	; 0x1992 <tcp_puts_data+0x12>
		rxtx_buffer[ TCP_DATA_P + offset ] = *data++;
		offset++;
	}

	return offset;
}
    19a0:	ca 01       	movw	r24, r20
    19a2:	08 95       	ret

000019a4 <tcp_send_packet>:
	BYTE clear_seqack,
	WORD next_ack_num,
	WORD dlength,
	BYTE *dest_mac,
	BYTE *dest_ip )
{
    19a4:	2f 92       	push	r2
    19a6:	3f 92       	push	r3
    19a8:	4f 92       	push	r4
    19aa:	5f 92       	push	r5
    19ac:	6f 92       	push	r6
    19ae:	7f 92       	push	r7
    19b0:	8f 92       	push	r8
    19b2:	9f 92       	push	r9
    19b4:	af 92       	push	r10
    19b6:	bf 92       	push	r11
    19b8:	cf 92       	push	r12
    19ba:	df 92       	push	r13
    19bc:	ef 92       	push	r14
    19be:	ff 92       	push	r15
    19c0:	0f 93       	push	r16
    19c2:	1f 93       	push	r17
    19c4:	df 93       	push	r29
    19c6:	cf 93       	push	r28
    19c8:	0f 92       	push	r0
    19ca:	cd b7       	in	r28, 0x3d	; 61
    19cc:	de b7       	in	r29, 0x3e	; 62
    19ce:	3c 01       	movw	r6, r24
    19d0:	26 2e       	mov	r2, r22
    19d2:	47 2e       	mov	r4, r23
    19d4:	49 83       	std	Y+1, r20	; 0x01
    19d6:	35 2e       	mov	r3, r21
    19d8:	52 2e       	mov	r5, r18
    19da:	f0 2e       	mov	r15, r16
    19dc:	85 01       	movw	r16, r10
    19de:	a4 01       	movw	r20, r8
	BYTE i, tseq;
	WORD_BYTES ck;
	
	// generate ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );		
    19e0:	60 e0       	ldi	r22, 0x00	; 0
    19e2:	78 e0       	ldi	r23, 0x08	; 8
    19e4:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <eth_generate_header>

	// sequence numbers:
	// add the rel ack num to SEQACK
	if ( next_ack_num )
    19e8:	c1 14       	cp	r12, r1
    19ea:	d1 04       	cpc	r13, r1
    19ec:	89 f0       	breq	.+34     	; 0x1a10 <tcp_send_packet+0x6c>
    19ee:	f3 01       	movw	r30, r6
    19f0:	b9 96       	adiw	r30, 0x29	; 41
    19f2:	34 e0       	ldi	r19, 0x04	; 4
	{
		for( i=4; i>0; i-- )
		{
			next_ack_num = rxtx_buffer [ TCP_SEQ_P + i - 1] + next_ack_num;
    19f4:	80 81       	ld	r24, Z
    19f6:	a6 01       	movw	r20, r12
    19f8:	48 0f       	add	r20, r24
    19fa:	51 1d       	adc	r21, r1
    19fc:	ca 01       	movw	r24, r20
			tseq = rxtx_buffer [ TCP_SEQACK_P + i - 1];
    19fe:	24 81       	ldd	r18, Z+4	; 0x04
			rxtx_buffer [ TCP_SEQACK_P + i - 1] = 0xff & next_ack_num;
    1a00:	44 83       	std	Z+4, r20	; 0x04

			// copy the acknum sent to us into the sequence number
			rxtx_buffer[ TCP_SEQ_P + i - 1 ] = tseq;
    1a02:	20 83       	st	Z, r18

			next_ack_num >>= 8;
    1a04:	c9 2e       	mov	r12, r25
    1a06:	dd 24       	eor	r13, r13

	// sequence numbers:
	// add the rel ack num to SEQACK
	if ( next_ack_num )
	{
		for( i=4; i>0; i-- )
    1a08:	31 50       	subi	r19, 0x01	; 1
    1a0a:	31 97       	sbiw	r30, 0x01	; 1
    1a0c:	33 23       	and	r19, r19
    1a0e:	91 f7       	brne	.-28     	; 0x19f4 <tcp_send_packet+0x50>
	}
	
	// initial tcp sequence number
	// setup maximum segment size
	// require to setup first packet is receive or transmit only
	if ( max_segment_size )
    1a10:	ff 20       	and	r15, r15
    1a12:	b9 f0       	breq	.+46     	; 0x1a42 <tcp_send_packet+0x9e>
	{
		// initial sequence number
		rxtx_buffer[ TCP_SEQ_P + 0 ] = 0;
    1a14:	f3 01       	movw	r30, r6
    1a16:	16 a2       	std	Z+38, r1	; 0x26
		rxtx_buffer[ TCP_SEQ_P + 1 ] = 0;
    1a18:	17 a2       	std	Z+39, r1	; 0x27
		rxtx_buffer[ TCP_SEQ_P + 2 ] = seqnum;
    1a1a:	80 91 60 00 	lds	r24, 0x0060
    1a1e:	80 a7       	std	Z+40, r24	; 0x28
		rxtx_buffer[ TCP_SEQ_P + 3 ] = 0;
    1a20:	11 a6       	std	Z+41, r1	; 0x29
		seqnum += 2;
    1a22:	8e 5f       	subi	r24, 0xFE	; 254
    1a24:	80 93 60 00 	sts	0x0060, r24

		// setup maximum segment size
		rxtx_buffer[ TCP_OPTIONS_P + 0 ] = 2;
    1a28:	82 e0       	ldi	r24, 0x02	; 2
    1a2a:	86 ab       	std	Z+54, r24	; 0x36
		rxtx_buffer[ TCP_OPTIONS_P + 1 ] = 4;
    1a2c:	84 e0       	ldi	r24, 0x04	; 4
    1a2e:	87 ab       	std	Z+55, r24	; 0x37
		rxtx_buffer[ TCP_OPTIONS_P + 2 ] = HIGH(1408);
    1a30:	85 e0       	ldi	r24, 0x05	; 5
    1a32:	80 af       	std	Z+56, r24	; 0x38
		rxtx_buffer[ TCP_OPTIONS_P + 3 ] = LOW(1408);
    1a34:	80 e8       	ldi	r24, 0x80	; 128
    1a36:	81 af       	std	Z+57, r24	; 0x39
		// setup tcp header length 24 bytes: 6*32/8 = 24
		rxtx_buffer[ TCP_HEADER_LEN_P ] = 0x60;
    1a38:	80 e6       	ldi	r24, 0x60	; 96
    1a3a:	86 a7       	std	Z+46, r24	; 0x2e
		dlength += 4;
    1a3c:	0c 5f       	subi	r16, 0xFC	; 252
    1a3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1a40:	03 c0       	rjmp	.+6      	; 0x1a48 <tcp_send_packet+0xa4>
	}
	else
	{
		// no options: 20 bytes: 5*32/8 = 20
		rxtx_buffer[ TCP_HEADER_LEN_P ] = 0x50;
    1a42:	80 e5       	ldi	r24, 0x50	; 80
    1a44:	f3 01       	movw	r30, r6
    1a46:	86 a7       	std	Z+46, r24	; 0x2e
	}

	// generate ip header and checksum
	ip_generate_header ( rxtx_buffer, (WORD_BYTES){(sizeof(IP_HEADER) + sizeof(TCP_HEADER) + dlength)}, IP_PROTO_TCP_V, dest_ip );
    1a48:	b8 01       	movw	r22, r16
    1a4a:	68 5d       	subi	r22, 0xD8	; 216
    1a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4e:	c3 01       	movw	r24, r6
    1a50:	46 e0       	ldi	r20, 0x06	; 6
    1a52:	2e 89       	ldd	r18, Y+22	; 0x16
    1a54:	3f 89       	ldd	r19, Y+23	; 0x17
    1a56:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <ip_generate_header>
	
	// clear sequence ack number before send tcp SYN packet
	if ( clear_seqack )
    1a5a:	ee 20       	and	r14, r14
    1a5c:	29 f0       	breq	.+10     	; 0x1a68 <tcp_send_packet+0xc4>
	{
		rxtx_buffer[ TCP_SEQACK_P + 0 ] = 0;
    1a5e:	f3 01       	movw	r30, r6
    1a60:	12 a6       	std	Z+42, r1	; 0x2a
		rxtx_buffer[ TCP_SEQACK_P + 1 ] = 0;
    1a62:	13 a6       	std	Z+43, r1	; 0x2b
		rxtx_buffer[ TCP_SEQACK_P + 2 ] = 0;
    1a64:	14 a6       	std	Z+44, r1	; 0x2c
		rxtx_buffer[ TCP_SEQACK_P + 3 ] = 0;
    1a66:	15 a6       	std	Z+45, r1	; 0x2d
	}
		
	// setup tcp flags
	rxtx_buffer [ TCP_FLAGS_P ] = flags;
    1a68:	f3 01       	movw	r30, r6
    1a6a:	57 a6       	std	Z+47, r5	; 0x2f
	
	// setup destination port
	rxtx_buffer [ TCP_DST_PORT_H_P ] = dest_port.byte.high;
    1a6c:	44 a2       	std	Z+36, r4	; 0x24
	rxtx_buffer [ TCP_DST_PORT_L_P ] = dest_port.byte.low;
    1a6e:	25 a2       	std	Z+37, r2	; 0x25

	// setup source port
	rxtx_buffer [ TCP_SRC_PORT_H_P ] = src_port.byte.high;
    1a70:	32 a2       	std	Z+34, r3	; 0x22
	rxtx_buffer [ TCP_SRC_PORT_L_P ] = src_port.byte.low;
    1a72:	49 81       	ldd	r20, Y+1	; 0x01
    1a74:	43 a3       	std	Z+35, r20	; 0x23

	// setup maximum windows size
	rxtx_buffer [ TCP_WINDOWSIZE_H_P ] = HIGH((MAX_RX_BUFFER-sizeof(IP_HEADER)-sizeof(ETH_HEADER)));
    1a76:	85 e0       	ldi	r24, 0x05	; 5
    1a78:	80 ab       	std	Z+48, r24	; 0x30
	rxtx_buffer [ TCP_WINDOWSIZE_L_P ] = LOW((MAX_RX_BUFFER-sizeof(IP_HEADER)-sizeof(ETH_HEADER)));
    1a7a:	8a eb       	ldi	r24, 0xBA	; 186
    1a7c:	81 ab       	std	Z+49, r24	; 0x31
	
	// setup urgend pointer (not used -> 0)
	rxtx_buffer[ TCP_URGENT_PTR_H_P ] = 0;
    1a7e:	14 aa       	std	Z+52, r1	; 0x34
	rxtx_buffer[ TCP_URGENT_PTR_L_P ] = 0;
    1a80:	15 aa       	std	Z+53, r1	; 0x35

	// clear old checksum and calculate new checksum
	rxtx_buffer[ TCP_CHECKSUM_H_P ] = 0;
    1a82:	12 aa       	std	Z+50, r1	; 0x32
	rxtx_buffer[ TCP_CHECKSUM_L_P ] = 0;
    1a84:	13 aa       	std	Z+51, r1	; 0x33
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	// +                                     Destination IP address                                    +
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	// +           0           +      IP Protocol      +                    Total length               +
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	ck.word = software_checksum( &rxtx_buffer[IP_SRC_IP_P], sizeof(TCP_HEADER)+dlength+8, IP_PROTO_TCP_V + sizeof(TCP_HEADER) + dlength );
    1a86:	06 5e       	subi	r16, 0xE6	; 230
    1a88:	1f 4f       	sbci	r17, 0xFF	; 255
    1a8a:	98 01       	movw	r18, r16
    1a8c:	40 e0       	ldi	r20, 0x00	; 0
    1a8e:	50 e0       	ldi	r21, 0x00	; 0
    1a90:	c3 01       	movw	r24, r6
    1a92:	4a 96       	adiw	r24, 0x1a	; 26
    1a94:	0e 5f       	subi	r16, 0xFE	; 254
    1a96:	1f 4f       	sbci	r17, 0xFF	; 255
    1a98:	b8 01       	movw	r22, r16
    1a9a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <software_checksum>
	rxtx_buffer[ TCP_CHECKSUM_H_P ] = ck.byte.high;
    1a9e:	f3 01       	movw	r30, r6
    1aa0:	92 ab       	std	Z+50, r25	; 0x32
	rxtx_buffer[ TCP_CHECKSUM_L_P ] = ck.byte.low;
    1aa2:	83 ab       	std	Z+51, r24	; 0x33

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+dlength );
    1aa4:	06 5e       	subi	r16, 0xE6	; 230
    1aa6:	1f 4f       	sbci	r17, 0xFF	; 255
    1aa8:	c3 01       	movw	r24, r6
    1aaa:	b8 01       	movw	r22, r16
    1aac:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    1ab0:	0f 90       	pop	r0
    1ab2:	cf 91       	pop	r28
    1ab4:	df 91       	pop	r29
    1ab6:	1f 91       	pop	r17
    1ab8:	0f 91       	pop	r16
    1aba:	ff 90       	pop	r15
    1abc:	ef 90       	pop	r14
    1abe:	df 90       	pop	r13
    1ac0:	cf 90       	pop	r12
    1ac2:	bf 90       	pop	r11
    1ac4:	af 90       	pop	r10
    1ac6:	9f 90       	pop	r9
    1ac8:	8f 90       	pop	r8
    1aca:	7f 90       	pop	r7
    1acc:	6f 90       	pop	r6
    1ace:	5f 90       	pop	r5
    1ad0:	4f 90       	pop	r4
    1ad2:	3f 90       	pop	r3
    1ad4:	2f 90       	pop	r2
    1ad6:	08 95       	ret

00001ad8 <ip_packet_is_ip>:
// Function : ip_check_ip
// Description : Check incoming packet
//
//********************************************************************************************
BYTE ip_packet_is_ip ( BYTE *rxtx_buffer )
{
    1ad8:	fc 01       	movw	r30, r24
	unsigned char i;
	
	// if ethernet type is not ip
	if ( rxtx_buffer[ ETH_TYPE_H_P ] != ETH_TYPE_IP_H_V || rxtx_buffer[ ETH_TYPE_L_P ] != ETH_TYPE_IP_L_V)
    1ada:	84 85       	ldd	r24, Z+12	; 0x0c
    1adc:	88 30       	cpi	r24, 0x08	; 8
    1ade:	a1 f4       	brne	.+40     	; 0x1b08 <ip_packet_is_ip+0x30>
    1ae0:	85 85       	ldd	r24, Z+13	; 0x0d
    1ae2:	88 23       	and	r24, r24
    1ae4:	89 f4       	brne	.+34     	; 0x1b08 <ip_packet_is_ip+0x30>
    1ae6:	df 01       	movw	r26, r30
    1ae8:	ef ed       	ldi	r30, 0xDF	; 223
    1aea:	f0 e0       	ldi	r31, 0x00	; 0
		return 0;
	
	// if ip packet not send to avr
	for ( i=0; i<sizeof(IP_ADDR); i++ )
	{
		if ( rxtx_buffer[ IP_DST_IP_P + i ] != avr_ip.byte[i] )
    1aec:	5e 96       	adiw	r26, 0x1e	; 30
    1aee:	9c 91       	ld	r25, X
    1af0:	5e 97       	sbiw	r26, 0x1e	; 30
    1af2:	80 81       	ld	r24, Z
    1af4:	98 17       	cp	r25, r24
    1af6:	41 f4       	brne	.+16     	; 0x1b08 <ip_packet_is_ip+0x30>
    1af8:	11 96       	adiw	r26, 0x01	; 1
    1afa:	31 96       	adiw	r30, 0x01	; 1
	// if ethernet type is not ip
	if ( rxtx_buffer[ ETH_TYPE_H_P ] != ETH_TYPE_IP_H_V || rxtx_buffer[ ETH_TYPE_L_P ] != ETH_TYPE_IP_L_V)
		return 0;
	
	// if ip packet not send to avr
	for ( i=0; i<sizeof(IP_ADDR); i++ )
    1afc:	80 e0       	ldi	r24, 0x00	; 0
    1afe:	e3 3e       	cpi	r30, 0xE3	; 227
    1b00:	f8 07       	cpc	r31, r24
    1b02:	a1 f7       	brne	.-24     	; 0x1aec <ip_packet_is_ip+0x14>
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	08 95       	ret
    1b08:	80 e0       	ldi	r24, 0x00	; 0
			return 0;
	}
	
	// destination ip address match with avr ip address
	return 1;
}
    1b0a:	08 95       	ret

00001b0c <ip_generate_header>:
// Function : ip_generate_packet
// Description : generate all ip header
//
//********************************************************************************************
void ip_generate_header ( BYTE *rxtx_buffer, WORD_BYTES total_length, BYTE protocol, BYTE *dest_ip )
{
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	ec 01       	movw	r28, r24
	BYTE i;
	WORD_BYTES ck;
	
	// set ipv4 and header length
	rxtx_buffer[ IP_P ] = IP_V4_V | IP_HEADER_LENGTH_V;
    1b16:	8c 01       	movw	r16, r24
    1b18:	02 5f       	subi	r16, 0xF2	; 242
    1b1a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b1c:	85 e4       	ldi	r24, 0x45	; 69
    1b1e:	8e 87       	std	Y+14, r24	; 0x0e

	// set TOS to default 0x00
	rxtx_buffer[ IP_TOS_P ] = 0x00;
    1b20:	1f 86       	std	Y+15, r1	; 0x0f

	// set total length
	rxtx_buffer [ IP_TOTLEN_H_P ] = total_length.byte.high;
    1b22:	78 8b       	std	Y+16, r23	; 0x10
	rxtx_buffer [ IP_TOTLEN_L_P ] = total_length.byte.low;
    1b24:	69 8b       	std	Y+17, r22	; 0x11
	
	// set packet identification
	rxtx_buffer [ IP_ID_H_P ] = ip_identfier.byte.high;
    1b26:	80 91 62 00 	lds	r24, 0x0062
    1b2a:	8a 8b       	std	Y+18, r24	; 0x12
	rxtx_buffer [ IP_ID_L_P ] = ip_identfier.byte.low;
    1b2c:	80 91 61 00 	lds	r24, 0x0061
    1b30:	8b 8b       	std	Y+19, r24	; 0x13
	ip_identfier.word++;
    1b32:	80 91 61 00 	lds	r24, 0x0061
    1b36:	90 91 62 00 	lds	r25, 0x0062
    1b3a:	01 96       	adiw	r24, 0x01	; 1
    1b3c:	90 93 62 00 	sts	0x0062, r25
    1b40:	80 93 61 00 	sts	0x0061, r24
	
	// set fragment flags	
	rxtx_buffer [ IP_FLAGS_H_P ] = 0x00;
    1b44:	1c 8a       	std	Y+20, r1	; 0x14
	rxtx_buffer [ IP_FLAGS_L_P ] = 0x00;
    1b46:	1d 8a       	std	Y+21, r1	; 0x15
	
	// set Time To Live
	rxtx_buffer [ IP_TTL_P ] = 128;
    1b48:	80 e8       	ldi	r24, 0x80	; 128
    1b4a:	8e 8b       	std	Y+22, r24	; 0x16
	
	// set ip packettype to tcp/udp/icmp...
	rxtx_buffer [ IP_PROTO_P ] = protocol;
    1b4c:	4f 8b       	std	Y+23, r20	; 0x17
    1b4e:	de 01       	movw	r26, r28
    1b50:	40 e0       	ldi	r20, 0x00	; 0
    1b52:	50 e0       	ldi	r21, 0x00	; 0
	
	// set source and destination ip address
	for ( i=0; i<4; i++ )
	{
		rxtx_buffer[ IP_DST_IP_P + i ] = dest_ip[i];
    1b54:	f9 01       	movw	r30, r18
    1b56:	e4 0f       	add	r30, r20
    1b58:	f5 1f       	adc	r31, r21
    1b5a:	80 81       	ld	r24, Z
    1b5c:	5e 96       	adiw	r26, 0x1e	; 30
    1b5e:	8c 93       	st	X, r24
    1b60:	5e 97       	sbiw	r26, 0x1e	; 30
		rxtx_buffer[ IP_SRC_IP_P + i ] = avr_ip.byte[ i ];
    1b62:	fa 01       	movw	r30, r20
    1b64:	e1 52       	subi	r30, 0x21	; 33
    1b66:	ff 4f       	sbci	r31, 0xFF	; 255
    1b68:	80 81       	ld	r24, Z
    1b6a:	5a 96       	adiw	r26, 0x1a	; 26
    1b6c:	8c 93       	st	X, r24
    1b6e:	5a 97       	sbiw	r26, 0x1a	; 26
    1b70:	4f 5f       	subi	r20, 0xFF	; 255
    1b72:	5f 4f       	sbci	r21, 0xFF	; 255
    1b74:	11 96       	adiw	r26, 0x01	; 1
	
	// set ip packettype to tcp/udp/icmp...
	rxtx_buffer [ IP_PROTO_P ] = protocol;
	
	// set source and destination ip address
	for ( i=0; i<4; i++ )
    1b76:	44 30       	cpi	r20, 0x04	; 4
    1b78:	51 05       	cpc	r21, r1
    1b7a:	61 f7       	brne	.-40     	; 0x1b54 <ip_generate_header+0x48>
		rxtx_buffer[ IP_DST_IP_P + i ] = dest_ip[i];
		rxtx_buffer[ IP_SRC_IP_P + i ] = avr_ip.byte[ i ];
	}
	
	// clear the 2 byte checksum
	rxtx_buffer[ IP_CHECKSUM_H_P ] = 0;
    1b7c:	18 8e       	std	Y+24, r1	; 0x18
	rxtx_buffer[ IP_CHECKSUM_L_P ] = 0;
    1b7e:	19 8e       	std	Y+25, r1	; 0x19

	// fill checksum value
	// calculate the checksum:
	ck.word = software_checksum ( &rxtx_buffer[ IP_P ], sizeof(IP_HEADER), 0 );
    1b80:	c8 01       	movw	r24, r16
    1b82:	64 e1       	ldi	r22, 0x14	; 20
    1b84:	70 e0       	ldi	r23, 0x00	; 0
    1b86:	20 e0       	ldi	r18, 0x00	; 0
    1b88:	30 e0       	ldi	r19, 0x00	; 0
    1b8a:	40 e0       	ldi	r20, 0x00	; 0
    1b8c:	50 e0       	ldi	r21, 0x00	; 0
    1b8e:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <software_checksum>
	rxtx_buffer[ IP_CHECKSUM_H_P ] = ck.byte.high;
    1b92:	98 8f       	std	Y+24, r25	; 0x18
	rxtx_buffer[ IP_CHECKSUM_L_P ] = ck.byte.low;
    1b94:	89 8f       	std	Y+25, r24	; 0x19
}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	08 95       	ret

00001ba0 <eth_generate_header>:
// Description : generarete ethernet header, contain destination and source MAC address,
// ethernet type.
//
//********************************************************************************************
void eth_generate_header ( BYTE *rxtx_buffer, WORD_BYTES type, BYTE *dest_mac )
{
    1ba0:	cf 93       	push	r28
    1ba2:	df 93       	push	r29
    1ba4:	ec 01       	movw	r28, r24
    1ba6:	dc 01       	movw	r26, r24
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	30 e0       	ldi	r19, 0x00	; 0
	BYTE i;
	//copy the destination mac from the source and fill my mac into src
	for ( i=0; i<sizeof(MAC_ADDR); i++)
	{
		rxtx_buffer[ ETH_DST_MAC_P + i ] = dest_mac[i];
    1bac:	fa 01       	movw	r30, r20
    1bae:	e2 0f       	add	r30, r18
    1bb0:	f3 1f       	adc	r31, r19
    1bb2:	80 81       	ld	r24, Z
    1bb4:	8c 93       	st	X, r24
		rxtx_buffer[ ETH_SRC_MAC_P + i ] = avr_mac.byte[i];
    1bb6:	f9 01       	movw	r30, r18
    1bb8:	eb 52       	subi	r30, 0x2B	; 43
    1bba:	ff 4f       	sbci	r31, 0xFF	; 255
    1bbc:	80 81       	ld	r24, Z
    1bbe:	16 96       	adiw	r26, 0x06	; 6
    1bc0:	8c 93       	st	X, r24
    1bc2:	16 97       	sbiw	r26, 0x06	; 6
    1bc4:	2f 5f       	subi	r18, 0xFF	; 255
    1bc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc8:	11 96       	adiw	r26, 0x01	; 1
//********************************************************************************************
void eth_generate_header ( BYTE *rxtx_buffer, WORD_BYTES type, BYTE *dest_mac )
{
	BYTE i;
	//copy the destination mac from the source and fill my mac into src
	for ( i=0; i<sizeof(MAC_ADDR); i++)
    1bca:	26 30       	cpi	r18, 0x06	; 6
    1bcc:	31 05       	cpc	r19, r1
    1bce:	71 f7       	brne	.-36     	; 0x1bac <eth_generate_header+0xc>
	{
		rxtx_buffer[ ETH_DST_MAC_P + i ] = dest_mac[i];
		rxtx_buffer[ ETH_SRC_MAC_P + i ] = avr_mac.byte[i];
	}
	rxtx_buffer[ ETH_TYPE_H_P ] = type.byte.high;//HIGH(type);
    1bd0:	7c 87       	std	Y+12, r23	; 0x0c
	rxtx_buffer[ ETH_TYPE_L_P ] = type.byte.low;//LOW(type);
    1bd2:	6d 87       	std	Y+13, r22	; 0x0d
}
    1bd4:	df 91       	pop	r29
    1bd6:	cf 91       	pop	r28
    1bd8:	08 95       	ret

00001bda <software_checksum>:
// http://www.msc.uky.edu/ken/cs471/notes/chap3.htm
// The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
//
//********************************************************************************************
WORD software_checksum(BYTE *rxtx_buffer, WORD len, DWORD sum)
{
    1bda:	ef 92       	push	r14
    1bdc:	ff 92       	push	r15
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	7c 01       	movw	r14, r24
    1be8:	8b 01       	movw	r16, r22
    1bea:	ec 01       	movw	r28, r24
    1bec:	0f c0       	rjmp	.+30     	; 0x1c0c <software_checksum+0x32>
	// build the sum of 16bit words
	while(len>1)
	{
		sum += 0xFFFF & (*rxtx_buffer<<8|*(rxtx_buffer+1));
    1bee:	f8 81       	ld	r31, Y
    1bf0:	e0 e0       	ldi	r30, 0x00	; 0
    1bf2:	89 81       	ldd	r24, Y+1	; 0x01
    1bf4:	90 e0       	ldi	r25, 0x00	; 0
    1bf6:	8e 2b       	or	r24, r30
    1bf8:	9f 2b       	or	r25, r31
    1bfa:	a0 e0       	ldi	r26, 0x00	; 0
    1bfc:	b0 e0       	ldi	r27, 0x00	; 0
    1bfe:	28 0f       	add	r18, r24
    1c00:	39 1f       	adc	r19, r25
    1c02:	4a 1f       	adc	r20, r26
    1c04:	5b 1f       	adc	r21, r27
		rxtx_buffer+=2;
    1c06:	22 96       	adiw	r28, 0x02	; 2
		len-=2;
    1c08:	62 50       	subi	r22, 0x02	; 2
    1c0a:	70 40       	sbci	r23, 0x00	; 0
//
//********************************************************************************************
WORD software_checksum(BYTE *rxtx_buffer, WORD len, DWORD sum)
{
	// build the sum of 16bit words
	while(len>1)
    1c0c:	62 30       	cpi	r22, 0x02	; 2
    1c0e:	71 05       	cpc	r23, r1
    1c10:	70 f7       	brcc	.-36     	; 0x1bee <software_checksum+0x14>
    1c12:	f8 01       	movw	r30, r16
    1c14:	ee 7f       	andi	r30, 0xFE	; 254
    1c16:	ee 0d       	add	r30, r14
    1c18:	ff 1d       	adc	r31, r15
		sum += 0xFFFF & (*rxtx_buffer<<8|*(rxtx_buffer+1));
		rxtx_buffer+=2;
		len-=2;
	}
	// if there is a byte left then add it (padded with zero)
	if (len)
    1c1a:	00 ff       	sbrs	r16, 0
    1c1c:	0d c0       	rjmp	.+26     	; 0x1c38 <software_checksum+0x5e>
	{
		sum += (0xFF & *rxtx_buffer)<<8;
    1c1e:	90 81       	ld	r25, Z
    1c20:	80 e0       	ldi	r24, 0x00	; 0
    1c22:	aa 27       	eor	r26, r26
    1c24:	97 fd       	sbrc	r25, 7
    1c26:	a0 95       	com	r26
    1c28:	ba 2f       	mov	r27, r26
    1c2a:	02 c0       	rjmp	.+4      	; 0x1c30 <software_checksum+0x56>
	}
	// now calculate the sum over the bytes in the sum
	// until the result is only 16bit long
	while (sum>>16)
	{
		sum = (sum & 0xFFFF)+(sum >> 16);
    1c2c:	40 70       	andi	r20, 0x00	; 0
    1c2e:	50 70       	andi	r21, 0x00	; 0
    1c30:	28 0f       	add	r18, r24
    1c32:	39 1f       	adc	r19, r25
    1c34:	4a 1f       	adc	r20, r26
    1c36:	5b 1f       	adc	r21, r27
	{
		sum += (0xFF & *rxtx_buffer)<<8;
	}
	// now calculate the sum over the bytes in the sum
	// until the result is only 16bit long
	while (sum>>16)
    1c38:	ca 01       	movw	r24, r20
    1c3a:	aa 27       	eor	r26, r26
    1c3c:	bb 27       	eor	r27, r27
    1c3e:	00 97       	sbiw	r24, 0x00	; 0
    1c40:	a1 05       	cpc	r26, r1
    1c42:	b1 05       	cpc	r27, r1
    1c44:	99 f7       	brne	.-26     	; 0x1c2c <software_checksum+0x52>
    1c46:	20 95       	com	r18
    1c48:	30 95       	com	r19
	{
		sum = (sum & 0xFFFF)+(sum >> 16);
	}
	// build 1's complement:
	return( (WORD) sum ^ 0xFFFF);
}
    1c4a:	c9 01       	movw	r24, r18
    1c4c:	df 91       	pop	r29
    1c4e:	cf 91       	pop	r28
    1c50:	1f 91       	pop	r17
    1c52:	0f 91       	pop	r16
    1c54:	ff 90       	pop	r15
    1c56:	ef 90       	pop	r14
    1c58:	08 95       	ret

00001c5a <icmp_generate_packet>:
// Function : icmp_send_reply
// Description : Send ARP reply packet from ARP request packet
//
//*******************************************************************************************
void icmp_generate_packet ( BYTE *rxtx_buffer )
{
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	ec 01       	movw	r28, r24
	BYTE i;
	WORD_BYTES ck;
	
	// In send ICMP request case, generate new ICMP data.
	if ( rxtx_buffer[ ICMP_TYPE_P ] == ICMP_TYPE_ECHOREQUEST_V )
    1c60:	9c 01       	movw	r18, r24
    1c62:	2e 5d       	subi	r18, 0xDE	; 222
    1c64:	3f 4f       	sbci	r19, 0xFF	; 255
    1c66:	8a a1       	ldd	r24, Y+34	; 0x22
    1c68:	88 30       	cpi	r24, 0x08	; 8
    1c6a:	39 f4       	brne	.+14     	; 0x1c7a <icmp_generate_packet+0x20>
    1c6c:	fe 01       	movw	r30, r28
    1c6e:	ba 96       	adiw	r30, 0x2a	; 42
    1c70:	81 e4       	ldi	r24, 0x41	; 65
	{
		for ( i=0; i<ICMP_MAX_DATA; i++ )
		{
			rxtx_buffer[ ICMP_DATA_P + i ] = 'A' + i;
    1c72:	81 93       	st	Z+, r24
    1c74:	8f 5f       	subi	r24, 0xFF	; 255
	WORD_BYTES ck;
	
	// In send ICMP request case, generate new ICMP data.
	if ( rxtx_buffer[ ICMP_TYPE_P ] == ICMP_TYPE_ECHOREQUEST_V )
	{
		for ( i=0; i<ICMP_MAX_DATA; i++ )
    1c76:	81 36       	cpi	r24, 0x61	; 97
    1c78:	e1 f7       	brne	.-8      	; 0x1c72 <icmp_generate_packet+0x18>
		{
			rxtx_buffer[ ICMP_DATA_P + i ] = 'A' + i;
		}
	}
	// clear icmp checksum
	rxtx_buffer[ ICMP_CHECKSUM_H_P ] = 0;
    1c7a:	1c a2       	std	Y+36, r1	; 0x24
	rxtx_buffer[ ICMP_CHECKSUM_L_P ] = 0;
    1c7c:	1d a2       	std	Y+37, r1	; 0x25

	// calculate new checksum.
	// ICMP checksum calculation begin at ICMP type to ICMP data.
	// Before calculate new checksum the checksum field must be zero.
	ck.word = software_checksum ( &rxtx_buffer[ ICMP_TYPE_P ], sizeof(ICMP_PACKET), 0 );
    1c7e:	c9 01       	movw	r24, r18
    1c80:	68 e2       	ldi	r22, 0x28	; 40
    1c82:	70 e0       	ldi	r23, 0x00	; 0
    1c84:	20 e0       	ldi	r18, 0x00	; 0
    1c86:	30 e0       	ldi	r19, 0x00	; 0
    1c88:	40 e0       	ldi	r20, 0x00	; 0
    1c8a:	50 e0       	ldi	r21, 0x00	; 0
    1c8c:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <software_checksum>
	rxtx_buffer[ ICMP_CHECKSUM_H_P ] = ck.byte.high;
    1c90:	9c a3       	std	Y+36, r25	; 0x24
	rxtx_buffer[ ICMP_CHECKSUM_L_P ] = ck.byte.low;
    1c92:	8d a3       	std	Y+37, r24	; 0x25
}
    1c94:	df 91       	pop	r29
    1c96:	cf 91       	pop	r28
    1c98:	08 95       	ret

00001c9a <icmp_send_reply>:
// Function : icmp_send_reply
// Description : Send ARP reply packet to destination.
//
//*******************************************************************************************
BYTE icmp_send_reply ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1c9a:	0f 93       	push	r16
    1c9c:	1f 93       	push	r17
    1c9e:	cf 93       	push	r28
    1ca0:	df 93       	push	r29
    1ca2:	ec 01       	movw	r28, r24
    1ca4:	9b 01       	movw	r18, r22
    1ca6:	8a 01       	movw	r16, r20
	
	// check protocol is icmp or not?
	if ( rxtx_buffer [ IP_PROTO_P ] != IP_PROTO_ICMP_V )
    1ca8:	8f 89       	ldd	r24, Y+23	; 0x17
    1caa:	81 30       	cpi	r24, 0x01	; 1
    1cac:	f9 f4       	brne	.+62     	; 0x1cec <icmp_send_reply+0x52>
		return 0;
	
	// check icmp packet type is echo request or not?
	if ( rxtx_buffer [ ICMP_TYPE_P ] != ICMP_TYPE_ECHOREQUEST_V )
    1cae:	8a a1       	ldd	r24, Y+34	; 0x22
    1cb0:	88 30       	cpi	r24, 0x08	; 8
    1cb2:	e1 f4       	brne	.+56     	; 0x1cec <icmp_send_reply+0x52>
		return 0;

	// set ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );
    1cb4:	ce 01       	movw	r24, r28
    1cb6:	60 e0       	ldi	r22, 0x00	; 0
    1cb8:	78 e0       	ldi	r23, 0x08	; 8
    1cba:	a9 01       	movw	r20, r18
    1cbc:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <eth_generate_header>
	
	// generate ip header and checksum
	ip_generate_header ( rxtx_buffer, (WORD_BYTES){(rxtx_buffer[IP_TOTLEN_H_P]<<8)|rxtx_buffer[IP_TOTLEN_L_P]}, IP_PROTO_ICMP_V, dest_ip );
    1cc0:	78 89       	ldd	r23, Y+16	; 0x10
    1cc2:	60 e0       	ldi	r22, 0x00	; 0
    1cc4:	89 89       	ldd	r24, Y+17	; 0x11
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	68 2b       	or	r22, r24
    1cca:	79 2b       	or	r23, r25
    1ccc:	ce 01       	movw	r24, r28
    1cce:	41 e0       	ldi	r20, 0x01	; 1
    1cd0:	98 01       	movw	r18, r16
    1cd2:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <ip_generate_header>

	// generate icmp packet
	rxtx_buffer[ ICMP_TYPE_P ] = ICMP_TYPE_ECHOREPLY_V;
    1cd6:	1a a2       	std	Y+34, r1	; 0x22
	icmp_generate_packet ( rxtx_buffer );
    1cd8:	ce 01       	movw	r24, r28
    1cda:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <icmp_generate_packet>

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(IP_HEADER) + sizeof(ICMP_PACKET) );
    1cde:	ce 01       	movw	r24, r28
    1ce0:	6a e4       	ldi	r22, 0x4A	; 74
    1ce2:	70 e0       	ldi	r23, 0x00	; 0
    1ce4:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
    1ce8:	81 e0       	ldi	r24, 0x01	; 1
    1cea:	01 c0       	rjmp	.+2      	; 0x1cee <icmp_send_reply+0x54>
	return 1;
    1cec:	80 e0       	ldi	r24, 0x00	; 0
}
    1cee:	df 91       	pop	r29
    1cf0:	cf 91       	pop	r28
    1cf2:	1f 91       	pop	r17
    1cf4:	0f 91       	pop	r16
    1cf6:	08 95       	ret

00001cf8 <icmp_send_request>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void icmp_send_request ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{	
    1cf8:	ef 92       	push	r14
    1cfa:	ff 92       	push	r15
    1cfc:	0f 93       	push	r16
    1cfe:	1f 93       	push	r17
    1d00:	8c 01       	movw	r16, r24
    1d02:	9b 01       	movw	r18, r22
    1d04:	7a 01       	movw	r14, r20
	// set ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );
    1d06:	60 e0       	ldi	r22, 0x00	; 0
    1d08:	78 e0       	ldi	r23, 0x08	; 8
    1d0a:	a9 01       	movw	r20, r18
    1d0c:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <eth_generate_header>
	
	// generate ip header and checksum
	ip_generate_header (	rxtx_buffer, (WORD_BYTES){sizeof(IP_HEADER) + sizeof(ICMP_PACKET)}, IP_PROTO_ICMP_V, dest_ip );
    1d10:	c8 01       	movw	r24, r16
    1d12:	6c e3       	ldi	r22, 0x3C	; 60
    1d14:	70 e0       	ldi	r23, 0x00	; 0
    1d16:	41 e0       	ldi	r20, 0x01	; 1
    1d18:	97 01       	movw	r18, r14
    1d1a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <ip_generate_header>

	// generate icmp packet and checksum
	rxtx_buffer[ ICMP_TYPE_P ] = ICMP_TYPE_ECHOREQUEST_V;
    1d1e:	88 e0       	ldi	r24, 0x08	; 8
    1d20:	f8 01       	movw	r30, r16
    1d22:	82 a3       	std	Z+34, r24	; 0x22
	rxtx_buffer[ ICMP_CODE_P ] = 0;
    1d24:	13 a2       	std	Z+35, r1	; 0x23
	rxtx_buffer[ ICMP_IDENTIFIER_H_P ] = icmp_id;
    1d26:	80 91 63 00 	lds	r24, 0x0063
    1d2a:	86 a3       	std	Z+38, r24	; 0x26
	rxtx_buffer[ ICMP_IDENTIFIER_L_P ] = 0;
    1d2c:	17 a2       	std	Z+39, r1	; 0x27
	rxtx_buffer[ ICMP_SEQUENCE_H_P ] = icmp_seq;
    1d2e:	80 91 64 00 	lds	r24, 0x0064
    1d32:	80 a7       	std	Z+40, r24	; 0x28
	rxtx_buffer[ ICMP_SEQUENCE_L_P ] = 0;
    1d34:	11 a6       	std	Z+41, r1	; 0x29
	icmp_id++;
    1d36:	80 91 63 00 	lds	r24, 0x0063
    1d3a:	8f 5f       	subi	r24, 0xFF	; 255
    1d3c:	80 93 63 00 	sts	0x0063, r24
	icmp_seq++;
    1d40:	80 91 64 00 	lds	r24, 0x0064
    1d44:	8f 5f       	subi	r24, 0xFF	; 255
    1d46:	80 93 64 00 	sts	0x0064, r24
	icmp_generate_packet ( rxtx_buffer );	
    1d4a:	c8 01       	movw	r24, r16
    1d4c:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <icmp_generate_packet>

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(IP_HEADER) + sizeof(ICMP_PACKET) );
    1d50:	c8 01       	movw	r24, r16
    1d52:	6a e4       	ldi	r22, 0x4A	; 74
    1d54:	70 e0       	ldi	r23, 0x00	; 0
    1d56:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    1d5a:	1f 91       	pop	r17
    1d5c:	0f 91       	pop	r16
    1d5e:	ff 90       	pop	r15
    1d60:	ef 90       	pop	r14
    1d62:	08 95       	ret

00001d64 <icmp_ping>:
// Function : icmp_ping_server
// Description : Send ARP reply packet to destination.
//
//*******************************************************************************************
BYTE icmp_ping ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1d64:	0f 93       	push	r16
    1d66:	1f 93       	push	r17
    1d68:	cf 93       	push	r28
    1d6a:	df 93       	push	r29
    1d6c:	ec 01       	movw	r28, r24
    1d6e:	8a 01       	movw	r16, r20
	BYTE i;
	WORD dlength;
	
	// destination ip was not found on network.
	if ( arp_who_is ( rxtx_buffer, dest_mac, dest_ip ) == 0 )
    1d70:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <arp_who_is>
    1d74:	88 23       	and	r24, r24
    1d76:	e9 f0       	breq	.+58     	; 0x1db2 <icmp_ping+0x4e>
		return 0;

	// send icmp request packet (ping) to server
	icmp_send_request ( rxtx_buffer, (BYTE*)&server_mac, dest_ip );
    1d78:	ce 01       	movw	r24, r28
    1d7a:	63 ee       	ldi	r22, 0xE3	; 227
    1d7c:	70 e0       	ldi	r23, 0x00	; 0
    1d7e:	a8 01       	movw	r20, r16
    1d80:	0e 94 7c 0e 	call	0x1cf8	; 0x1cf8 <icmp_send_request>
    1d84:	10 e0       	ldi	r17, 0x00	; 0

	for ( i=0; i<10; i++ )
	{
		_delay_ms( 10 );
    1d86:	8a e0       	ldi	r24, 0x0A	; 10
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>
		dlength = enc28j60_packet_receive( rxtx_buffer, MAX_RXTX_BUFFER );
    1d8e:	ce 01       	movw	r24, r28
    1d90:	6c ed       	ldi	r22, 0xDC	; 220
    1d92:	75 e0       	ldi	r23, 0x05	; 5
    1d94:	0e 94 82 05 	call	0xb04	; 0xb04 <enc28j60_packet_receive>

		if ( dlength )
    1d98:	89 2b       	or	r24, r25
    1d9a:	41 f0       	breq	.+16     	; 0x1dac <icmp_ping+0x48>
		{
			// check protocol is icmp or not?
			if ( rxtx_buffer [ IP_PROTO_P ] != IP_PROTO_ICMP_V )
    1d9c:	8f 89       	ldd	r24, Y+23	; 0x17
    1d9e:	81 30       	cpi	r24, 0x01	; 1
    1da0:	29 f4       	brne	.+10     	; 0x1dac <icmp_ping+0x48>
				continue;
	
			// check icmp packet type is echo reply or not?
			if ( rxtx_buffer [ ICMP_TYPE_P ] != ICMP_TYPE_ECHOREPLY_V )
    1da2:	8a a1       	ldd	r24, Y+34	; 0x22
    1da4:	88 23       	and	r24, r24
    1da6:	11 f4       	brne	.+4      	; 0x1dac <icmp_ping+0x48>
				continue;
    1da8:	81 e0       	ldi	r24, 0x01	; 1
    1daa:	04 c0       	rjmp	.+8      	; 0x1db4 <icmp_ping+0x50>
		return 0;

	// send icmp request packet (ping) to server
	icmp_send_request ( rxtx_buffer, (BYTE*)&server_mac, dest_ip );

	for ( i=0; i<10; i++ )
    1dac:	1f 5f       	subi	r17, 0xFF	; 255
    1dae:	1a 30       	cpi	r17, 0x0A	; 10
    1db0:	51 f7       	brne	.-44     	; 0x1d86 <icmp_ping+0x22>
    1db2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	// time out
	return 0;
}
    1db4:	df 91       	pop	r29
    1db6:	cf 91       	pop	r28
    1db8:	1f 91       	pop	r17
    1dba:	0f 91       	pop	r16
    1dbc:	08 95       	ret

00001dbe <udp_puts_data>:
// Function : udp_puts_data
// Description : puts data from RAM to UDP tx buffer
//
//********************************************************************************************
WORD udp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
    1dbe:	fb 01       	movw	r30, r22
    1dc0:	46 5d       	subi	r20, 0xD6	; 214
    1dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    1dc4:	dc 01       	movw	r26, r24
    1dc6:	a4 0f       	add	r26, r20
    1dc8:	b5 1f       	adc	r27, r21
    1dca:	4a 52       	subi	r20, 0x2A	; 42
    1dcc:	50 40       	sbci	r21, 0x00	; 0
    1dce:	04 c0       	rjmp	.+8      	; 0x1dd8 <udp_puts_data+0x1a>
	while( *data )
	{
		rxtx_buffer[ UDP_DATA_P + offset ] = *data++;
    1dd0:	8d 93       	st	X+, r24
    1dd2:	31 96       	adiw	r30, 0x01	; 1
		offset++;
    1dd4:	4f 5f       	subi	r20, 0xFF	; 255
    1dd6:	5f 4f       	sbci	r21, 0xFF	; 255
// Description : puts data from RAM to UDP tx buffer
//
//********************************************************************************************
WORD udp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
	while( *data )
    1dd8:	80 81       	ld	r24, Z
    1dda:	88 23       	and	r24, r24
    1ddc:	c9 f7       	brne	.-14     	; 0x1dd0 <udp_puts_data+0x12>
		rxtx_buffer[ UDP_DATA_P + offset ] = *data++;
		offset++;
	}

	return offset;
}
    1dde:	ca 01       	movw	r24, r20
    1de0:	08 95       	ret

00001de2 <udp_puts_data_p>:
// Function : udp_puts_data_p
// Description : puts data from program memory to tx buffer
//
//********************************************************************************************
WORD udp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
    1de2:	46 5d       	subi	r20, 0xD6	; 214
    1de4:	5f 4f       	sbci	r21, 0xFF	; 255
    1de6:	dc 01       	movw	r26, r24
    1de8:	a4 0f       	add	r26, r20
    1dea:	b5 1f       	adc	r27, r21
    1dec:	4a 52       	subi	r20, 0x2A	; 42
    1dee:	50 40       	sbci	r21, 0x00	; 0
    1df0:	03 c0       	rjmp	.+6      	; 0x1df8 <udp_puts_data_p+0x16>
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
	{
		rxtx_buffer[ UDP_DATA_P + offset ] = ch;
    1df2:	8d 93       	st	X+, r24
		offset++;
    1df4:	4f 5f       	subi	r20, 0xFF	; 255
    1df6:	5f 4f       	sbci	r21, 0xFF	; 255
    1df8:	fb 01       	movw	r30, r22
//********************************************************************************************
WORD udp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
    1dfa:	6f 5f       	subi	r22, 0xFF	; 255
    1dfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1dfe:	84 91       	lpm	r24, Z+
    1e00:	88 23       	and	r24, r24
    1e02:	b9 f7       	brne	.-18     	; 0x1df2 <udp_puts_data_p+0x10>
		rxtx_buffer[ UDP_DATA_P + offset ] = ch;
		offset++;
	}

	return offset;
}
    1e04:	ca 01       	movw	r24, r20
    1e06:	08 95       	ret

00001e08 <udp_generate_header>:
//
// Description : generate udp header
//
//********************************************************************************************
void udp_generate_header ( BYTE *rxtx_buffer, WORD_BYTES dest_port, WORD_BYTES length )
{
    1e08:	0f 93       	push	r16
    1e0a:	1f 93       	push	r17
    1e0c:	8c 01       	movw	r16, r24
	WORD_BYTES ck;

	// setup source port, default value is 3000
	rxtx_buffer[UDP_SRC_PORT_H_P] = UDP_AVR_PORT_H_V;
    1e0e:	8b e0       	ldi	r24, 0x0B	; 11
    1e10:	f8 01       	movw	r30, r16
    1e12:	82 a3       	std	Z+34, r24	; 0x22
	rxtx_buffer[UDP_SRC_PORT_L_P] = UDP_AVR_PORT_L_V;
    1e14:	88 eb       	ldi	r24, 0xB8	; 184
    1e16:	83 a3       	std	Z+35, r24	; 0x23

	// setup destination port
	rxtx_buffer[UDP_DST_PORT_H_P] = dest_port.byte.high;
    1e18:	74 a3       	std	Z+36, r23	; 0x24
	rxtx_buffer[UDP_DST_PORT_L_P] = dest_port.byte.low;
    1e1a:	65 a3       	std	Z+37, r22	; 0x25

	// setup udp length
	rxtx_buffer[UDP_LENGTH_H_P] = length.byte.high;
    1e1c:	56 a3       	std	Z+38, r21	; 0x26
	rxtx_buffer[UDP_LENGTH_L_P] = length.byte.low;
    1e1e:	47 a3       	std	Z+39, r20	; 0x27

	// setup udp checksum
	rxtx_buffer[UDP_CHECKSUM_H_P] = 0;
    1e20:	10 a6       	std	Z+40, r1	; 0x28
	rxtx_buffer[UDP_CHECKSUM_L_P] = 0;
    1e22:	11 a6       	std	Z+41, r1	; 0x29
	// length+8 for source/destination IP address length (8-bytes)
	ck.word = software_checksum ( (BYTE*)&rxtx_buffer[IP_SRC_IP_P], length.word+8, length.word+IP_PROTO_UDP_V);
    1e24:	ba 01       	movw	r22, r20
    1e26:	6f 5e       	subi	r22, 0xEF	; 239
    1e28:	7f 4f       	sbci	r23, 0xFF	; 255
    1e2a:	9b 01       	movw	r18, r22
    1e2c:	40 e0       	ldi	r20, 0x00	; 0
    1e2e:	50 e0       	ldi	r21, 0x00	; 0
    1e30:	c8 01       	movw	r24, r16
    1e32:	4a 96       	adiw	r24, 0x1a	; 26
    1e34:	69 50       	subi	r22, 0x09	; 9
    1e36:	70 40       	sbci	r23, 0x00	; 0
    1e38:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <software_checksum>
	rxtx_buffer[UDP_CHECKSUM_H_P] = ck.byte.high;
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	90 a7       	std	Z+40, r25	; 0x28
	rxtx_buffer[UDP_CHECKSUM_L_P] = ck.byte.low;
    1e40:	81 a7       	std	Z+41, r24	; 0x29
}
    1e42:	1f 91       	pop	r17
    1e44:	0f 91       	pop	r16
    1e46:	08 95       	ret

00001e48 <udp_receive>:
//
// Description : check received packet and process UDP command.
//
//********************************************************************************************
BYTE udp_receive ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1e48:	ef 92       	push	r14
    1e4a:	ff 92       	push	r15
    1e4c:	0f 93       	push	r16
    1e4e:	1f 93       	push	r17
    1e50:	cf 93       	push	r28
    1e52:	df 93       	push	r29
    1e54:	8c 01       	movw	r16, r24
    1e56:	9b 01       	movw	r18, r22
    1e58:	7a 01       	movw	r14, r20
	WORD_BYTES dlength, adc0;
	BYTE generic_buf[64], temp, count_time_temp[3], tmp;

	// check UDP packet and check destination port
	if ( rxtx_buffer[IP_PROTO_P] != IP_PROTO_UDP_V || rxtx_buffer[UDP_DST_PORT_H_P] != UDP_AVR_PORT_H_V || rxtx_buffer[ UDP_DST_PORT_L_P ] != UDP_AVR_PORT_L_V )
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	87 89       	ldd	r24, Z+23	; 0x17
    1e5e:	81 31       	cpi	r24, 0x11	; 17
    1e60:	99 f5       	brne	.+102    	; 0x1ec8 <udp_receive+0x80>
    1e62:	84 a1       	ldd	r24, Z+36	; 0x24
    1e64:	8b 30       	cpi	r24, 0x0B	; 11
    1e66:	81 f5       	brne	.+96     	; 0x1ec8 <udp_receive+0x80>
    1e68:	85 a1       	ldd	r24, Z+37	; 0x25
    1e6a:	88 3b       	cpi	r24, 0xB8	; 184
    1e6c:	69 f5       	brne	.+90     	; 0x1ec8 <udp_receive+0x80>
    1e6e:	d8 01       	movw	r26, r16
    1e70:	9a 96       	adiw	r26, 0x2a	; 42
    1e72:	c0 e0       	ldi	r28, 0x00	; 0
    1e74:	d0 e0       	ldi	r29, 0x00	; 0
    1e76:	02 c0       	rjmp	.+4      	; 0x1e7c <udp_receive+0x34>
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
	{
		rxtx_buffer[ UDP_DATA_P + offset ] = ch;
    1e78:	8d 93       	st	X+, r24
		offset++;
    1e7a:	21 96       	adiw	r28, 0x01	; 1
//********************************************************************************************
WORD udp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
    1e7c:	fe 01       	movw	r30, r28
    1e7e:	e8 5f       	subi	r30, 0xF8	; 248
    1e80:	f6 4f       	sbci	r31, 0xF6	; 246
    1e82:	84 91       	lpm	r24, Z+
    1e84:	88 23       	and	r24, r24
    1e86:	c1 f7       	brne	.-16     	; 0x1e78 <udp_receive+0x30>
	
	// unknown command, send "ERROR" to client
	dlength.word = udp_puts_data_p ( rxtx_buffer, PSTR("ERROR\r\n"), 0 );

	// set ethernet header
	eth_generate_header (rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );
    1e88:	c8 01       	movw	r24, r16
    1e8a:	60 e0       	ldi	r22, 0x00	; 0
    1e8c:	78 e0       	ldi	r23, 0x08	; 8
    1e8e:	a9 01       	movw	r20, r18
    1e90:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <eth_generate_header>
	
	// generate ip header and checksum
	ip_generate_header (rxtx_buffer, (WORD_BYTES){sizeof(IP_HEADER)+sizeof(UDP_HEADER)+dlength.word}, IP_PROTO_UDP_V, dest_ip );
    1e94:	6c 96       	adiw	r28, 0x1c	; 28
    1e96:	c8 01       	movw	r24, r16
    1e98:	be 01       	movw	r22, r28
    1e9a:	41 e1       	ldi	r20, 0x11	; 17
    1e9c:	97 01       	movw	r18, r14
    1e9e:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <ip_generate_header>

	// generate UDP header
	udp_generate_header (rxtx_buffer, (WORD_BYTES){(rxtx_buffer[UDP_SRC_PORT_H_P]<<8)|rxtx_buffer[UDP_SRC_PORT_L_P]}, (WORD_BYTES){sizeof(UDP_HEADER)+dlength.word});
    1ea2:	f8 01       	movw	r30, r16
    1ea4:	72 a1       	ldd	r23, Z+34	; 0x22
    1ea6:	60 e0       	ldi	r22, 0x00	; 0
    1ea8:	83 a1       	ldd	r24, Z+35	; 0x23
    1eaa:	90 e0       	ldi	r25, 0x00	; 0
    1eac:	68 2b       	or	r22, r24
    1eae:	79 2b       	or	r23, r25
    1eb0:	64 97       	sbiw	r28, 0x14	; 20
    1eb2:	c8 01       	movw	r24, r16
    1eb4:	ae 01       	movw	r20, r28
    1eb6:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <udp_generate_header>

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER)+sizeof(IP_HEADER)+sizeof(UDP_HEADER)+dlength.word );
    1eba:	a2 96       	adiw	r28, 0x22	; 34
    1ebc:	c8 01       	movw	r24, r16
    1ebe:	be 01       	movw	r22, r28
    1ec0:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	01 c0       	rjmp	.+2      	; 0x1eca <udp_receive+0x82>

	return 1;
    1ec8:	80 e0       	ldi	r24, 0x00	; 0
}
    1eca:	df 91       	pop	r29
    1ecc:	cf 91       	pop	r28
    1ece:	1f 91       	pop	r17
    1ed0:	0f 91       	pop	r16
    1ed2:	ff 90       	pop	r15
    1ed4:	ef 90       	pop	r14
    1ed6:	08 95       	ret

00001ed8 <_delay_ms>:
void _delay_ms(int delayIn_MS);
void _delay_us(int delayIn_uS);

//function to give delay of X Milli-seconds
void _delay_ms(int delayIn_MS)
{	int i;
    1ed8:	40 e0       	ldi	r20, 0x00	; 0
    1eda:	50 e0       	ldi	r21, 0x00	; 0
    1edc:	09 c0       	rjmp	.+18     	; 0x1ef0 <_delay_ms+0x18>
	double j=0;
	for (i=0; i<delayIn_MS; i++)
    1ede:	20 e0       	ldi	r18, 0x00	; 0
    1ee0:	30 e0       	ldi	r19, 0x00	; 0
    1ee2:	2f 5f       	subi	r18, 0xFF	; 255
    1ee4:	3f 4f       	sbci	r19, 0xFF	; 255
		for (j=0; j<MS_DelayCnt; j++);
    1ee6:	26 33       	cpi	r18, 0x36	; 54
    1ee8:	31 05       	cpc	r19, r1
    1eea:	d9 f7       	brne	.-10     	; 0x1ee2 <_delay_ms+0xa>

//function to give delay of X Milli-seconds
void _delay_ms(int delayIn_MS)
{	int i;
	double j=0;
	for (i=0; i<delayIn_MS; i++)
    1eec:	4f 5f       	subi	r20, 0xFF	; 255
    1eee:	5f 4f       	sbci	r21, 0xFF	; 255
    1ef0:	48 17       	cp	r20, r24
    1ef2:	59 07       	cpc	r21, r25
    1ef4:	a4 f3       	brlt	.-24     	; 0x1ede <_delay_ms+0x6>
		for (j=0; j<MS_DelayCnt; j++);
}
    1ef6:	08 95       	ret

00001ef8 <_delay_us>:

//function to give delay of X micro-seconds
void _delay_us(int delayIn_uS)
{	int i;
    1ef8:	40 e0       	ldi	r20, 0x00	; 0
    1efa:	50 e0       	ldi	r21, 0x00	; 0
    1efc:	09 c0       	rjmp	.+18     	; 0x1f10 <_delay_us+0x18>
	double j=0;
	for (i=0; i<delayIn_uS; i++)
    1efe:	20 e0       	ldi	r18, 0x00	; 0
    1f00:	30 e0       	ldi	r19, 0x00	; 0
    1f02:	2f 5f       	subi	r18, 0xFF	; 255
    1f04:	3f 4f       	sbci	r19, 0xFF	; 255
		for (j=0; j<uS_DelayCnt; j++);
    1f06:	2a 30       	cpi	r18, 0x0A	; 10
    1f08:	31 05       	cpc	r19, r1
    1f0a:	d9 f7       	brne	.-10     	; 0x1f02 <_delay_us+0xa>

//function to give delay of X micro-seconds
void _delay_us(int delayIn_uS)
{	int i;
	double j=0;
	for (i=0; i<delayIn_uS; i++)
    1f0c:	4f 5f       	subi	r20, 0xFF	; 255
    1f0e:	5f 4f       	sbci	r21, 0xFF	; 255
    1f10:	48 17       	cp	r20, r24
    1f12:	59 07       	cpc	r21, r25
    1f14:	a4 f3       	brlt	.-24     	; 0x1efe <_delay_us+0x6>
		for (j=0; j<uS_DelayCnt; j++);
}
    1f16:	08 95       	ret

00001f18 <initTimer_heartBeat>:
			1		1		1		-->		External Clock Source on PIN T0.
											Clock On Rising Edge			 */
	 /************************************************************************/
	 
	// Prescaler = FCPU/1024
	TCCR0 |= (1 << CS02) | (1 << CS00);
    1f18:	83 b7       	in	r24, 0x33	; 51
    1f1a:	85 60       	ori	r24, 0x05	; 5
    1f1c:	83 bf       	out	0x33, r24	; 51
   
	//Enable Overflow Interrupt Enable
	TIMSK |= 1 << TOIE0;
    1f1e:	89 b7       	in	r24, 0x39	; 57
    1f20:	81 60       	ori	r24, 0x01	; 1
    1f22:	89 bf       	out	0x39, r24	; 57
   
	//Initialize Counter
	TCNT0 = 0;
    1f24:	12 be       	out	0x32, r1	; 50
   
	//Initialize our variable
	count = 0;
    1f26:	10 92 ea 00 	sts	0x00EA, r1
	flag = 0;
    1f2a:	10 92 e9 00 	sts	0x00E9, r1
   
	//Set Port as output
	heartBeatDDR |= (1 << heartBeatPIN);
    1f2e:	a0 9a       	sbi	0x14, 0	; 20

	sei();
    1f30:	78 94       	sei
 }
    1f32:	08 95       	ret

00001f34 <__vector_11>:
 
//Interrupt Service Routine for TIMER0 Overflow Interrupt
ISR(TIMER0_OVF_vect)
{
    1f34:	1f 92       	push	r1
    1f36:	0f 92       	push	r0
    1f38:	0f b6       	in	r0, 0x3f	; 63
    1f3a:	0f 92       	push	r0
    1f3c:	11 24       	eor	r1, r1
    1f3e:	8f 93       	push	r24
	//This is the interrupt service routine for TIMER0 OVERFLOW Interrupt.
	//CPU automatically call this when TIMER0 overflows.

	//Increment our variable
	count++;
    1f40:	80 91 ea 00 	lds	r24, 0x00EA
    1f44:	8f 5f       	subi	r24, 0xFF	; 255
    1f46:	80 93 ea 00 	sts	0x00EA, r24
	if(count == 16)	//toggle in every 500ms
    1f4a:	80 91 ea 00 	lds	r24, 0x00EA
    1f4e:	80 31       	cpi	r24, 0x10	; 16
    1f50:	81 f4       	brne	.+32     	; 0x1f72 <__vector_11+0x3e>
	{
		count = 0;
    1f52:	10 92 ea 00 	sts	0x00EA, r1
		if (flag == 0)
    1f56:	80 91 e9 00 	lds	r24, 0x00E9
    1f5a:	88 23       	and	r24, r24
    1f5c:	29 f4       	brne	.+10     	; 0x1f68 <__vector_11+0x34>
		{
			heartBeatPORT |= (1 << heartBeatPIN);
    1f5e:	a8 9a       	sbi	0x15, 0	; 21
			flag = 1;
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	80 93 e9 00 	sts	0x00E9, r24
    1f66:	05 c0       	rjmp	.+10     	; 0x1f72 <__vector_11+0x3e>
		}
		else if (flag == 1)
    1f68:	81 30       	cpi	r24, 0x01	; 1
    1f6a:	19 f4       	brne	.+6      	; 0x1f72 <__vector_11+0x3e>
		{
			heartBeatPORT &= ~(1 << heartBeatPIN);
    1f6c:	a8 98       	cbi	0x15, 0	; 21
			flag = 0;
    1f6e:	10 92 e9 00 	sts	0x00E9, r1
		so in 1 sec there are 31 interrupts. Therefore counter is set to 0 
		every 1 sec.that means heartBeatPORT will toggled every 1 sec. 
		That means it is ON for 1 sec and OFF for 1 sec. So time period 
		is 2 sec and freq is 1/2 = 0.5Hz									*/
	/************************************************************************/
}//end of ISR
    1f72:	8f 91       	pop	r24
    1f74:	0f 90       	pop	r0
    1f76:	0f be       	out	0x3f, r0	; 63
    1f78:	0f 90       	pop	r0
    1f7a:	1f 90       	pop	r1
    1f7c:	18 95       	reti

00001f7e <Init_USART>:

#include "usart.h"

//Function to initialize the USART
void Init_USART(uint16_t ubrr){
	UCSRB =  (1 << RXEN) | (1 << TXEN);      // Enable receiver and transmitter              
    1f7e:	88 e1       	ldi	r24, 0x18	; 24
    1f80:	8a b9       	out	0x0a, r24	; 10
   // UCSRC = (1 << URSEL) | (3 << UCSZ0);     // Set frame format: 8-bit data, 1-stop bit
	UCSRC |= (1 << URSEL ) | (1 << UCSZ0 ) | (1 << UCSZ1 ); // Use 8- bit character sizes
    1f82:	80 b5       	in	r24, 0x20	; 32
    1f84:	86 68       	ori	r24, 0x86	; 134
    1f86:	80 bd       	out	0x20, r24	; 32
    // Set baud rate
	UBRRL = (uint8_t)BAUD_PRESCALE;          // Load lower 8-bits of the baud rate value into the low byte of the UBRR register
    1f88:	8d e4       	ldi	r24, 0x4D	; 77
    1f8a:	89 b9       	out	0x09, r24	; 9
	UBRRH = (uint8_t)(BAUD_PRESCALE >> 8);   // Load higher 8-bits of the baud rate value into the higher byte of the UBRR register                      
    1f8c:	10 bc       	out	0x20, r1	; 32
    //UCSRB |= (1 << RXCIE );                  // Enable the USART Recieve Complete interrupt ( USART_RXC )
    //sei ();                                  // Enable the Global Interrupt Enable flag so that interrupts can be processed
}
    1f8e:	08 95       	ret

00001f90 <USART_Send8BitData>:

//Function that Sends Frames with 5 to 8 Data Bit
void USART_Send8BitData(unsigned char data){
	while ( !( UCSRA & (1<<UDRE)) );        //Wait for empty transmit buffer
    1f90:	5d 9b       	sbis	0x0b, 5	; 11
    1f92:	fe cf       	rjmp	.-4      	; 0x1f90 <USART_Send8BitData>
	UDR = data;                             //Put data into buffer, sends the data
    1f94:	8c b9       	out	0x0c, r24	; 12
}
    1f96:	08 95       	ret

00001f98 <USART_Send9BitData>:

//Function that Sends Frames with 9 Data Bit
void USART_Send9BitData(unsigned int data){	
	while ( !( UCSRA & (1<<UDRE)) );       //Wait for empty transmit buffer
    1f98:	5d 9b       	sbis	0x0b, 5	; 11
    1f9a:	fe cf       	rjmp	.-4      	; 0x1f98 <USART_Send9BitData>
	UCSRB &= ~(1<<TXB8);                   //Copy 9th bit to TXB8
    1f9c:	50 98       	cbi	0x0a, 0	; 10
	if ( data & 0x0100 )
    1f9e:	90 fd       	sbrc	r25, 0
		UCSRB |= (1<<TXB8);	
    1fa0:	50 9a       	sbi	0x0a, 0	; 10
	UDR = data;                           //Put data into buffer, sends the data
    1fa2:	8c b9       	out	0x0c, r24	; 12
}
    1fa4:	08 95       	ret

00001fa6 <USART_Receive8BitData>:

//Function that Receives Frames with 5 to 8 Data Bits
unsigned char USART_Receive8BitData(void){	
	while ( !(UCSRA & (1<<RXC)) );       //Wait for data to be received	
    1fa6:	5f 9b       	sbis	0x0b, 7	; 11
    1fa8:	fe cf       	rjmp	.-4      	; 0x1fa6 <USART_Receive8BitData>
	return UDR;                          //Get and return received data from buffer
    1faa:	8c b1       	in	r24, 0x0c	; 12
}
    1fac:	08 95       	ret

00001fae <USART_Receive9BitData>:

//Function that Receives Frames with 9 Data Bits
unsigned int USART_Receive9BitData(void){
	unsigned char status, resh, resl;	
	while ( !(UCSRA & (1<<RXC)) );        //Wait for data to be received	
    1fae:	5f 9b       	sbis	0x0b, 7	; 11
    1fb0:	fe cf       	rjmp	.-4      	; 0x1fae <USART_Receive9BitData>
	//Get status and 9th bit, then data from buffer
	status = UCSRA;
    1fb2:	8b b1       	in	r24, 0x0b	; 11
	resh = UCSRB;
    1fb4:	2a b1       	in	r18, 0x0a	; 10
	resl = UDR;	
    1fb6:	3c b1       	in	r19, 0x0c	; 12
	//If error, return -1
	if ( status & ((1<<FE)|(1<<DOR)|(1<<PE)) )
    1fb8:	8c 71       	andi	r24, 0x1C	; 28
    1fba:	19 f0       	breq	.+6      	; 0x1fc2 <USART_Receive9BitData+0x14>
    1fbc:	2f ef       	ldi	r18, 0xFF	; 255
    1fbe:	3f ef       	ldi	r19, 0xFF	; 255
    1fc0:	08 c0       	rjmp	.+16     	; 0x1fd2 <USART_Receive9BitData+0x24>
		return -1;
	//Filter the 9th bit, then return
	resh = (resh >> 1) & 0x01;
    1fc2:	26 95       	lsr	r18
	return ((resh << 8) | resl);
    1fc4:	92 2f       	mov	r25, r18
    1fc6:	91 70       	andi	r25, 0x01	; 1
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	23 2f       	mov	r18, r19
    1fcc:	30 e0       	ldi	r19, 0x00	; 0
    1fce:	28 2b       	or	r18, r24
    1fd0:	39 2b       	or	r19, r25
}
    1fd2:	c9 01       	movw	r24, r18
    1fd4:	08 95       	ret

00001fd6 <USART_Flush>:

//Function that Flush the Receive Buffer
void USART_Flush(void){
    1fd6:	01 c0       	rjmp	.+2      	; 0x1fda <USART_Flush+0x4>
	unsigned char dummy;
	while ( UCSRA & (1<<RXC) ) 
	  dummy = UDR;
    1fd8:	8c b1       	in	r24, 0x0c	; 12
}

//Function that Flush the Receive Buffer
void USART_Flush(void){
	unsigned char dummy;
	while ( UCSRA & (1<<RXC) ) 
    1fda:	5f 99       	sbic	0x0b, 7	; 11
    1fdc:	fd cf       	rjmp	.-6      	; 0x1fd8 <USART_Flush+0x2>
	  dummy = UDR;
}
    1fde:	08 95       	ret

00001fe0 <USART_SendString>:

//Function that sends the string via USART
void USART_SendString(char *str) {
    1fe0:	fc 01       	movw	r30, r24
    1fe2:	04 c0       	rjmp	.+8      	; 0x1fec <USART_SendString+0xc>
    //sei ();                                  // Enable the Global Interrupt Enable flag so that interrupts can be processed
}

//Function that Sends Frames with 5 to 8 Data Bit
void USART_Send8BitData(unsigned char data){
	while ( !( UCSRA & (1<<UDRE)) );        //Wait for empty transmit buffer
    1fe4:	5d 9b       	sbis	0x0b, 5	; 11
    1fe6:	fe cf       	rjmp	.-4      	; 0x1fe4 <USART_SendString+0x4>

//Function that sends the string via USART
void USART_SendString(char *str) {
	int h;
	while(*str)         
		USART_Send8BitData(*str++);       // send message
    1fe8:	31 96       	adiw	r30, 0x01	; 1
}

//Function that Sends Frames with 5 to 8 Data Bit
void USART_Send8BitData(unsigned char data){
	while ( !( UCSRA & (1<<UDRE)) );        //Wait for empty transmit buffer
	UDR = data;                             //Put data into buffer, sends the data
    1fea:	8c b9       	out	0x0c, r24	; 12
}

//Function that sends the string via USART
void USART_SendString(char *str) {
	int h;
	while(*str)         
    1fec:	80 81       	ld	r24, Z
    1fee:	88 23       	and	r24, r24
    1ff0:	c9 f7       	brne	.-14     	; 0x1fe4 <USART_SendString+0x4>
		USART_Send8BitData(*str++);       // send message
	for(h=0;h<=200;h++); 
}
    1ff2:	08 95       	ret

00001ff4 <GSM_TrfBalance>:
//	USART_SendString(number);
//	USART_SendString(";\r");
}

// function to transfer balance
void GSM_TrfBalance(char *number,char *balance) {
    1ff4:	ef 92       	push	r14
    1ff6:	ff 92       	push	r15
    1ff8:	0f 93       	push	r16
    1ffa:	1f 93       	push	r17
    1ffc:	8c 01       	movw	r16, r24
    1ffe:	7b 01       	movw	r14, r22
	USART_SendString("AT+CMGF=0\r");
    2000:	85 e6       	ldi	r24, 0x65	; 101
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	_delay_ms(10000);
    2008:	80 e1       	ldi	r24, 0x10	; 16
    200a:	97 e2       	ldi	r25, 0x27	; 39
    200c:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>
	USART_SendString("AT+CUSD=1,\"*422*23456781*");
    2010:	80 e7       	ldi	r24, 0x70	; 112
    2012:	90 e0       	ldi	r25, 0x00	; 0
    2014:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString(number);
    2018:	c8 01       	movw	r24, r16
    201a:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString("*");
    201e:	8a e8       	ldi	r24, 0x8A	; 138
    2020:	90 e0       	ldi	r25, 0x00	; 0
    2022:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString(balance);
    2026:	c7 01       	movw	r24, r14
    2028:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString("00#\",15\r");
    202c:	8c e8       	ldi	r24, 0x8C	; 140
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>

}
    2034:	1f 91       	pop	r17
    2036:	0f 91       	pop	r16
    2038:	ff 90       	pop	r15
    203a:	ef 90       	pop	r14
    203c:	08 95       	ret

0000203e <GSM_SendMessage>:
	USART_SendString("AT+CMGF=1\r");
	_delay_ms(20);
}

//function to send message from SIM900 GSM Modem
void GSM_SendMessage(char *number,char *msg){
    203e:	ef 92       	push	r14
    2040:	ff 92       	push	r15
    2042:	0f 93       	push	r16
    2044:	1f 93       	push	r17
    2046:	8c 01       	movw	r16, r24
    2048:	7b 01       	movw	r14, r22
	USART_SendString("AT+CMGS=\"");
    204a:	85 e9       	ldi	r24, 0x95	; 149
    204c:	90 e0       	ldi	r25, 0x00	; 0
    204e:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString(number);
    2052:	c8 01       	movw	r24, r16
    2054:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString("\"\r");
    2058:	8f e9       	ldi	r24, 0x9F	; 159
    205a:	90 e0       	ldi	r25, 0x00	; 0
    205c:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	_delay_ms(6000);
    2060:	80 e7       	ldi	r24, 0x70	; 112
    2062:	97 e1       	ldi	r25, 0x17	; 23
    2064:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>

	USART_SendString("emBank verification code: ");
    2068:	82 ea       	ldi	r24, 0xA2	; 162
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString(msg);
    2070:	c7 01       	movw	r24, r14
    2072:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	USART_SendString("\x1A");
    2076:	8d eb       	ldi	r24, 0xBD	; 189
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>

//	USART_SendString("ATD");
//	USART_SendString(number);
//	USART_SendString(";\r");
}
    207e:	1f 91       	pop	r17
    2080:	0f 91       	pop	r16
    2082:	ff 90       	pop	r15
    2084:	ef 90       	pop	r14
    2086:	08 95       	ret

00002088 <Init_GSM>:

 #include "gsm.h"

//function to initialize SIM900 GSM Modem
void Init_GSM(){
	USART_SendString("AT+CMGF=1\r");
    2088:	8f eb       	ldi	r24, 0xBF	; 191
    208a:	90 e0       	ldi	r25, 0x00	; 0
    208c:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <USART_SendString>
	_delay_ms(20);
    2090:	84 e1       	ldi	r24, 0x14	; 20
    2092:	90 e0       	ldi	r25, 0x00	; 0
    2094:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <_delay_ms>
}
    2098:	08 95       	ret

0000209a <__eerd_block>:
    209a:	a0 e0       	ldi	r26, 0x00	; 0
    209c:	b0 e0       	ldi	r27, 0x00	; 0
    209e:	e3 e5       	ldi	r30, 0x53	; 83
    20a0:	f0 e1       	ldi	r31, 0x10	; 16
    20a2:	0c 94 73 10 	jmp	0x20e6	; 0x20e6 <__prologue_saves__+0x14>
    20a6:	7c 01       	movw	r14, r24
    20a8:	eb 01       	movw	r28, r22
    20aa:	8a 01       	movw	r16, r20
    20ac:	69 01       	movw	r12, r18
    20ae:	09 c0       	rjmp	.+18     	; 0x20c2 <__eerd_block+0x28>
    20b0:	ce 01       	movw	r24, r28
    20b2:	21 96       	adiw	r28, 0x01	; 1
    20b4:	f6 01       	movw	r30, r12
    20b6:	09 95       	icall
    20b8:	f7 01       	movw	r30, r14
    20ba:	81 93       	st	Z+, r24
    20bc:	7f 01       	movw	r14, r30
    20be:	01 50       	subi	r16, 0x01	; 1
    20c0:	10 40       	sbci	r17, 0x00	; 0
    20c2:	01 15       	cp	r16, r1
    20c4:	11 05       	cpc	r17, r1
    20c6:	a1 f7       	brne	.-24     	; 0x20b0 <__eerd_block+0x16>
    20c8:	cd b7       	in	r28, 0x3d	; 61
    20ca:	de b7       	in	r29, 0x3e	; 62
    20cc:	e8 e0       	ldi	r30, 0x08	; 8
    20ce:	0c 94 8f 10 	jmp	0x211e	; 0x211e <__epilogue_restores__+0x14>

000020d2 <__prologue_saves__>:
    20d2:	2f 92       	push	r2
    20d4:	3f 92       	push	r3
    20d6:	4f 92       	push	r4
    20d8:	5f 92       	push	r5
    20da:	6f 92       	push	r6
    20dc:	7f 92       	push	r7
    20de:	8f 92       	push	r8
    20e0:	9f 92       	push	r9
    20e2:	af 92       	push	r10
    20e4:	bf 92       	push	r11
    20e6:	cf 92       	push	r12
    20e8:	df 92       	push	r13
    20ea:	ef 92       	push	r14
    20ec:	ff 92       	push	r15
    20ee:	0f 93       	push	r16
    20f0:	1f 93       	push	r17
    20f2:	cf 93       	push	r28
    20f4:	df 93       	push	r29
    20f6:	cd b7       	in	r28, 0x3d	; 61
    20f8:	de b7       	in	r29, 0x3e	; 62
    20fa:	ca 1b       	sub	r28, r26
    20fc:	db 0b       	sbc	r29, r27
    20fe:	0f b6       	in	r0, 0x3f	; 63
    2100:	f8 94       	cli
    2102:	de bf       	out	0x3e, r29	; 62
    2104:	0f be       	out	0x3f, r0	; 63
    2106:	cd bf       	out	0x3d, r28	; 61
    2108:	09 94       	ijmp

0000210a <__epilogue_restores__>:
    210a:	2a 88       	ldd	r2, Y+18	; 0x12
    210c:	39 88       	ldd	r3, Y+17	; 0x11
    210e:	48 88       	ldd	r4, Y+16	; 0x10
    2110:	5f 84       	ldd	r5, Y+15	; 0x0f
    2112:	6e 84       	ldd	r6, Y+14	; 0x0e
    2114:	7d 84       	ldd	r7, Y+13	; 0x0d
    2116:	8c 84       	ldd	r8, Y+12	; 0x0c
    2118:	9b 84       	ldd	r9, Y+11	; 0x0b
    211a:	aa 84       	ldd	r10, Y+10	; 0x0a
    211c:	b9 84       	ldd	r11, Y+9	; 0x09
    211e:	c8 84       	ldd	r12, Y+8	; 0x08
    2120:	df 80       	ldd	r13, Y+7	; 0x07
    2122:	ee 80       	ldd	r14, Y+6	; 0x06
    2124:	fd 80       	ldd	r15, Y+5	; 0x05
    2126:	0c 81       	ldd	r16, Y+4	; 0x04
    2128:	1b 81       	ldd	r17, Y+3	; 0x03
    212a:	aa 81       	ldd	r26, Y+2	; 0x02
    212c:	b9 81       	ldd	r27, Y+1	; 0x01
    212e:	ce 0f       	add	r28, r30
    2130:	d1 1d       	adc	r29, r1
    2132:	0f b6       	in	r0, 0x3f	; 63
    2134:	f8 94       	cli
    2136:	de bf       	out	0x3e, r29	; 62
    2138:	0f be       	out	0x3f, r0	; 63
    213a:	cd bf       	out	0x3d, r28	; 61
    213c:	ed 01       	movw	r28, r26
    213e:	08 95       	ret

00002140 <_exit>:
    2140:	f8 94       	cli

00002142 <__stop_program>:
    2142:	ff cf       	rjmp	.-2      	; 0x2142 <__stop_program>
