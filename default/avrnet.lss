
avrnet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002148  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  00800060  00002148  000021fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000021  008000b0  008000b0  0000224c  2**0
                  ALLOC
  3 .eeprom       00000008  00810000  00810000  0000224c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000001a0  00000000  00000000  00002254  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000006a7  00000000  00000000  000023f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003e02  00000000  00000000  00002a9b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011fc  00000000  00000000  0000689d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001eed  00000000  00000000  00007a99  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000480  00000000  00000000  00009988  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000808  00000000  00000000  00009e08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001337  00000000  00000000  0000a610  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  0000b947  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 88 04 	jmp	0x910	; 0x910 <__ctors_end>
       4:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
       8:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
       c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      10:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      14:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      18:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      1c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      20:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      24:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      28:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      2c:	0c 94 a0 0f 	jmp	0x1f40	; 0x1f40 <__vector_11>
      30:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      34:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      38:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      3c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      40:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      44:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      48:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      4c:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>
      50:	0c 94 a5 04 	jmp	0x94a	; 0x94a <__bad_interrupt>

00000054 <__c.2460>:
      54:	3c 2f 66 6f 6f 74 65 72 3e 3c 2f 73 65 63 74 69     </footer></secti
      64:	6f 6e 3e 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c     on></body></html
      74:	3e 00                                               >.

00000076 <__c.2458>:
      76:	43 6f 70 79 72 69 67 68 74 20 26 63 6f 70 79 3b     Copyright &copy;
      86:	20 32 30 31 34 20 65 6d 42 61 6e 6b 2e 20 41 6c      2014 emBank. Al
      96:	6c 20 72 69 67 68 74 73 20 72 65 73 65 72 76 65     l rights reserve
      a6:	64 2e 00                                            d..

000000a9 <__c.2456>:
      a9:	3c 2f 64 69 76 3e 3c 2f 64 69 76 3e 3c 2f 73 65     </div></div></se
      b9:	63 74 69 6f 6e 3e 3c 2f 73 65 63 74 69 6f 6e 3e     ction></section>
      c9:	3c 66 6f 6f 74 65 72 3e 00                          <footer>.

000000d2 <__c.2454>:
      d2:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
      e2:	3e 3c 2f 64 69 76 3e 00                             ></div>.

000000ea <__c.2452>:
      ea:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
      fa:	6c 3d 31 26 66 61 6e 3d 31 3e 3c 69 6d 67 20 63     l=1&fan=1><img c
     10a:	6c 61 73 73 3d 73 77 69 74 63 68 20 73 72 63 3d     lass=switch src=
     11a:	68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 35     http://192.168.5
     12a:	33 2e 33 2f 61 2f 69 2f 73 2d 66 2e 70 6e 67 3e     3.3/a/i/s-f.png>
     13a:	3c 2f 61 3e 00                                      </a>.

0000013f <__c.2450>:
     13f:	3c 69 6d 67 20 63 6c 61 73 73 3d 22 66 61 6e 22     <img class="fan"
     14f:	20 73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e      src=http://192.
     15f:	31 36 38 2e 35 33 2e 33 2f 61 2f 69 2f 66 61 6e     168.53.3/a/i/fan
     16f:	2e 70 6e 67 20 2f 3e 00                             .png />.

00000177 <__c.2448>:
     177:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     187:	6c 3d 31 26 66 61 6e 3d 30 3e 3c 69 6d 67 20 63     l=1&fan=0><img c
     197:	6c 61 73 73 3d 73 77 69 74 63 68 20 73 72 63 3d     lass=switch src=
     1a7:	68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 35     http://192.168.5
     1b7:	33 2e 33 2f 61 2f 69 2f 73 2d 6e 2e 70 6e 67 3e     3.3/a/i/s-n.png>
     1c7:	3c 2f 61 3e 00                                      </a>.

000001cc <__c.2446>:
     1cc:	3c 69 6d 67 20 63 6c 61 73 73 3d 22 66 61 6e 20     <img class="fan 
     1dc:	72 6f 74 61 74 69 6e 67 22 20 73 72 63 3d 68 74     rotating" src=ht
     1ec:	74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 35 33 2e     tp://192.168.53.
     1fc:	33 2f 61 2f 69 2f 66 61 6e 2e 70 6e 67 20 2f 3e     3/a/i/fan.png />
	...

0000020d <__c.2444>:
     20d:	3c 2f 64 69 76 3e 3c 64 69 76 20 63 6c 61 73 73     </div><div class
     21d:	3d 63 49 74 65 6d 3e 00                             =cItem>.

00000225 <__c.2442>:
     225:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
     235:	3e 3c 2f 64 69 76 3e 00                             ></div>.

0000023d <__c.2440>:
     23d:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     24d:	6c 3d 31 26 62 75 6c 62 32 3d 31 3e 3c 69 6d 67     l=1&bulb2=1><img
     25d:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     26d:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     27d:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 66 2e 70 6e     .53.3/a/i/s-f.pn
     28d:	67 3e 3c 2f 61 3e 00                                g></a>.

00000294 <__c.2438>:
     294:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     2a4:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     2b4:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 66 2e     68.53.3/a/i/b-f.
     2c4:	70 6e 67 20 2f 3e 00                                png />.

000002cb <__c.2436>:
     2cb:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     2db:	6c 3d 31 26 62 75 6c 62 32 3d 30 3e 3c 69 6d 67     l=1&bulb2=0><img
     2eb:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     2fb:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     30b:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 6e 2e 70 6e     .53.3/a/i/s-n.pn
     31b:	67 3e 3c 2f 61 3e 00                                g></a>.

00000322 <__c.2434>:
     322:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     332:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     342:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 6e 2e     68.53.3/a/i/b-n.
     352:	70 6e 67 20 2f 3e 00                                png />.

00000359 <__c.2432>:
     359:	3c 2f 64 69 76 3e 3c 64 69 76 20 63 6c 61 73 73     </div><div class
     369:	3d 63 49 74 65 6d 3e 00                             =cItem>.

00000371 <__c.2430>:
     371:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
     381:	3e 3c 2f 64 69 76 3e 00                             ></div>.

00000389 <__c.2428>:
     389:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     399:	6c 3d 31 26 62 75 6c 62 31 3d 31 3e 3c 69 6d 67     l=1&bulb1=1><img
     3a9:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     3b9:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     3c9:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 66 2e 70 6e     .53.3/a/i/s-f.pn
     3d9:	67 3e 3c 2f 61 3e 00                                g></a>.

000003e0 <__c.2426>:
     3e0:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     3f0:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     400:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 66 2e     68.53.3/a/i/b-f.
     410:	70 6e 67 20 2f 3e 00                                png />.

00000417 <__c.2424>:
     417:	3c 61 20 68 72 65 66 3d 2f 3f 63 6f 6e 74 72 6f     <a href=/?contro
     427:	6c 3d 31 26 62 75 6c 62 31 3d 30 3e 3c 69 6d 67     l=1&bulb1=0><img
     437:	20 63 6c 61 73 73 3d 73 77 69 74 63 68 20 73 72      class=switch sr
     447:	63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38     c=http://192.168
     457:	2e 35 33 2e 33 2f 61 2f 69 2f 73 2d 6e 2e 70 6e     .53.3/a/i/s-n.pn
     467:	67 3e 3c 2f 61 3e 00                                g></a>.

0000046e <__c.2422>:
     46e:	3c 69 6d 67 20 63 6c 61 73 73 3d 62 75 6c 62 20     <img class=bulb 
     47e:	73 72 63 3d 68 74 74 70 3a 2f 2f 31 39 32 2e 31     src=http://192.1
     48e:	36 38 2e 35 33 2e 33 2f 61 2f 69 2f 62 2d 6e 2e     68.53.3/a/i/b-n.
     49e:	70 6e 67 20 2f 3e 00                                png />.

000004a5 <__c.2420>:
     4a5:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6f 6e 74 72     <div class=contr
     4b5:	6f 6c 3e 3c 64 69 76 20 63 6c 61 73 73 3d 63 49     ol><div class=cI
     4c5:	74 65 6d 3e 00                                      tem>.

000004ca <__c.2418>:
     4ca:	3c 73 65 63 74 69 6f 6e 20 69 64 3d 75 73 65 72     <section id=user
     4da:	2d 72 65 67 20 63 6c 61 73 73 3d 22 73 70 6c 61     -reg class="spla
     4ea:	73 68 2d 63 6f 6e 74 65 6e 74 20 72 65 67 69 73     sh-content regis
     4fa:	74 65 72 22 3e 00                                   ter">.

00000500 <__c.2416>:
     500:	3c 64 69 76 20 63 6c 61 73 73 3d 63 6c 65 61 72     <div class=clear
     510:	3e 3c 2f 64 69 76 3e 3c 2f 68 65 61 64 65 72 3e     ></div></header>
	...

00000521 <__c.2414>:
     521:	3c 2f 75 6c 3e 3c 2f 6e 61 76 3e 00                 </ul></nav>.

0000052d <__c.2412>:
     52d:	3c 6c 69 3e 3c 61 20 68 72 65 66 3d 68 74 74 70     <li><a href=http
     53d:	3a 2f 2f 31 39 32 2e 31 36 38 2e 35 33 2e 33 2f     ://192.168.53.3/
     54d:	3e 61 63 63 6f 75 6e 74 3c 2f 61 3e 3c 2f 6c 69     >account</a></li
     55d:	3e 00                                               >.

0000055f <__c.2410>:
     55f:	3c 6c 69 3e 3c 61 20 68 72 65 66 3d 68 74 74 70     <li><a href=http
     56f:	3a 2f 2f 31 39 32 2e 31 36 38 2e 35 33 2e 33 2f     ://192.168.53.3/
     57f:	3e 68 6f 6d 65 3c 2f 61 3e 3c 2f 6c 69 3e 00        >home</a></li>.

0000058e <__c.2408>:
     58e:	3c 6e 61 76 3e 3c 75 6c 3e 00                       <nav><ul>.

00000598 <__c.2406>:
     598:	3c 64 69 76 20 63 6c 61 73 73 3d 22 74 61 67 2d     <div class="tag-
     5a8:	6c 69 6e 65 22 3e 3c 73 70 61 6e 3e 45 6d 62 65     line"><span>Embe
     5b8:	64 64 65 64 20 53 65 72 76 65 72 20 62 61 73 65     dded Server base
     5c8:	64 20 54 61 6e 73 61 63 74 69 6f 6e 20 53 79 73     d Tansaction Sys
     5d8:	74 65 6d 3c 2f 73 70 61 6e 3e 3c 2f 64 69 76 3e     tem</span></div>
	...

000005e9 <__c.2404>:
     5e9:	3c 64 69 76 20 63 6c 61 73 73 3d 6c 6f 67 6f 3e     <div class=logo>
     5f9:	3c 61 20 68 72 65 66 3d 68 74 74 70 3a 2f 2f 31     <a href=http://1
     609:	39 32 2e 31 36 38 2e 35 33 2e 33 2f 20 3e 3c 2f     92.168.53.3/ ></
     619:	61 3e 3c 2f 64 69 76 3e 00                          a></div>.

00000622 <__c.2402>:
     622:	3c 68 65 61 64 65 72 3e 00                          <header>.

0000062b <__c.2400>:
     62b:	3c 73 65 63 74 69 6f 6e 20 63 6c 61 73 73 3d 22     <section class="
     63b:	68 6f 6d 65 22 3e 00                                home">.

00000642 <__c.2398>:
     642:	3c 73 65 63 74 69 6f 6e 20 69 64 3d 6c 61 79 6f     <section id=layo
     652:	75 74 3e 00                                         ut>.

00000656 <__c.2396>:
     656:	3c 2f 68 65 61 64 3e 3c 62 6f 64 79 3e 00           </head><body>.

00000664 <__c.2394>:
     664:	3c 6c 69 6e 6b 20 72 65 6c 3d 73 74 79 6c 65 73     <link rel=styles
     674:	68 65 65 74 20 74 79 70 65 3d 74 65 78 74 2f 63     heet type=text/c
     684:	73 73 20 68 72 65 66 3d 68 74 74 70 3a 2f 2f 31     ss href=http://1
     694:	39 32 2e 31 36 38 2e 35 33 2e 33 2f 61 2f 63 2f     92.168.53.3/a/c/
     6a4:	73 2e 63 73 73 20 2f 3e 00                          s.css />.

000006ad <__c.2392>:
     6ad:	3c 74 69 74 6c 65 3e 43 6f 6e 74 72 6f 6c 20 52     <title>Control R
     6bd:	6f 6f 6d 20 7c 7c 20 65 6d 42 61 6e 6b 3c 2f 74     oom || emBank</t
     6cd:	69 74 6c 65 3e 00                                   itle>.

000006d3 <__c.2390>:
     6d3:	3c 74 69 74 6c 65 3e 43 6f 6e 74 72 6f 6c 20 52     <title>Control R
     6e3:	6f 6f 6d 20 7c 7c 20 65 6d 42 61 6e 6b 3c 2f 74     oom || emBank</t
     6f3:	69 74 6c 65 3e 00                                   itle>.

000006f9 <__c.2388>:
     6f9:	3c 68 74 6d 6c 3e 3c 68 65 61 64 3e 00              <html><head>.

00000706 <__c.2386>:
     706:	3c 21 44 4f 43 54 59 50 45 20 68 74 6d 6c 3e 00     <!DOCTYPE html>.

00000716 <__c.2384>:
     716:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     726:	0a 41 63 63 65 73 73 2d 43 6f 6e 74 72 6f 6c 2d     .Access-Control-
     736:	41 6c 6c 6f 77 2d 4f 72 69 67 69 6e 3a 20 2a 0d     Allow-Origin: *.
     746:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     756:	65 78 74 2f 68 74 6d 6c 0d 0a 43 6f 6e 6e 65 63     ext/html..Connec
     766:	74 69 6f 6e 3a 20 6b 65 65 70 2d 61 6c 69 76 65     tion: keep-alive
     776:	0d 0a 0d 0a 00                                      .....

0000077b <__c.2375>:
     77b:	73 75 63 63 65 73 73 00                             success.

00000783 <__c.2373>:
     783:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     793:	0a 41 63 63 65 73 73 2d 43 6f 6e 74 72 6f 6c 2d     .Access-Control-
     7a3:	41 6c 6c 6f 77 2d 4f 72 69 67 69 6e 3a 20 2a 0d     Allow-Origin: *.
     7b3:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     7c3:	65 78 74 2f 68 74 6d 6c 0d 0a 43 6f 6e 6e 65 63     ext/html..Connec
     7d3:	74 69 6f 6e 3a 20 6b 65 65 70 2d 61 6c 69 76 65     tion: keep-alive
     7e3:	0d 0a 0d 0a 00                                      .....

000007e8 <__c.2365>:
     7e8:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     7f8:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     808:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00              ext/html.....

00000815 <__c.2349>:
     815:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 70     Connection: keep
     825:	2d 61 6c 69 76 65 0d 0a 0d 0a 00                    -alive.....

00000830 <__c.2347>:
     830:	4b 65 65 70 2d 41 6c 69 76 65 3a 20 33 30 30 0d     Keep-Alive: 300.
     840:	0a 00                                               ..

00000842 <__c.2345>:
     842:	41 63 63 65 70 74 3a 20 74 65 78 74 2f 68 74 6d     Accept: text/htm
     852:	6c 0d 0a 00                                         l...

00000856 <__c.2343>:
     856:	55 73 65 72 2d 41 67 65 6e 74 3a 20 41 56 52 20     User-Agent: AVR 
     866:	65 74 68 65 72 6e 65 74 0d 0a 00                    ethernet...

00000871 <__c.2341>:
     871:	48 6f 73 74 3a 20 31 30 2e 31 2e 31 2e 37 36 0d     Host: 10.1.1.76.
     881:	0a 00                                               ..

00000883 <__c.2339>:
     883:	20 48 54 54 50 2f 31 2e 30 0d 0a 00                  HTTP/1.0...

0000088f <__c.2337>:
     88f:	47 45 54 20 2f 61 76 72 6e 65 74 2f 73 61 76 65     GET /avrnet/save
     89f:	2e 70 68 70 3f 70 77 64 3d 73 65 63 72 65 74 26     .php?pwd=secret&
     8af:	74 65 6d 70 3d 00                                   temp=.

000008b5 <__c.2196>:
     8b5:	66 61 6e 00                                         fan.

000008b9 <__c.2194>:
     8b9:	62 75 6c 62 32 00                                   bulb2.

000008bf <__c.2192>:
     8bf:	62 75 6c 62 31 00                                   bulb1.

000008c5 <__c.2190>:
     8c5:	63 6f 6e 74 72 6f 6c 00                             control.

000008cd <__c.2188>:
     8cd:	63 68 65 63 6b 00                                   check.

000008d3 <__c.2185>:
     8d3:	61 6d 6d 6f 75 6e 74 00                             ammount.

000008db <__c.2183>:
     8db:	72 65 63 65 69 76 65 72 00                          receiver.

000008e4 <__c.2181>:
     8e4:	62 61 6c 5f 74 72 66 00                             bal_trf.

000008ec <__c.2179>:
     8ec:	73 65 63 43 6f 64 65 00                             secCode.

000008f4 <__c.2177>:
     8f4:	6d 6f 62 4e 75 6d 00                                mobNum.

000008fb <__c.2175>:
     8fb:	72 65 67 5f 73 65 6e 64 5f 6d 73 67 00              reg_send_msg.

00000908 <__c.2214>:
     908:	45 52 52 4f 52 0d 0a 00                             ERROR...

00000910 <__ctors_end>:
     910:	11 24       	eor	r1, r1
     912:	1f be       	out	0x3f, r1	; 63
     914:	cf e5       	ldi	r28, 0x5F	; 95
     916:	d8 e0       	ldi	r29, 0x08	; 8
     918:	de bf       	out	0x3e, r29	; 62
     91a:	cd bf       	out	0x3d, r28	; 61

0000091c <__do_copy_data>:
     91c:	10 e0       	ldi	r17, 0x00	; 0
     91e:	a0 e6       	ldi	r26, 0x60	; 96
     920:	b0 e0       	ldi	r27, 0x00	; 0
     922:	e8 e4       	ldi	r30, 0x48	; 72
     924:	f1 e2       	ldi	r31, 0x21	; 33
     926:	02 c0       	rjmp	.+4      	; 0x92c <.do_copy_data_start>

00000928 <.do_copy_data_loop>:
     928:	05 90       	lpm	r0, Z+
     92a:	0d 92       	st	X+, r0

0000092c <.do_copy_data_start>:
     92c:	a0 3b       	cpi	r26, 0xB0	; 176
     92e:	b1 07       	cpc	r27, r17
     930:	d9 f7       	brne	.-10     	; 0x928 <.do_copy_data_loop>

00000932 <__do_clear_bss>:
     932:	10 e0       	ldi	r17, 0x00	; 0
     934:	a0 eb       	ldi	r26, 0xB0	; 176
     936:	b0 e0       	ldi	r27, 0x00	; 0
     938:	01 c0       	rjmp	.+2      	; 0x93c <.do_clear_bss_start>

0000093a <.do_clear_bss_loop>:
     93a:	1d 92       	st	X+, r1

0000093c <.do_clear_bss_start>:
     93c:	a1 3d       	cpi	r26, 0xD1	; 209
     93e:	b1 07       	cpc	r27, r17
     940:	e1 f7       	brne	.-8      	; 0x93a <.do_clear_bss_loop>
     942:	0e 94 61 07 	call	0xec2	; 0xec2 <main>
     946:	0c 94 a2 10 	jmp	0x2144	; 0x2144 <_exit>

0000094a <__bad_interrupt>:
     94a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000094e <enc28j60ReadOp>:
//
//*******************************************************************************************
BYTE enc28j60ReadOp(BYTE op, BYTE address)
{
	// activate CS
	CSACTIVE;
     94e:	c4 98       	cbi	0x18, 4	; 24
	// issue read command
	SPDR = op | (address & ADDR_MASK);
     950:	96 2f       	mov	r25, r22
     952:	9f 71       	andi	r25, 0x1F	; 31
     954:	98 2b       	or	r25, r24
     956:	9f b9       	out	0x0f, r25	; 15
	waitspi();
     958:	77 9b       	sbis	0x0e, 7	; 14
     95a:	fe cf       	rjmp	.-4      	; 0x958 <enc28j60ReadOp+0xa>
	// read data
	SPDR = 0x00;
     95c:	1f b8       	out	0x0f, r1	; 15
	waitspi();
     95e:	77 9b       	sbis	0x0e, 7	; 14
     960:	fe cf       	rjmp	.-4      	; 0x95e <enc28j60ReadOp+0x10>
	// do dummy read if needed (for mac and mii, see datasheet page 29)
	if(address & 0x80)
     962:	67 ff       	sbrs	r22, 7
     964:	03 c0       	rjmp	.+6      	; 0x96c <enc28j60ReadOp+0x1e>
	{
		SPDR = 0x00;
     966:	1f b8       	out	0x0f, r1	; 15
		waitspi();
     968:	77 9b       	sbis	0x0e, 7	; 14
     96a:	fe cf       	rjmp	.-4      	; 0x968 <enc28j60ReadOp+0x1a>
	}
	// release CS
	CSPASSIVE;
     96c:	c4 9a       	sbi	0x18, 4	; 24
	return(SPDR);
     96e:	8f b1       	in	r24, 0x0f	; 15
}
     970:	08 95       	ret

00000972 <enc28j60WriteOp>:
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     972:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     974:	6f 71       	andi	r22, 0x1F	; 31
     976:	68 2b       	or	r22, r24
     978:	6f b9       	out	0x0f, r22	; 15
	waitspi();
     97a:	77 9b       	sbis	0x0e, 7	; 14
     97c:	fe cf       	rjmp	.-4      	; 0x97a <enc28j60WriteOp+0x8>
	// write data
	SPDR = data;
     97e:	4f b9       	out	0x0f, r20	; 15
	waitspi();
     980:	77 9b       	sbis	0x0e, 7	; 14
     982:	fe cf       	rjmp	.-4      	; 0x980 <enc28j60WriteOp+0xe>
	CSPASSIVE;
     984:	c4 9a       	sbi	0x18, 4	; 24
}
     986:	08 95       	ret

00000988 <enc28j60SetBank>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60SetBank(BYTE address)
{
     988:	48 2f       	mov	r20, r24
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
     98a:	28 2f       	mov	r18, r24
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	20 76       	andi	r18, 0x60	; 96
     990:	30 70       	andi	r19, 0x00	; 0
     992:	80 91 b0 00 	lds	r24, 0x00B0
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	28 17       	cp	r18, r24
     99a:	39 07       	cpc	r19, r25
     99c:	d9 f0       	breq	.+54     	; 0x9d4 <enc28j60SetBank+0x4c>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     99e:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     9a0:	8f eb       	ldi	r24, 0xBF	; 191
     9a2:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     9a4:	77 9b       	sbis	0x0e, 7	; 14
     9a6:	fe cf       	rjmp	.-4      	; 0x9a4 <enc28j60SetBank+0x1c>
	// write data
	SPDR = data;
     9a8:	83 e0       	ldi	r24, 0x03	; 3
     9aa:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     9ac:	77 9b       	sbis	0x0e, 7	; 14
     9ae:	fe cf       	rjmp	.-4      	; 0x9ac <enc28j60SetBank+0x24>
	CSPASSIVE;
     9b0:	c4 9a       	sbi	0x18, 4	; 24
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     9b2:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     9b4:	8f e9       	ldi	r24, 0x9F	; 159
     9b6:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     9b8:	77 9b       	sbis	0x0e, 7	; 14
     9ba:	fe cf       	rjmp	.-4      	; 0x9b8 <enc28j60SetBank+0x30>
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
     9bc:	85 e0       	ldi	r24, 0x05	; 5
     9be:	35 95       	asr	r19
     9c0:	27 95       	ror	r18
     9c2:	8a 95       	dec	r24
     9c4:	e1 f7       	brne	.-8      	; 0x9be <enc28j60SetBank+0x36>
	CSACTIVE;
	// issue write command
	SPDR = op | (address & ADDR_MASK);
	waitspi();
	// write data
	SPDR = data;
     9c6:	2f b9       	out	0x0f, r18	; 15
	waitspi();
     9c8:	77 9b       	sbis	0x0e, 7	; 14
     9ca:	fe cf       	rjmp	.-4      	; 0x9c8 <enc28j60SetBank+0x40>
	CSPASSIVE;
     9cc:	c4 9a       	sbi	0x18, 4	; 24
	if((address & BANK_MASK) != Enc28j60Bank)
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
		Enc28j60Bank = (address & BANK_MASK);
     9ce:	40 76       	andi	r20, 0x60	; 96
     9d0:	40 93 b0 00 	sts	0x00B0, r20
     9d4:	08 95       	ret

000009d6 <enc28j60Read>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
BYTE enc28j60Read(BYTE address)
{
     9d6:	1f 93       	push	r17
     9d8:	18 2f       	mov	r17, r24
	// select bank to read
	enc28j60SetBank(address);
     9da:	0e 94 c4 04 	call	0x988	; 0x988 <enc28j60SetBank>
	
	// do the read
	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
     9de:	80 e0       	ldi	r24, 0x00	; 0
     9e0:	61 2f       	mov	r22, r17
     9e2:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
}
     9e6:	1f 91       	pop	r17
     9e8:	08 95       	ret

000009ea <enc28j60Write>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60Write(BYTE address, BYTE data)
{
     9ea:	0f 93       	push	r16
     9ec:	1f 93       	push	r17
     9ee:	18 2f       	mov	r17, r24
     9f0:	06 2f       	mov	r16, r22
	// select bank to write
	enc28j60SetBank(address);
     9f2:	0e 94 c4 04 	call	0x988	; 0x988 <enc28j60SetBank>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     9f6:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     9f8:	1f 71       	andi	r17, 0x1F	; 31
     9fa:	10 64       	ori	r17, 0x40	; 64
     9fc:	1f b9       	out	0x0f, r17	; 15
	waitspi();
     9fe:	77 9b       	sbis	0x0e, 7	; 14
     a00:	fe cf       	rjmp	.-4      	; 0x9fe <enc28j60Write+0x14>
	// write data
	SPDR = data;
     a02:	0f b9       	out	0x0f, r16	; 15
	waitspi();
     a04:	77 9b       	sbis	0x0e, 7	; 14
     a06:	fe cf       	rjmp	.-4      	; 0xa04 <enc28j60Write+0x1a>
	CSPASSIVE;
     a08:	c4 9a       	sbi	0x18, 4	; 24
	// select bank to write
	enc28j60SetBank(address);

	// do the write
	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <enc28j60_read_phyreg>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
WORD enc28j60_read_phyreg(BYTE address)
{
     a10:	0f 93       	push	r16
     a12:	1f 93       	push	r17
     a14:	68 2f       	mov	r22, r24
	WORD data;
	
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
     a16:	84 ed       	ldi	r24, 0xD4	; 212
     a18:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
     a1c:	82 ed       	ldi	r24, 0xD2	; 210
     a1e:	61 e0       	ldi	r22, 0x01	; 1
     a20:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Loop to wait until the PHY register has been read through the MII
	// This requires 10.24us
	while( (enc28j60Read(MISTAT) & MISTAT_BUSY) );
     a24:	8a ee       	ldi	r24, 0xEA	; 234
     a26:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     a2a:	80 fd       	sbrc	r24, 0
     a2c:	fb cf       	rjmp	.-10     	; 0xa24 <enc28j60_read_phyreg+0x14>
	
	// Stop reading
	enc28j60Write(MICMD, MICMD_MIIRD);
     a2e:	82 ed       	ldi	r24, 0xD2	; 210
     a30:	61 e0       	ldi	r22, 0x01	; 1
     a32:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Obtain results and return
	data = enc28j60Read ( MIRDL );
     a36:	88 ed       	ldi	r24, 0xD8	; 216
     a38:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     a3c:	08 2f       	mov	r16, r24
     a3e:	10 e0       	ldi	r17, 0x00	; 0
	data |= enc28j60Read ( MIRDH );
     a40:	89 ed       	ldi	r24, 0xD9	; 217
     a42:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     a46:	28 2f       	mov	r18, r24
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	20 2b       	or	r18, r16
     a4c:	31 2b       	or	r19, r17

	return data;
}
     a4e:	c9 01       	movw	r24, r18
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	08 95       	ret

00000a56 <enc28j60getrev>:
// Description : read the revision of the chip.
//
//*******************************************************************************************
BYTE enc28j60getrev(void)
{
	return(enc28j60Read(EREVID));
     a56:	82 e7       	ldi	r24, 0x72	; 114
     a58:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
}
     a5c:	08 95       	ret

00000a5e <enc28j60_packet_send>:
// Function : enc28j60_packet_send
// Description : Send packet to network.
//
//*******************************************************************************************
void enc28j60_packet_send ( BYTE *buffer, WORD length )
{
     a5e:	0f 93       	push	r16
     a60:	1f 93       	push	r17
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	8c 01       	movw	r16, r24
     a68:	eb 01       	movw	r28, r22
	//Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, LOW(TXSTART_INIT) );
     a6a:	82 e0       	ldi	r24, 0x02	; 2
     a6c:	64 e2       	ldi	r22, 0x24	; 36
     a6e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EWRPTH, HIGH(TXSTART_INIT) );
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	6a e1       	ldi	r22, 0x1A	; 26
     a76:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, LOW((TXSTART_INIT+length)) );
     a7a:	ce 01       	movw	r24, r28
     a7c:	8c 5d       	subi	r24, 0xDC	; 220
     a7e:	68 2f       	mov	r22, r24
     a80:	86 e0       	ldi	r24, 0x06	; 6
     a82:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ETXNDH, HIGH((TXSTART_INIT+length)) );
     a86:	9e 01       	movw	r18, r28
     a88:	2c 5d       	subi	r18, 0xDC	; 220
     a8a:	35 4e       	sbci	r19, 0xE5	; 229
     a8c:	87 e0       	ldi	r24, 0x07	; 7
     a8e:	63 2f       	mov	r22, r19
     a90:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     a94:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     a96:	8a e7       	ldi	r24, 0x7A	; 122
     a98:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     a9a:	77 9b       	sbis	0x0e, 7	; 14
     a9c:	fe cf       	rjmp	.-4      	; 0xa9a <enc28j60_packet_send+0x3c>
	// write data
	SPDR = data;
     a9e:	1f b8       	out	0x0f, r1	; 15
	waitspi();
     aa0:	77 9b       	sbis	0x0e, 7	; 14
     aa2:	fe cf       	rjmp	.-4      	; 0xaa0 <enc28j60_packet_send+0x42>
	CSPASSIVE;
     aa4:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60Write(ETXNDH, HIGH((TXSTART_INIT+length)) );

	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);

	CSACTIVE;
     aa6:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
     aa8:	8a e7       	ldi	r24, 0x7A	; 122
     aaa:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     aac:	77 9b       	sbis	0x0e, 7	; 14
     aae:	fe cf       	rjmp	.-4      	; 0xaac <enc28j60_packet_send+0x4e>
     ab0:	08 c0       	rjmp	.+16     	; 0xac2 <enc28j60_packet_send+0x64>
	while(length)
	{
		length--;
		// write data
		SPDR = *buffer++;
     ab2:	f8 01       	movw	r30, r16
     ab4:	80 81       	ld	r24, Z
     ab6:	8f b9       	out	0x0f, r24	; 15
		waitspi();
     ab8:	77 9b       	sbis	0x0e, 7	; 14
     aba:	fe cf       	rjmp	.-4      	; 0xab8 <enc28j60_packet_send+0x5a>
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
	waitspi();
	while(length)
	{
		length--;
     abc:	21 97       	sbiw	r28, 0x01	; 1
		// write data
		SPDR = *buffer++;
     abe:	0f 5f       	subi	r16, 0xFF	; 255
     ac0:	1f 4f       	sbci	r17, 0xFF	; 255

	CSACTIVE;
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
	waitspi();
	while(length)
     ac2:	20 97       	sbiw	r28, 0x00	; 0
     ac4:	b1 f7       	brne	.-20     	; 0xab2 <enc28j60_packet_send+0x54>
		length--;
		// write data
		SPDR = *buffer++;
		waitspi();
	}
	CSPASSIVE;
     ac6:	c4 9a       	sbi	0x18, 4	; 24
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     ac8:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     aca:	8f e9       	ldi	r24, 0x9F	; 159
     acc:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     ace:	77 9b       	sbis	0x0e, 7	; 14
     ad0:	fe cf       	rjmp	.-4      	; 0xace <enc28j60_packet_send+0x70>
	// write data
	SPDR = data;
     ad2:	88 e0       	ldi	r24, 0x08	; 8
     ad4:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     ad6:	77 9b       	sbis	0x0e, 7	; 14
     ad8:	fe cf       	rjmp	.-4      	; 0xad6 <enc28j60_packet_send+0x78>
	CSPASSIVE;
     ada:	c4 9a       	sbi	0x18, 4	; 24
	
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);

	// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) )
     adc:	8c e1       	ldi	r24, 0x1C	; 28
     ade:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     ae2:	81 ff       	sbrs	r24, 1
     ae4:	0a c0       	rjmp	.+20     	; 0xafa <enc28j60_packet_send+0x9c>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     ae6:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     ae8:	8f eb       	ldi	r24, 0xBF	; 191
     aea:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     aec:	77 9b       	sbis	0x0e, 7	; 14
     aee:	fe cf       	rjmp	.-4      	; 0xaec <enc28j60_packet_send+0x8e>
	// write data
	SPDR = data;
     af0:	88 e0       	ldi	r24, 0x08	; 8
     af2:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     af4:	77 9b       	sbis	0x0e, 7	; 14
     af6:	fe cf       	rjmp	.-4      	; 0xaf4 <enc28j60_packet_send+0x96>
	CSPASSIVE;
     af8:	c4 9a       	sbi	0x18, 4	; 24
	// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) )
	{
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
	}
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	08 95       	ret

00000b04 <enc28j60_packet_receive>:
// Description : check received packet and return length of data
//
//*******************************************************************************************
//WORD data_length;
WORD enc28j60_packet_receive ( BYTE *rxtx_buffer, WORD max_length )
{
     b04:	cf 92       	push	r12
     b06:	df 92       	push	r13
     b08:	ef 92       	push	r14
     b0a:	ff 92       	push	r15
     b0c:	0f 93       	push	r16
     b0e:	1f 93       	push	r17
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	6c 01       	movw	r12, r24
     b16:	7b 01       	movw	r14, r22
	WORD_BYTES rx_status, data_length;
	
	// check if a packet has been received and buffered
	// if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
	// The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) == 0 )
     b18:	89 e3       	ldi	r24, 0x39	; 57
     b1a:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     b1e:	88 23       	and	r24, r24
     b20:	19 f4       	brne	.+6      	; 0xb28 <enc28j60_packet_receive+0x24>
     b22:	20 e0       	ldi	r18, 0x00	; 0
     b24:	30 e0       	ldi	r19, 0x00	; 0
     b26:	5f c0       	rjmp	.+190    	; 0xbe6 <enc28j60_packet_receive+0xe2>
	{
		return 0;
	}

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, next_packet_ptr.bytes[0]);
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	60 91 b1 00 	lds	r22, 0x00B1
     b2e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERDPTH, next_packet_ptr.bytes[1]);
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	60 91 b2 00 	lds	r22, 0x00B2
     b38:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// read the next packet pointer
	next_packet_ptr.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b3c:	8a e3       	ldi	r24, 0x3A	; 58
     b3e:	60 e0       	ldi	r22, 0x00	; 0
     b40:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b44:	80 93 b1 00 	sts	0x00B1, r24
	next_packet_ptr.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b48:	8a e3       	ldi	r24, 0x3A	; 58
     b4a:	60 e0       	ldi	r22, 0x00	; 0
     b4c:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b50:	08 2f       	mov	r16, r24
     b52:	80 93 b2 00 	sts	0x00B2, r24

	// read the packet length (see datasheet page 43)
	data_length.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b56:	8a e3       	ldi	r24, 0x3A	; 58
     b58:	60 e0       	ldi	r22, 0x00	; 0
     b5a:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b5e:	c8 2f       	mov	r28, r24
	data_length.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b60:	8a e3       	ldi	r24, 0x3A	; 58
     b62:	60 e0       	ldi	r22, 0x00	; 0
     b64:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b68:	d8 2f       	mov	r29, r24
	data_length.word -=4; //remove the CRC count
     b6a:	24 97       	sbiw	r28, 0x04	; 4
	
	// read the receive status (see datasheet page 43)
	rx_status.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b6c:	8a e3       	ldi	r24, 0x3A	; 58
     b6e:	60 e0       	ldi	r22, 0x00	; 0
     b70:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
     b74:	18 2f       	mov	r17, r24
	rx_status.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b76:	8a e3       	ldi	r24, 0x3A	; 58
     b78:	60 e0       	ldi	r22, 0x00	; 0
     b7a:	0e 94 a7 04 	call	0x94e	; 0x94e <enc28j60ReadOp>
	
	if ( data_length.word > (max_length-1) )
     b7e:	b7 01       	movw	r22, r14
     b80:	61 50       	subi	r22, 0x01	; 1
     b82:	70 40       	sbci	r23, 0x00	; 0
     b84:	6c 17       	cp	r22, r28
     b86:	7d 07       	cpc	r23, r29
     b88:	08 f4       	brcc	.+2      	; 0xb8c <enc28j60_packet_receive+0x88>
	{
		data_length.word = max_length-1;
     b8a:	eb 01       	movw	r28, r22
	}
	
	// check CRC and symbol errors (see datasheet page 44, table 7-3):
	// The ERXFCON.CRCEN is set by default. Normally we should not
	// need to check this.
	if ( (rx_status.word & 0x80)==0 )
     b8c:	17 fd       	sbrc	r17, 7
     b8e:	03 c0       	rjmp	.+6      	; 0xb96 <enc28j60_packet_receive+0x92>
	{
		// invalid
		data_length.word = 0;
     b90:	c0 e0       	ldi	r28, 0x00	; 0
     b92:	d0 e0       	ldi	r29, 0x00	; 0
     b94:	14 c0       	rjmp	.+40     	; 0xbbe <enc28j60_packet_receive+0xba>
	}
	else
	{
		// read data from rx buffer and save to rxtx_buffer
		rx_status.word = data_length.word;
     b96:	9e 01       	movw	r18, r28
		CSACTIVE;
     b98:	c4 98       	cbi	0x18, 4	; 24
		// issue read command
		SPDR = ENC28J60_READ_BUF_MEM;
     b9a:	8a e3       	ldi	r24, 0x3A	; 58
     b9c:	8f b9       	out	0x0f, r24	; 15
		waitspi();
     b9e:	77 9b       	sbis	0x0e, 7	; 14
     ba0:	fe cf       	rjmp	.-4      	; 0xb9e <enc28j60_packet_receive+0x9a>
     ba2:	09 c0       	rjmp	.+18     	; 0xbb6 <enc28j60_packet_receive+0xb2>
		while(rx_status.word)
		{
			rx_status.word--;
			SPDR = 0x00;
     ba4:	1f b8       	out	0x0f, r1	; 15
			waitspi();
     ba6:	77 9b       	sbis	0x0e, 7	; 14
     ba8:	fe cf       	rjmp	.-4      	; 0xba6 <enc28j60_packet_receive+0xa2>
			*rxtx_buffer++ = SPDR;
     baa:	8f b1       	in	r24, 0x0f	; 15
     bac:	f6 01       	movw	r30, r12
     bae:	81 93       	st	Z+, r24
     bb0:	6f 01       	movw	r12, r30
     bb2:	21 50       	subi	r18, 0x01	; 1
     bb4:	30 40       	sbci	r19, 0x00	; 0
		rx_status.word = data_length.word;
		CSACTIVE;
		// issue read command
		SPDR = ENC28J60_READ_BUF_MEM;
		waitspi();
		while(rx_status.word)
     bb6:	21 15       	cp	r18, r1
     bb8:	31 05       	cpc	r19, r1
     bba:	a1 f7       	brne	.-24     	; 0xba4 <enc28j60_packet_receive+0xa0>
			rx_status.word--;
			SPDR = 0x00;
			waitspi();
			*rxtx_buffer++ = SPDR;
		}
		CSPASSIVE;
     bbc:	c4 9a       	sbi	0x18, 4	; 24
	}
	
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, next_packet_ptr.bytes[0]);
     bbe:	8c e0       	ldi	r24, 0x0C	; 12
     bc0:	60 91 b1 00 	lds	r22, 0x00B1
     bc4:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXRDPTH, next_packet_ptr.bytes[1]);
     bc8:	8d e0       	ldi	r24, 0x0D	; 13
     bca:	60 2f       	mov	r22, r16
     bcc:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     bd0:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     bd2:	8e e9       	ldi	r24, 0x9E	; 158
     bd4:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     bd6:	77 9b       	sbis	0x0e, 7	; 14
     bd8:	fe cf       	rjmp	.-4      	; 0xbd6 <enc28j60_packet_receive+0xd2>
	// write data
	SPDR = data;
     bda:	80 e4       	ldi	r24, 0x40	; 64
     bdc:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     bde:	77 9b       	sbis	0x0e, 7	; 14
     be0:	fe cf       	rjmp	.-4      	; 0xbde <enc28j60_packet_receive+0xda>
	CSPASSIVE;
     be2:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60Write(ERXRDPTH, next_packet_ptr.bytes[1]);

	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);

	return( data_length.word );
     be4:	9e 01       	movw	r18, r28
}
     be6:	c9 01       	movw	r24, r18
     be8:	df 91       	pop	r29
     bea:	cf 91       	pop	r28
     bec:	1f 91       	pop	r17
     bee:	0f 91       	pop	r16
     bf0:	ff 90       	pop	r15
     bf2:	ef 90       	pop	r14
     bf4:	df 90       	pop	r13
     bf6:	cf 90       	pop	r12
     bf8:	08 95       	ret

00000bfa <enc28j60PhyWrite>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60PhyWrite(BYTE address, WORD_BYTES data)
{
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	98 2f       	mov	r25, r24
     c00:	16 2f       	mov	r17, r22
     c02:	07 2f       	mov	r16, r23
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
     c04:	84 ed       	ldi	r24, 0xD4	; 212
     c06:	69 2f       	mov	r22, r25
     c08:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// write the PHY data
	enc28j60Write(MIWRL, data.byte.low);
     c0c:	86 ed       	ldi	r24, 0xD6	; 214
     c0e:	61 2f       	mov	r22, r17
     c10:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MIWRH, data.byte.high);
     c14:	87 ed       	ldi	r24, 0xD7	; 215
     c16:	60 2f       	mov	r22, r16
     c18:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
     c1c:	04 c0       	rjmp	.+8      	; 0xc26 <enc28j60PhyWrite+0x2c>
	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY)
	{
		_delay_us(15);
     c1e:	8f e0       	ldi	r24, 0x0F	; 15
     c20:	90 e0       	ldi	r25, 0x00	; 0
     c22:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <_delay_us>
	enc28j60Write(MIREGADR, address);
	// write the PHY data
	enc28j60Write(MIWRL, data.byte.low);
	enc28j60Write(MIWRH, data.byte.high);
	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY)
     c26:	8a ee       	ldi	r24, 0xEA	; 234
     c28:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <enc28j60Read>
     c2c:	80 fd       	sbrc	r24, 0
     c2e:	f7 cf       	rjmp	.-18     	; 0xc1e <enc28j60PhyWrite+0x24>
	{
		_delay_us(15);
	}
}
     c30:	1f 91       	pop	r17
     c32:	0f 91       	pop	r16
     c34:	08 95       	ret

00000c36 <enc28j60_init>:
	//enc28j60_flag.rx_buffer_is_free = 1;
	_delay_ms(20);
}
*/
void enc28j60_init( BYTE *avr_mac)
{
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	ec 01       	movw	r28, r24
	// initialize I/O
	//DDRB |= _BV( DDB4 );
	//CSPASSIVE;

	// enable PB0, reset as output 
	ENC28J60_DDR |= _BV(ENC28J60_RESET_PIN_DDR);
     c3c:	8b 9a       	sbi	0x11, 3	; 17

	// enable PD2/INT0, as input
	ENC28J60_DDR &= ~_BV(ENC28J60_INT_PIN_DDR);
     c3e:	8a 98       	cbi	0x11, 2	; 17
	ENC28J60_PORT |= _BV(ENC28J60_INT_PIN);
     c40:	92 9a       	sbi	0x12, 2	; 18

	// set output to gnd, reset the ethernet chip
	ENC28J60_PORT &= ~_BV(ENC28J60_RESET_PIN);
     c42:	93 98       	cbi	0x12, 3	; 18
	_delay_ms(10);
     c44:	8a e0       	ldi	r24, 0x0A	; 10
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>

	// set output to Vcc, reset inactive
	ENC28J60_PORT |= _BV(ENC28J60_RESET_PIN);
     c4c:	93 9a       	sbi	0x12, 3	; 18
	_delay_ms(200);
     c4e:	88 ec       	ldi	r24, 0xC8	; 200
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>

    //	
	DDRB  |= _BV( DDB4 ) | _BV( DDB5 ) | _BV( DDB7 ); // mosi, sck, ss output
     c56:	87 b3       	in	r24, 0x17	; 23
     c58:	80 6b       	ori	r24, 0xB0	; 176
     c5a:	87 bb       	out	0x17, r24	; 23
	//DDRB &= ~_BV( DDB6 ); // MISO is input

	CSPASSIVE;
     c5c:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~(_BV( PB5 ) | _BV( PB7 ) );
     c5e:	88 b3       	in	r24, 0x18	; 24
     c60:	8f 75       	andi	r24, 0x5F	; 95
     c62:	88 bb       	out	0x18, r24	; 24
	//
	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = _BV( SPE ) | _BV( MSTR );
     c64:	80 e5       	ldi	r24, 0x50	; 80
     c66:	8d b9       	out	0x0d, r24	; 13
    SPSR |= _BV( SPI2X );
     c68:	70 9a       	sbi	0x0e, 0	; 14
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     c6a:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     c6c:	8f ef       	ldi	r24, 0xFF	; 255
     c6e:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     c70:	77 9b       	sbis	0x0e, 7	; 14
     c72:	fe cf       	rjmp	.-4      	; 0xc70 <enc28j60_init+0x3a>
	// write data
	SPDR = data;
     c74:	8f ef       	ldi	r24, 0xFF	; 255
     c76:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     c78:	77 9b       	sbis	0x0e, 7	; 14
     c7a:	fe cf       	rjmp	.-4      	; 0xc78 <enc28j60_init+0x42>
	CSPASSIVE;
     c7c:	c4 9a       	sbi	0x18, 4	; 24
    SPCR = _BV( SPE ) | _BV( MSTR );
    SPSR |= _BV( SPI2X );

	// perform system reset
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
	_delay_ms(50);
     c7e:	82 e3       	ldi	r24, 0x32	; 50
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>
	//while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	next_packet_ptr.word = RXSTART_INIT;
     c86:	10 92 b2 00 	sts	0x00B2, r1
     c8a:	10 92 b1 00 	sts	0x00B1, r1
    // Rx start
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
     c8e:	88 e0       	ldi	r24, 0x08	; 8
     c90:	60 e0       	ldi	r22, 0x00	; 0
     c92:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
     c96:	89 e0       	ldi	r24, 0x09	; 9
     c98:	60 e0       	ldi	r22, 0x00	; 0
     c9a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
     c9e:	8c e0       	ldi	r24, 0x0C	; 12
     ca0:	60 e0       	ldi	r22, 0x00	; 0
     ca2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
     ca6:	8d e0       	ldi	r24, 0x0D	; 13
     ca8:	60 e0       	ldi	r22, 0x00	; 0
     caa:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// RX end
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
     cae:	8a e0       	ldi	r24, 0x0A	; 10
     cb0:	63 e2       	ldi	r22, 0x23	; 35
     cb2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
     cb6:	8b e0       	ldi	r24, 0x0B	; 11
     cb8:	6a e1       	ldi	r22, 0x1A	; 26
     cba:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// TX start
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
     cbe:	84 e0       	ldi	r24, 0x04	; 4
     cc0:	64 e2       	ldi	r22, 0x24	; 36
     cc2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
     cc6:	85 e0       	ldi	r24, 0x05	; 5
     cc8:	6a e1       	ldi	r22, 0x1A	; 26
     cca:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	// TX end
	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
     cce:	86 e0       	ldi	r24, 0x06	; 6
     cd0:	60 e0       	ldi	r22, 0x00	; 0
     cd2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
     cd6:	87 e0       	ldi	r24, 0x07	; 7
     cd8:	60 e2       	ldi	r22, 0x20	; 32
     cda:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
     cde:	80 ec       	ldi	r24, 0xC0	; 192
     ce0:	6d e0       	ldi	r22, 0x0D	; 13
     ce2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// bring MAC out of reset
	//enc28j60Write(MACON2, 0x00);

	// enable automatic padding to 60bytes and CRC operations
	enc28j60Write(MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
     ce6:	82 ec       	ldi	r24, 0xC2	; 194
     ce8:	62 e3       	ldi	r22, 0x32	; 50
     cea:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// Allow infinite deferals if the medium is continuously busy 
    // (do not time out a transmission if the half duplex medium is 
    // completely saturated with other people's data)
    enc28j60Write(MACON4, MACON4_DEFER);
     cee:	83 ec       	ldi	r24, 0xC3	; 195
     cf0:	60 e4       	ldi	r22, 0x40	; 64
     cf2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter)
	// 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
	// collisions will occur less often with a larger number.
    enc28j60Write(MACLCON2, 63);
     cf6:	89 ec       	ldi	r24, 0xC9	; 201
     cf8:	6f e3       	ldi	r22, 0x3F	; 63
     cfa:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
	// later.
	enc28j60Write(MAIPGL, 0x12);
     cfe:	86 ec       	ldi	r24, 0xC6	; 198
     d00:	62 e1       	ldi	r22, 0x12	; 18
     d02:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
     d06:	87 ec       	ldi	r24, 0xC7	; 199
     d08:	6c e0       	ldi	r22, 0x0C	; 12
     d0a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// Set the maximum packet size which the controller will accept
    // Do not send packets longer than MAX_FRAMELEN:
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
     d0e:	8a ec       	ldi	r24, 0xCA	; 202
     d10:	6e ee       	ldi	r22, 0xEE	; 238
     d12:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
     d16:	8b ec       	ldi	r24, 0xCB	; 203
     d18:	65 e0       	ldi	r22, 0x05	; 5
     d1a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// do bank 3 stuff
    // write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	// ENC28J60 is big-endian avr gcc is little-endian
	enc28j60Write(MAADR5, avr_mac[0]);
     d1e:	84 ee       	ldi	r24, 0xE4	; 228
     d20:	68 81       	ld	r22, Y
     d22:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR4, avr_mac[1]);
     d26:	85 ee       	ldi	r24, 0xE5	; 229
     d28:	69 81       	ldd	r22, Y+1	; 0x01
     d2a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR3, avr_mac[2]);
     d2e:	82 ee       	ldi	r24, 0xE2	; 226
     d30:	6a 81       	ldd	r22, Y+2	; 0x02
     d32:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR2, avr_mac[3]);
     d36:	83 ee       	ldi	r24, 0xE3	; 227
     d38:	6b 81       	ldd	r22, Y+3	; 0x03
     d3a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR1, avr_mac[4]);
     d3e:	80 ee       	ldi	r24, 0xE0	; 224
     d40:	6c 81       	ldd	r22, Y+4	; 0x04
     d42:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(MAADR0, avr_mac[5]);
     d46:	81 ee       	ldi	r24, 0xE1	; 225
     d48:	6d 81       	ldd	r22, Y+5	; 0x05
     d4a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, (WORD_BYTES){PHCON2_HDLDIS});
     d4e:	80 e1       	ldi	r24, 0x10	; 16
     d50:	60 e0       	ldi	r22, 0x00	; 0
     d52:	71 e0       	ldi	r23, 0x01	; 1
     d54:	0e 94 fd 05 	call	0xbfa	; 0xbfa <enc28j60PhyWrite>
	
	// Magjack leds configuration, see enc28j60 datasheet, page 11
	// 0x476 is PHLCON LEDA=links status, LEDB=receive/transmit
	// enc28j60PhyWrite(PHLCON,0b0000 0100 0111 00 10);
	enc28j60PhyWrite(PHLCON,(WORD_BYTES){0x0472});
     d58:	84 e1       	ldi	r24, 0x14	; 20
     d5a:	62 e7       	ldi	r22, 0x72	; 114
     d5c:	74 e0       	ldi	r23, 0x04	; 4
     d5e:	0e 94 fd 05 	call	0xbfa	; 0xbfa <enc28j60PhyWrite>
	// Type     ETH.DST
	// ARP      BROADCAST
 	// 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
	// in binary these poitions are:11 0000 0011 1111
	// This is hex 303F->EPMM0=0x3f,EPMM1=0x30
	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
     d62:	88 e3       	ldi	r24, 0x38	; 56
     d64:	60 eb       	ldi	r22, 0xB0	; 176
     d66:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMM0, 0x3f);
     d6a:	88 e2       	ldi	r24, 0x28	; 40
     d6c:	6f e3       	ldi	r22, 0x3F	; 63
     d6e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMM1, 0x30);
     d72:	89 e2       	ldi	r24, 0x29	; 41
     d74:	60 e3       	ldi	r22, 0x30	; 48
     d76:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMCSL, 0xf9);
     d7a:	80 e3       	ldi	r24, 0x30	; 48
     d7c:	69 ef       	ldi	r22, 0xF9	; 249
     d7e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	enc28j60Write(EPMCSH, 0xf7);
     d82:	81 e3       	ldi	r24, 0x31	; 49
     d84:	67 ef       	ldi	r22, 0xF7	; 247
     d86:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>

	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
     d8a:	84 ec       	ldi	r24, 0xC4	; 196
     d8c:	62 e1       	ldi	r22, 0x12	; 18
     d8e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <enc28j60Write>
	
	// switch to bank 0
	enc28j60SetBank(ECON1);
     d92:	8f e1       	ldi	r24, 0x1F	; 31
     d94:	0e 94 c4 04 	call	0x988	; 0x988 <enc28j60SetBank>
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     d98:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     d9a:	8b e9       	ldi	r24, 0x9B	; 155
     d9c:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     d9e:	77 9b       	sbis	0x0e, 7	; 14
     da0:	fe cf       	rjmp	.-4      	; 0xd9e <enc28j60_init+0x168>
	// write data
	SPDR = data;
     da2:	80 ec       	ldi	r24, 0xC0	; 192
     da4:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     da6:	77 9b       	sbis	0x0e, 7	; 14
     da8:	fe cf       	rjmp	.-4      	; 0xda6 <enc28j60_init+0x170>
	CSPASSIVE;
     daa:	c4 9a       	sbi	0x18, 4	; 24
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
	CSACTIVE;
     dac:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
     dae:	8f e9       	ldi	r24, 0x9F	; 159
     db0:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     db2:	77 9b       	sbis	0x0e, 7	; 14
     db4:	fe cf       	rjmp	.-4      	; 0xdb2 <enc28j60_init+0x17c>
	// write data
	SPDR = data;
     db6:	84 e0       	ldi	r24, 0x04	; 4
     db8:	8f b9       	out	0x0f, r24	; 15
	waitspi();
     dba:	77 9b       	sbis	0x0e, 7	; 14
     dbc:	fe cf       	rjmp	.-4      	; 0xdba <enc28j60_init+0x184>
	CSPASSIVE;
     dbe:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);

	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);

	_delay_ms(20);
     dc0:	84 e1       	ldi	r24, 0x14	; 20
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>
}
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	08 95       	ret

00000dce <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     dce:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     dd0:	e1 99       	sbic	0x1c, 1	; 28
     dd2:	fe cf       	rjmp	.-4      	; 0xdd0 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     dd4:	3f bb       	out	0x1f, r19	; 31
     dd6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     dd8:	e0 9a       	sbi	0x1c, 0	; 28
     dda:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     ddc:	08 95       	ret

00000dde <server_process>:
// Function : server_process
// Description : Run web server and listen on port 80
//
//*****************************************************************************************
void server_process ( void )
{
     dde:	cf 92       	push	r12
     de0:	df 92       	push	r13
     de2:	ef 92       	push	r14
     de4:	ff 92       	push	r15
     de6:	0f 93       	push	r16
     de8:	1f 93       	push	r17
     dea:	df 93       	push	r29
     dec:	cf 93       	push	r28
     dee:	cd b7       	in	r28, 0x3d	; 61
     df0:	de b7       	in	r29, 0x3e	; 62
     df2:	c6 5e       	subi	r28, 0xE6	; 230
     df4:	d5 40       	sbci	r29, 0x05	; 5
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
	IP_ADDR client_ip;
	// you can change rx,tx buffer size in includes.h
	BYTE rxtx_buffer[MAX_RXTX_BUFFER];
	WORD plen;
	
	if ( flag1.bits.syn_is_sent )
     e00:	80 91 ba 00 	lds	r24, 0x00BA
     e04:	85 fd       	sbrc	r24, 5
     e06:	4d c0       	rjmp	.+154    	; 0xea2 <server_process+0xc4>
		return;
	// get new packet
	plen = enc28j60_packet_receive( (BYTE*)&rxtx_buffer, MAX_RXTX_BUFFER );
     e08:	ce 01       	movw	r24, r28
     e0a:	0b 96       	adiw	r24, 0x0b	; 11
     e0c:	6c ed       	ldi	r22, 0xDC	; 220
     e0e:	75 e0       	ldi	r23, 0x05	; 5
     e10:	0e 94 82 05 	call	0xb04	; 0xb04 <enc28j60_packet_receive>
	
	//plen will ne unequal to zero if there is a valid packet (without crc error)
	if(plen==0)
     e14:	89 2b       	or	r24, r25
     e16:	09 f4       	brne	.+2      	; 0xe1a <server_process+0x3c>
     e18:	44 c0       	rjmp	.+136    	; 0xea2 <server_process+0xc4>
		return;

	// copy client mac address from buffer to client mac variable
	memcpy ( (BYTE*)&client_mac, &rxtx_buffer[ ETH_SRC_MAC_P ], sizeof(MAC_ADDR) );
     e1a:	de 01       	movw	r26, r28
     e1c:	15 96       	adiw	r26, 0x05	; 5
     e1e:	fe 01       	movw	r30, r28
     e20:	71 96       	adiw	r30, 0x11	; 17
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	01 90       	ld	r0, Z+
     e26:	0d 92       	st	X+, r0
     e28:	81 50       	subi	r24, 0x01	; 1
     e2a:	e1 f7       	brne	.-8      	; 0xe24 <server_process+0x46>
	
	// check arp packet if match with avr ip let's send reply
	if ( arp_packet_is_arp( rxtx_buffer, (WORD_BYTES){ARP_OPCODE_REQUEST_V} ) )
     e2c:	9b e0       	ldi	r25, 0x0B	; 11
     e2e:	c9 2e       	mov	r12, r25
     e30:	d1 2c       	mov	r13, r1
     e32:	cc 0e       	add	r12, r28
     e34:	dd 1e       	adc	r13, r29
     e36:	c6 01       	movw	r24, r12
     e38:	61 e0       	ldi	r22, 0x01	; 1
     e3a:	70 e0       	ldi	r23, 0x00	; 0
     e3c:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <arp_packet_is_arp>
     e40:	88 23       	and	r24, r24
     e42:	39 f0       	breq	.+14     	; 0xe52 <server_process+0x74>
	{
		arp_send_reply ( (BYTE*)&rxtx_buffer, (BYTE*)&client_mac );
     e44:	c6 01       	movw	r24, r12
     e46:	be 01       	movw	r22, r28
     e48:	6b 5f       	subi	r22, 0xFB	; 251
     e4a:	7f 4f       	sbci	r23, 0xFF	; 255
     e4c:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <arp_send_reply>
     e50:	28 c0       	rjmp	.+80     	; 0xea2 <server_process+0xc4>
		return;
	}

	// get client ip address
	memcpy ( (BYTE*)&client_ip, &rxtx_buffer[ IP_SRC_IP_P ], sizeof(IP_ADDR) );
     e52:	8d a1       	ldd	r24, Y+37	; 0x25
     e54:	9e a1       	ldd	r25, Y+38	; 0x26
     e56:	af a1       	ldd	r26, Y+39	; 0x27
     e58:	b8 a5       	ldd	r27, Y+40	; 0x28
     e5a:	89 83       	std	Y+1, r24	; 0x01
     e5c:	9a 83       	std	Y+2, r25	; 0x02
     e5e:	ab 83       	std	Y+3, r26	; 0x03
     e60:	bc 83       	std	Y+4, r27	; 0x04
	// check ip packet send to avr or not?
	if ( ip_packet_is_ip ( (BYTE*)&rxtx_buffer ) == 0 )
     e62:	c6 01       	movw	r24, r12
     e64:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <ip_packet_is_ip>
     e68:	88 23       	and	r24, r24
     e6a:	d9 f0       	breq	.+54     	; 0xea2 <server_process+0xc4>
	{
		return;
	}

	// check ICMP packet, if packet is icmp packet let's send icmp echo reply
	if ( icmp_send_reply ( (BYTE*)&rxtx_buffer, (BYTE*)&client_mac, (BYTE*)&client_ip ) )
     e6c:	85 e0       	ldi	r24, 0x05	; 5
     e6e:	e8 2e       	mov	r14, r24
     e70:	f1 2c       	mov	r15, r1
     e72:	ec 0e       	add	r14, r28
     e74:	fd 1e       	adc	r15, r29
     e76:	c6 01       	movw	r24, r12
     e78:	b7 01       	movw	r22, r14
     e7a:	8e 01       	movw	r16, r28
     e7c:	0f 5f       	subi	r16, 0xFF	; 255
     e7e:	1f 4f       	sbci	r17, 0xFF	; 255
     e80:	a8 01       	movw	r20, r16
     e82:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <icmp_send_reply>
     e86:	88 23       	and	r24, r24
     e88:	61 f4       	brne	.+24     	; 0xea2 <server_process+0xc4>
	{
		return;
	}

	// check UDP packet
	if (udp_receive ( (BYTE *)&rxtx_buffer, (BYTE *)&client_mac, (BYTE *)&client_ip ))
     e8a:	c6 01       	movw	r24, r12
     e8c:	b7 01       	movw	r22, r14
     e8e:	a8 01       	movw	r20, r16
     e90:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <udp_receive>
     e94:	88 23       	and	r24, r24
     e96:	29 f4       	brne	.+10     	; 0xea2 <server_process+0xc4>
		return;
	}
	
	// tcp start here
	// start web server at port 80, see http.c
	http_webserver_process ( (BYTE*)rxtx_buffer, (BYTE*)&client_mac, (BYTE*)&client_ip );
     e98:	c6 01       	movw	r24, r12
     e9a:	b7 01       	movw	r22, r14
     e9c:	a8 01       	movw	r20, r16
     e9e:	0e 94 df 09 	call	0x13be	; 0x13be <http_webserver_process>
}
     ea2:	ca 51       	subi	r28, 0x1A	; 26
     ea4:	da 4f       	sbci	r29, 0xFA	; 250
     ea6:	0f b6       	in	r0, 0x3f	; 63
     ea8:	f8 94       	cli
     eaa:	de bf       	out	0x3e, r29	; 62
     eac:	0f be       	out	0x3f, r0	; 63
     eae:	cd bf       	out	0x3d, r28	; 61
     eb0:	cf 91       	pop	r28
     eb2:	df 91       	pop	r29
     eb4:	1f 91       	pop	r17
     eb6:	0f 91       	pop	r16
     eb8:	ff 90       	pop	r15
     eba:	ef 90       	pop	r14
     ebc:	df 90       	pop	r13
     ebe:	cf 90       	pop	r12
     ec0:	08 95       	ret

00000ec2 <main>:
//
//*****************************************************************************************
int main (void)
{
	// Initializing heartbeat of the system
	initTimer_heartBeat();
     ec2:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <initTimer_heartBeat>
	
	// Initializing USART
	Init_USART(BAUD_PRESCALE);
     ec6:	8d e4       	ldi	r24, 0x4D	; 77
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <Init_USART>

	// Initializing GSM Modem
	Init_GSM();
     ece:	0e 94 46 10 	call	0x208c	; 0x208c <Init_GSM>

	//USART_SendString("program initialized");

	// change your mac address here
	avr_mac.byte[0] = 'AA';
     ed2:	81 e4       	ldi	r24, 0x41	; 65
     ed4:	80 93 bb 00 	sts	0x00BB, r24
	avr_mac.byte[1] = 'FE';
     ed8:	85 e4       	ldi	r24, 0x45	; 69
     eda:	80 93 bc 00 	sts	0x00BC, r24
	avr_mac.byte[2] = '56';
     ede:	96 e3       	ldi	r25, 0x36	; 54
     ee0:	90 93 bd 00 	sts	0x00BD, r25
	avr_mac.byte[3] = 'D4';
     ee4:	84 e3       	ldi	r24, 0x34	; 52
     ee6:	80 93 be 00 	sts	0x00BE, r24
	avr_mac.byte[4] = '76';
     eea:	90 93 bf 00 	sts	0x00BF, r25
	avr_mac.byte[5] = '87';
     eee:	87 e3       	ldi	r24, 0x37	; 55
     ef0:	80 93 c0 00 	sts	0x00C0, r24

	// Changing the status of bulb and fan into initial states	
	CONTROL_DDR |= (1<<BULB_1_PIN);
     ef4:	a3 9a       	sbi	0x14, 3	; 20
	CONTROL_DDR |= (1<<BULB_2_PIN);
     ef6:	a4 9a       	sbi	0x14, 4	; 20
	CONTROL_DDR |= (1<<FAN_PIN);
     ef8:	a5 9a       	sbi	0x14, 5	; 20
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     efa:	85 ec       	ldi	r24, 0xC5	; 197
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	60 e0       	ldi	r22, 0x00	; 0
     f00:	70 e0       	ldi	r23, 0x00	; 0
     f02:	44 e0       	ldi	r20, 0x04	; 4
     f04:	50 e0       	ldi	r21, 0x00	; 0
     f06:	27 ee       	ldi	r18, 0xE7	; 231
     f08:	36 e0       	ldi	r19, 0x06	; 6
     f0a:	0e 94 4f 10 	call	0x209e	; 0x209e <__eerd_block>
	eeprom_read_block ( &avr_ip, ee_avr_ip, 4 );
	eeprom_read_block ( &server_ip, ee_server_ip, 4 );
	

	// initialiing enc28j60/Ehternet IC
	enc28j60_init( (BYTE*)&avr_mac );
     f0e:	81 ec       	ldi	r24, 0xC1	; 193
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	64 e0       	ldi	r22, 0x04	; 4
     f14:	70 e0       	ldi	r23, 0x00	; 0
     f16:	44 e0       	ldi	r20, 0x04	; 4
     f18:	50 e0       	ldi	r21, 0x00	; 0
     f1a:	27 ee       	ldi	r18, 0xE7	; 231
     f1c:	36 e0       	ldi	r19, 0x06	; 6
     f1e:	0e 94 4f 10 	call	0x209e	; 0x209e <__eerd_block>
     f22:	8b eb       	ldi	r24, 0xBB	; 187
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	0e 94 1b 06 	call	0xc36	; 0xc36 <enc28j60_init>

	// sending message
	GSM_SendMessage('9849057718', 'Test Message from GSM Server.');
     f2a:	88 e3       	ldi	r24, 0x38	; 56
     f2c:	91 e3       	ldi	r25, 0x31	; 49
     f2e:	6e e2       	ldi	r22, 0x2E	; 46
     f30:	72 e7       	ldi	r23, 0x72	; 114
     f32:	0e 94 25 10 	call	0x204a	; 0x204a <GSM_SendMessage>
	// loop forever
	// Infinite looping for continuous process
	for(;;)
	{
		// server process response for arp, icmp, http
		server_process ();
     f36:	0e 94 ef 06 	call	0xdde	; 0xdde <server_process>
     f3a:	fd cf       	rjmp	.-6      	; 0xf36 <main+0x74>

00000f3c <http_get_ip>:
// 10.1.1.1 (ascii), http_get_ip function convert ip address in ascii to binary and stored
// in BYTE *dest
//
//********************************************************************************************
unsigned char http_get_ip ( unsigned char *buf, BYTE *dest )
{
     f3c:	dc 01       	movw	r26, r24
     f3e:	40 e0       	ldi	r20, 0x00	; 0
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	21 e0       	ldi	r18, 0x01	; 1

		if ( ch >= '0' && ch <= '9' )
		{
			ch = ch - '0';
			temp = (temp * digit) + ch;
			digit *= 10;
     f44:	5a e0       	ldi	r21, 0x0A	; 10
	digit = 1;
	temp = 0;

	while ( 1 )
	{
		ch = *buf++;
     f46:	9d 91       	ld	r25, X+

		if ( ch >= '0' && ch <= '9' )
     f48:	39 2f       	mov	r19, r25
     f4a:	30 53       	subi	r19, 0x30	; 48
     f4c:	3a 30       	cpi	r19, 0x0A	; 10
     f4e:	40 f4       	brcc	.+16     	; 0xf60 <http_get_ip+0x24>
		{
			ch = ch - '0';
			temp = (temp * digit) + ch;
     f50:	24 9f       	mul	r18, r20
     f52:	40 2d       	mov	r20, r0
     f54:	11 24       	eor	r1, r1
     f56:	43 0f       	add	r20, r19
			digit *= 10;
     f58:	25 9f       	mul	r18, r21
     f5a:	20 2d       	mov	r18, r0
     f5c:	11 24       	eor	r1, r1
     f5e:	0d c0       	rjmp	.+26     	; 0xf7a <http_get_ip+0x3e>
		}
		else if ( ch == '.' || ch == '\0' )
     f60:	9e 32       	cpi	r25, 0x2E	; 46
     f62:	21 f0       	breq	.+8      	; 0xf6c <http_get_ip+0x30>
     f64:	99 23       	and	r25, r25
     f66:	11 f0       	breq	.+4      	; 0xf6c <http_get_ip+0x30>
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	08 95       	ret
		{
			dest[ i ] = temp;
     f6c:	fb 01       	movw	r30, r22
     f6e:	e8 0f       	add	r30, r24
     f70:	f1 1d       	adc	r31, r1
     f72:	40 83       	st	Z, r20
			i++;
     f74:	8f 5f       	subi	r24, 0xFF	; 255
     f76:	40 e0       	ldi	r20, 0x00	; 0
     f78:	21 e0       	ldi	r18, 0x01	; 1
		}
		else
		{
			return 0;
		}
		if ( i == 4 )
     f7a:	84 30       	cpi	r24, 0x04	; 4
     f7c:	21 f7       	brne	.-56     	; 0xf46 <http_get_ip+0xa>
			return i;
	}
}
     f7e:	08 95       	ret

00000f80 <hex2int>:
// Function : hex2int
// Description : convert a single hex digit character to its integer value
//
//********************************************************************************************
unsigned char hex2int(char c)
{
     f80:	98 2f       	mov	r25, r24
	if (c >= '0' && c <='9')
     f82:	80 53       	subi	r24, 0x30	; 48
     f84:	8a 30       	cpi	r24, 0x0A	; 10
     f86:	68 f0       	brcs	.+26     	; 0xfa2 <hex2int+0x22>
		return((unsigned char)c - '0');

	if (c >= 'a' && c <='f')
     f88:	81 53       	subi	r24, 0x31	; 49
     f8a:	86 30       	cpi	r24, 0x06	; 6
     f8c:	10 f4       	brcc	.+4      	; 0xf92 <hex2int+0x12>
		return((unsigned char)c - 'a' + 10);
     f8e:	86 5f       	subi	r24, 0xF6	; 246
     f90:	08 95       	ret
	
	if (c >= 'A' && c <='F')
     f92:	89 2f       	mov	r24, r25
     f94:	81 54       	subi	r24, 0x41	; 65
     f96:	86 30       	cpi	r24, 0x06	; 6
     f98:	10 f0       	brcs	.+4      	; 0xf9e <hex2int+0x1e>
     f9a:	80 e0       	ldi	r24, 0x00	; 0
     f9c:	08 95       	ret
		return((unsigned char)c - 'A' + 10);
     f9e:	89 2f       	mov	r24, r25
     fa0:	87 53       	subi	r24, 0x37	; 55

	return 0;
}
     fa2:	08 95       	ret

00000fa4 <urldecode>:
// Function : urldecode
// Description : decode a url string e.g "hello%20joe" or "hello+joe" becomes "hello joe"
//
//********************************************************************************************
void urldecode(unsigned char *urlbuf)
{
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	fc 01       	movw	r30, r24
     faa:	ec 01       	movw	r28, r24
     fac:	37 c0       	rjmp	.+110    	; 0x101c <urldecode+0x78>
	unsigned char *dst;

	dst=urlbuf;
	while ((c = *urlbuf))
	{
		if (c == '+') c = ' ';
     fae:	8b 32       	cpi	r24, 0x2B	; 43
     fb0:	11 f4       	brne	.+4      	; 0xfb6 <urldecode+0x12>
     fb2:	80 e2       	ldi	r24, 0x20	; 32
     fb4:	31 c0       	rjmp	.+98     	; 0x1018 <urldecode+0x74>
		if (c == '%')
     fb6:	85 32       	cpi	r24, 0x25	; 37
     fb8:	79 f5       	brne	.+94     	; 0x1018 <urldecode+0x74>
		{
			urlbuf++;
     fba:	df 01       	movw	r26, r30
     fbc:	11 96       	adiw	r26, 0x01	; 1
			c = *urlbuf;
     fbe:	91 81       	ldd	r25, Z+1	; 0x01
			urlbuf++;
     fc0:	fd 01       	movw	r30, r26
     fc2:	31 96       	adiw	r30, 0x01	; 1
// Description : convert a single hex digit character to its integer value
//
//********************************************************************************************
unsigned char hex2int(char c)
{
	if (c >= '0' && c <='9')
     fc4:	39 2f       	mov	r19, r25
     fc6:	30 53       	subi	r19, 0x30	; 48
     fc8:	3a 30       	cpi	r19, 0x0A	; 10
     fca:	70 f0       	brcs	.+28     	; 0xfe8 <urldecode+0x44>
		return((unsigned char)c - '0');

	if (c >= 'a' && c <='f')
     fcc:	89 2f       	mov	r24, r25
     fce:	81 56       	subi	r24, 0x61	; 97
     fd0:	86 30       	cpi	r24, 0x06	; 6
     fd2:	10 f4       	brcc	.+4      	; 0xfd8 <urldecode+0x34>
		return((unsigned char)c - 'a' + 10);
     fd4:	37 52       	subi	r19, 0x27	; 39
     fd6:	08 c0       	rjmp	.+16     	; 0xfe8 <urldecode+0x44>
	
	if (c >= 'A' && c <='F')
     fd8:	89 2f       	mov	r24, r25
     fda:	81 54       	subi	r24, 0x41	; 65
     fdc:	86 30       	cpi	r24, 0x06	; 6
     fde:	10 f0       	brcs	.+4      	; 0xfe4 <urldecode+0x40>
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	02 c0       	rjmp	.+4      	; 0xfe8 <urldecode+0x44>
		return((unsigned char)c - 'A' + 10);
     fe4:	39 2f       	mov	r19, r25
     fe6:	37 53       	subi	r19, 0x37	; 55
		if (c == '%')
		{
			urlbuf++;
			c = *urlbuf;
			urlbuf++;
			c = (hex2int(c) << 4) | hex2int(*urlbuf);
     fe8:	11 96       	adiw	r26, 0x01	; 1
     fea:	2c 91       	ld	r18, X
// Description : convert a single hex digit character to its integer value
//
//********************************************************************************************
unsigned char hex2int(char c)
{
	if (c >= '0' && c <='9')
     fec:	92 2f       	mov	r25, r18
     fee:	90 53       	subi	r25, 0x30	; 48
     ff0:	9a 30       	cpi	r25, 0x0A	; 10
     ff2:	70 f0       	brcs	.+28     	; 0x1010 <urldecode+0x6c>
		return((unsigned char)c - '0');

	if (c >= 'a' && c <='f')
     ff4:	82 2f       	mov	r24, r18
     ff6:	81 56       	subi	r24, 0x61	; 97
     ff8:	86 30       	cpi	r24, 0x06	; 6
     ffa:	10 f4       	brcc	.+4      	; 0x1000 <urldecode+0x5c>
		return((unsigned char)c - 'a' + 10);
     ffc:	97 52       	subi	r25, 0x27	; 39
     ffe:	08 c0       	rjmp	.+16     	; 0x1010 <urldecode+0x6c>
	
	if (c >= 'A' && c <='F')
    1000:	82 2f       	mov	r24, r18
    1002:	81 54       	subi	r24, 0x41	; 65
    1004:	86 30       	cpi	r24, 0x06	; 6
    1006:	10 f0       	brcs	.+4      	; 0x100c <urldecode+0x68>
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	02 c0       	rjmp	.+4      	; 0x1010 <urldecode+0x6c>
		return((unsigned char)c - 'A' + 10);
    100c:	92 2f       	mov	r25, r18
    100e:	97 53       	subi	r25, 0x37	; 55
		if (c == '%')
		{
			urlbuf++;
			c = *urlbuf;
			urlbuf++;
			c = (hex2int(c) << 4) | hex2int(*urlbuf);
    1010:	83 2f       	mov	r24, r19
    1012:	82 95       	swap	r24
    1014:	80 7f       	andi	r24, 0xF0	; 240
    1016:	89 2b       	or	r24, r25
		}
		*dst = c;
    1018:	89 93       	st	Y+, r24
		dst++;
		urlbuf++;
    101a:	31 96       	adiw	r30, 0x01	; 1
{
	unsigned char c;
	unsigned char *dst;

	dst=urlbuf;
	while ((c = *urlbuf))
    101c:	80 81       	ld	r24, Z
    101e:	88 23       	and	r24, r24
    1020:	31 f6       	brne	.-116    	; 0xfae <urldecode+0xa>
		}
		*dst = c;
		dst++;
		urlbuf++;
	}
	*dst = '\0';
    1022:	18 82       	st	Y, r1
}
    1024:	df 91       	pop	r29
    1026:	cf 91       	pop	r28
    1028:	08 95       	ret

0000102a <http_control>:
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nContent-Type: text/html\r\nConnection: keep-alive\r\n\r\n"), 0 );
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("success"), dlen );
	return (dlen);
}

WORD http_control( BYTE *rxtx_buffer ) {
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	ec 01       	movw	r28, r24
	WORD dlen;
	
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nContent-Type: text/html\r\nConnection: keep-alive\r\n\r\n"), 0 );
    1030:	66 e1       	ldi	r22, 0x16	; 22
    1032:	77 e0       	ldi	r23, 0x07	; 7
    1034:	40 e0       	ldi	r20, 0x00	; 0
    1036:	50 e0       	ldi	r21, 0x00	; 0
    1038:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    103c:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<!DOCTYPE html>"), dlen );
    103e:	ce 01       	movw	r24, r28
    1040:	66 e0       	ldi	r22, 0x06	; 6
    1042:	77 e0       	ldi	r23, 0x07	; 7
    1044:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1048:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<html><head>"), dlen );
    104a:	ce 01       	movw	r24, r28
    104c:	69 ef       	ldi	r22, 0xF9	; 249
    104e:	76 e0       	ldi	r23, 0x06	; 6
    1050:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1054:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<title>Control Room || emBank</title>"), dlen );
    1056:	ce 01       	movw	r24, r28
    1058:	63 ed       	ldi	r22, 0xD3	; 211
    105a:	76 e0       	ldi	r23, 0x06	; 6
    105c:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1060:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<title>Control Room || emBank</title>"), dlen );
    1062:	ce 01       	movw	r24, r28
    1064:	6d ea       	ldi	r22, 0xAD	; 173
    1066:	76 e0       	ldi	r23, 0x06	; 6
    1068:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    106c:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<link rel=stylesheet type=text/css href=http://192.168.53.3/a/c/s.css />"), dlen );
    106e:	ce 01       	movw	r24, r28
    1070:	64 e6       	ldi	r22, 0x64	; 100
    1072:	76 e0       	ldi	r23, 0x06	; 6
    1074:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1078:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</head><body>"), dlen );
    107a:	ce 01       	movw	r24, r28
    107c:	66 e5       	ldi	r22, 0x56	; 86
    107e:	76 e0       	ldi	r23, 0x06	; 6
    1080:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1084:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<section id=layout>"), dlen );
    1086:	ce 01       	movw	r24, r28
    1088:	62 e4       	ldi	r22, 0x42	; 66
    108a:	76 e0       	ldi	r23, 0x06	; 6
    108c:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1090:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<section class=\"home\">"), dlen );
    1092:	ce 01       	movw	r24, r28
    1094:	6b e2       	ldi	r22, 0x2B	; 43
    1096:	76 e0       	ldi	r23, 0x06	; 6
    1098:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    109c:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<header>"), dlen );
    109e:	ce 01       	movw	r24, r28
    10a0:	62 e2       	ldi	r22, 0x22	; 34
    10a2:	76 e0       	ldi	r23, 0x06	; 6
    10a4:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10a8:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=logo><a href=http://192.168.53.3/ ></a></div>"), dlen );
    10aa:	ce 01       	movw	r24, r28
    10ac:	69 ee       	ldi	r22, 0xE9	; 233
    10ae:	75 e0       	ldi	r23, 0x05	; 5
    10b0:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10b4:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=\"tag-line\"><span>Embedded Server based Tansaction System</span></div>"), dlen );
    10b6:	ce 01       	movw	r24, r28
    10b8:	68 e9       	ldi	r22, 0x98	; 152
    10ba:	75 e0       	ldi	r23, 0x05	; 5
    10bc:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10c0:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<nav><ul>"), dlen );
    10c2:	ce 01       	movw	r24, r28
    10c4:	6e e8       	ldi	r22, 0x8E	; 142
    10c6:	75 e0       	ldi	r23, 0x05	; 5
    10c8:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10cc:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<li><a href=http://192.168.53.3/>home</a></li>"), dlen );
    10ce:	ce 01       	movw	r24, r28
    10d0:	6f e5       	ldi	r22, 0x5F	; 95
    10d2:	75 e0       	ldi	r23, 0x05	; 5
    10d4:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10d8:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<li><a href=http://192.168.53.3/>account</a></li>"), dlen );
    10da:	ce 01       	movw	r24, r28
    10dc:	6d e2       	ldi	r22, 0x2D	; 45
    10de:	75 e0       	ldi	r23, 0x05	; 5
    10e0:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10e4:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</ul></nav>"), dlen );
    10e6:	ce 01       	movw	r24, r28
    10e8:	61 e2       	ldi	r22, 0x21	; 33
    10ea:	75 e0       	ldi	r23, 0x05	; 5
    10ec:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10f0:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div></header>"), dlen );
    10f2:	ce 01       	movw	r24, r28
    10f4:	60 e0       	ldi	r22, 0x00	; 0
    10f6:	75 e0       	ldi	r23, 0x05	; 5
    10f8:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    10fc:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<section id=user-reg class=\"splash-content register\">"), dlen );
    10fe:	ce 01       	movw	r24, r28
    1100:	6a ec       	ldi	r22, 0xCA	; 202
    1102:	74 e0       	ldi	r23, 0x04	; 4
    1104:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1108:	ac 01       	movw	r20, r24
	
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=control><div class=cItem>"), dlen );
    110a:	ce 01       	movw	r24, r28
    110c:	65 ea       	ldi	r22, 0xA5	; 165
    110e:	74 e0       	ldi	r23, 0x04	; 4
    1110:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1114:	ac 01       	movw	r20, r24

	if(bulb_1 == 1) {
    1116:	80 91 b3 00 	lds	r24, 0x00B3
    111a:	90 91 b4 00 	lds	r25, 0x00B4
    111e:	81 30       	cpi	r24, 0x01	; 1
    1120:	91 05       	cpc	r25, r1
    1122:	51 f4       	brne	.+20     	; 0x1138 <http_control+0x10e>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-n.png />"), dlen );
    1124:	ce 01       	movw	r24, r28
    1126:	6e e6       	ldi	r22, 0x6E	; 110
    1128:	74 e0       	ldi	r23, 0x04	; 4
    112a:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    112e:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb1=0><img class=switch src=http://192.168.53.3/a/i/s-n.png></a>"), dlen );
    1130:	ce 01       	movw	r24, r28
    1132:	67 e1       	ldi	r22, 0x17	; 23
    1134:	74 e0       	ldi	r23, 0x04	; 4
    1136:	0b c0       	rjmp	.+22     	; 0x114e <http_control+0x124>
	} else if(bulb_1 == 0) {
    1138:	89 2b       	or	r24, r25
    113a:	61 f4       	brne	.+24     	; 0x1154 <http_control+0x12a>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-f.png />"), dlen );
    113c:	ce 01       	movw	r24, r28
    113e:	60 ee       	ldi	r22, 0xE0	; 224
    1140:	73 e0       	ldi	r23, 0x03	; 3
    1142:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1146:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb1=1><img class=switch src=http://192.168.53.3/a/i/s-f.png></a>"), dlen );
    1148:	ce 01       	movw	r24, r28
    114a:	69 e8       	ldi	r22, 0x89	; 137
    114c:	73 e0       	ldi	r23, 0x03	; 3
    114e:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1152:	ac 01       	movw	r20, r24
	}

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div>"), dlen );
    1154:	ce 01       	movw	r24, r28
    1156:	61 e7       	ldi	r22, 0x71	; 113
    1158:	73 e0       	ldi	r23, 0x03	; 3
    115a:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    115e:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</div><div class=cItem>"), dlen );
    1160:	ce 01       	movw	r24, r28
    1162:	69 e5       	ldi	r22, 0x59	; 89
    1164:	73 e0       	ldi	r23, 0x03	; 3
    1166:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    116a:	ac 01       	movw	r20, r24

	if(bulb_2 == 1) {
    116c:	80 91 b5 00 	lds	r24, 0x00B5
    1170:	90 91 b6 00 	lds	r25, 0x00B6
    1174:	81 30       	cpi	r24, 0x01	; 1
    1176:	91 05       	cpc	r25, r1
    1178:	51 f4       	brne	.+20     	; 0x118e <http_control+0x164>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-n.png />"), dlen );
    117a:	ce 01       	movw	r24, r28
    117c:	62 e2       	ldi	r22, 0x22	; 34
    117e:	73 e0       	ldi	r23, 0x03	; 3
    1180:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1184:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb2=0><img class=switch src=http://192.168.53.3/a/i/s-n.png></a>"), dlen );
    1186:	ce 01       	movw	r24, r28
    1188:	6b ec       	ldi	r22, 0xCB	; 203
    118a:	72 e0       	ldi	r23, 0x02	; 2
    118c:	0b c0       	rjmp	.+22     	; 0x11a4 <http_control+0x17a>
	} else if(bulb_2 == 0) {
    118e:	89 2b       	or	r24, r25
    1190:	61 f4       	brne	.+24     	; 0x11aa <http_control+0x180>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=bulb src=http://192.168.53.3/a/i/b-f.png />"), dlen );
    1192:	ce 01       	movw	r24, r28
    1194:	64 e9       	ldi	r22, 0x94	; 148
    1196:	72 e0       	ldi	r23, 0x02	; 2
    1198:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    119c:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&bulb2=1><img class=switch src=http://192.168.53.3/a/i/s-f.png></a>"), dlen );
    119e:	ce 01       	movw	r24, r28
    11a0:	6d e3       	ldi	r22, 0x3D	; 61
    11a2:	72 e0       	ldi	r23, 0x02	; 2
    11a4:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    11a8:	ac 01       	movw	r20, r24
	}

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div>"), dlen );
    11aa:	ce 01       	movw	r24, r28
    11ac:	65 e2       	ldi	r22, 0x25	; 37
    11ae:	72 e0       	ldi	r23, 0x02	; 2
    11b0:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    11b4:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</div><div class=cItem>"), dlen );
    11b6:	ce 01       	movw	r24, r28
    11b8:	6d e0       	ldi	r22, 0x0D	; 13
    11ba:	72 e0       	ldi	r23, 0x02	; 2
    11bc:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    11c0:	ac 01       	movw	r20, r24

	if(fan == 1) {
    11c2:	80 91 b7 00 	lds	r24, 0x00B7
    11c6:	90 91 b8 00 	lds	r25, 0x00B8
    11ca:	81 30       	cpi	r24, 0x01	; 1
    11cc:	91 05       	cpc	r25, r1
    11ce:	51 f4       	brne	.+20     	; 0x11e4 <http_control+0x1ba>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=\"fan rotating\" src=http://192.168.53.3/a/i/fan.png />"), dlen );
    11d0:	ce 01       	movw	r24, r28
    11d2:	6c ec       	ldi	r22, 0xCC	; 204
    11d4:	71 e0       	ldi	r23, 0x01	; 1
    11d6:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    11da:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&fan=0><img class=switch src=http://192.168.53.3/a/i/s-n.png></a>"), dlen );
    11dc:	ce 01       	movw	r24, r28
    11de:	67 e7       	ldi	r22, 0x77	; 119
    11e0:	71 e0       	ldi	r23, 0x01	; 1
    11e2:	0b c0       	rjmp	.+22     	; 0x11fa <http_control+0x1d0>
	} else if(fan == 0) {
    11e4:	89 2b       	or	r24, r25
    11e6:	61 f4       	brne	.+24     	; 0x1200 <http_control+0x1d6>
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<img class=\"fan\" src=http://192.168.53.3/a/i/fan.png />"), dlen );
    11e8:	ce 01       	movw	r24, r28
    11ea:	6f e3       	ldi	r22, 0x3F	; 63
    11ec:	71 e0       	ldi	r23, 0x01	; 1
    11ee:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    11f2:	ac 01       	movw	r20, r24
		dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<a href=/?control=1&fan=1><img class=switch src=http://192.168.53.3/a/i/s-f.png></a>"), dlen );
    11f4:	ce 01       	movw	r24, r28
    11f6:	6a ee       	ldi	r22, 0xEA	; 234
    11f8:	70 e0       	ldi	r23, 0x00	; 0
    11fa:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    11fe:	ac 01       	movw	r20, r24
	}

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("<div class=clear></div>"), dlen );
    1200:	ce 01       	movw	r24, r28
    1202:	62 ed       	ldi	r22, 0xD2	; 210
    1204:	70 e0       	ldi	r23, 0x00	; 0
    1206:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    120a:	ac 01       	movw	r20, r24

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</div></div></section></section><footer>"), dlen );
    120c:	ce 01       	movw	r24, r28
    120e:	69 ea       	ldi	r22, 0xA9	; 169
    1210:	70 e0       	ldi	r23, 0x00	; 0
    1212:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1216:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("Copyright &copy; 2014 emBank. All rights reserved."), dlen );
    1218:	ce 01       	movw	r24, r28
    121a:	66 e7       	ldi	r22, 0x76	; 118
    121c:	70 e0       	ldi	r23, 0x00	; 0
    121e:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1222:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("</footer></section></body></html>"), dlen );
    1224:	ce 01       	movw	r24, r28
    1226:	64 e5       	ldi	r22, 0x54	; 84
    1228:	70 e0       	ldi	r23, 0x00	; 0
    122a:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>

	return (dlen);
}
    122e:	df 91       	pop	r29
    1230:	cf 91       	pop	r28
    1232:	08 95       	ret

00001234 <http_test>:
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR ( "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n" ), 0 );
	
	return (dlen);
}

WORD http_test( BYTE *rxtx_buffer ) {
    1234:	0f 93       	push	r16
    1236:	1f 93       	push	r17
    1238:	8c 01       	movw	r16, r24
	WORD dlen;
	
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nContent-Type: text/html\r\nConnection: keep-alive\r\n\r\n"), 0 );
    123a:	63 e8       	ldi	r22, 0x83	; 131
    123c:	77 e0       	ldi	r23, 0x07	; 7
    123e:	40 e0       	ldi	r20, 0x00	; 0
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1246:	ac 01       	movw	r20, r24
	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR("success"), dlen );
    1248:	c8 01       	movw	r24, r16
    124a:	6b e7       	ldi	r22, 0x7B	; 123
    124c:	77 e0       	ldi	r23, 0x07	; 7
    124e:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
	return (dlen);
}
    1252:	1f 91       	pop	r17
    1254:	0f 91       	pop	r16
    1256:	08 95       	ret

00001258 <http_home>:
WORD http_home( BYTE *rxtx_buffer )
{
	WORD dlen;
	BYTE generic_buf[64];

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR ( "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n" ), 0 );
    1258:	68 ee       	ldi	r22, 0xE8	; 232
    125a:	77 e0       	ldi	r23, 0x07	; 7
    125c:	40 e0       	ldi	r20, 0x00	; 0
    125e:	50 e0       	ldi	r21, 0x00	; 0
    1260:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
	
	return (dlen);
}
    1264:	08 95       	ret

00001266 <http_put_request>:
// Description : put http request to tx buffer contain 2-variables pwd and temp.
// webserver receive pwd, temp and save to text file by PHP script on webserver.
//
//*****************************************************************************************
WORD http_put_request ( BYTE *rxtx_buffer )
{
    1266:	0f 93       	push	r16
    1268:	1f 93       	push	r17
    126a:	df 93       	push	r29
    126c:	cf 93       	push	r28
    126e:	cd b7       	in	r28, 0x3d	; 61
    1270:	de b7       	in	r29, 0x3e	; 62
    1272:	c0 54       	subi	r28, 0x40	; 64
    1274:	d0 40       	sbci	r29, 0x00	; 0
    1276:	0f b6       	in	r0, 0x3f	; 63
    1278:	f8 94       	cli
    127a:	de bf       	out	0x3e, r29	; 62
    127c:	0f be       	out	0x3f, r0	; 63
    127e:	cd bf       	out	0x3d, r28	; 61
    1280:	8c 01       	movw	r16, r24
	BYTE temp_value;
	WORD dlength;
	BYTE generic_buf[64];
	

	generic_buf[ 2 ] = '\0';
    1282:	1b 82       	std	Y+3, r1	; 0x03

	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "GET /avrnet/save.php?pwd=secret&temp=" ), 0 );
    1284:	6f e8       	ldi	r22, 0x8F	; 143
    1286:	78 e0       	ldi	r23, 0x08	; 8
    1288:	40 e0       	ldi	r20, 0x00	; 0
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    1290:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data ( rxtx_buffer, (BYTE *)generic_buf, dlength );
    1292:	c8 01       	movw	r24, r16
    1294:	be 01       	movw	r22, r28
    1296:	6f 5f       	subi	r22, 0xFF	; 255
    1298:	7f 4f       	sbci	r23, 0xFF	; 255
    129a:	0e 94 c6 0c 	call	0x198c	; 0x198c <tcp_puts_data>
    129e:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( " HTTP/1.0\r\n" ), dlength );
    12a0:	c8 01       	movw	r24, r16
    12a2:	63 e8       	ldi	r22, 0x83	; 131
    12a4:	78 e0       	ldi	r23, 0x08	; 8
    12a6:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    12aa:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Host: 10.1.1.76\r\n" ), dlength );
    12ac:	c8 01       	movw	r24, r16
    12ae:	61 e7       	ldi	r22, 0x71	; 113
    12b0:	78 e0       	ldi	r23, 0x08	; 8
    12b2:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    12b6:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "User-Agent: AVR ethernet\r\n" ), dlength );
    12b8:	c8 01       	movw	r24, r16
    12ba:	66 e5       	ldi	r22, 0x56	; 86
    12bc:	78 e0       	ldi	r23, 0x08	; 8
    12be:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    12c2:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Accept: text/html\r\n" ), dlength );
    12c4:	c8 01       	movw	r24, r16
    12c6:	62 e4       	ldi	r22, 0x42	; 66
    12c8:	78 e0       	ldi	r23, 0x08	; 8
    12ca:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    12ce:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Keep-Alive: 300\r\n" ), dlength );
    12d0:	c8 01       	movw	r24, r16
    12d2:	60 e3       	ldi	r22, 0x30	; 48
    12d4:	78 e0       	ldi	r23, 0x08	; 8
    12d6:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    12da:	ac 01       	movw	r20, r24
	dlength = tcp_puts_data_p ( rxtx_buffer, PSTR ( "Connection: keep-alive\r\n\r\n" ), dlength );
    12dc:	c8 01       	movw	r24, r16
    12de:	65 e1       	ldi	r22, 0x15	; 21
    12e0:	78 e0       	ldi	r23, 0x08	; 8
    12e2:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>

	return dlength;
}
    12e6:	c0 5c       	subi	r28, 0xC0	; 192
    12e8:	df 4f       	sbci	r29, 0xFF	; 255
    12ea:	0f b6       	in	r0, 0x3f	; 63
    12ec:	f8 94       	cli
    12ee:	de bf       	out	0x3e, r29	; 62
    12f0:	0f be       	out	0x3f, r0	; 63
    12f2:	cd bf       	out	0x3d, r28	; 61
    12f4:	cf 91       	pop	r28
    12f6:	df 91       	pop	r29
    12f8:	1f 91       	pop	r17
    12fa:	0f 91       	pop	r16
    12fc:	08 95       	ret

000012fe <http_get_variable>:
//		when you call http_get_variable with val_key="pwd", then function stored "123456"
//		to dest buffer.
//
//********************************************************************************************
BYTE http_get_variable ( BYTE *rxtx_buffer, WORD dlength, PGM_P val_key, BYTE *dest )
{
    12fe:	cf 92       	push	r12
    1300:	df 92       	push	r13
    1302:	ef 92       	push	r14
    1304:	ff 92       	push	r15
    1306:	0f 93       	push	r16
    1308:	1f 93       	push	r17
    130a:	cf 93       	push	r28
    130c:	df 93       	push	r29
    130e:	ec 01       	movw	r28, r24
    1310:	8b 01       	movw	r16, r22
    1312:	6a 01       	movw	r12, r20
    1314:	79 01       	movw	r14, r18
	BYTE match=0, temp;

	key = val_key;
	
	// get data position
	data_p = tcp_get_hlength( rxtx_buffer ) + sizeof(ETH_HEADER) + sizeof(IP_HEADER);
    1316:	0e 94 ac 0c 	call	0x1958	; 0x1958 <tcp_get_hlength>
    131a:	28 2f       	mov	r18, r24
    131c:	30 e0       	ldi	r19, 0x00	; 0
    131e:	2e 5d       	subi	r18, 0xDE	; 222
    1320:	3f 4f       	sbci	r19, 0xFF	; 255
    1322:	fe 01       	movw	r30, r28
    1324:	e2 0f       	add	r30, r18
    1326:	f3 1f       	adc	r31, r19
    1328:	05 c0       	rjmp	.+10     	; 0x1334 <http_get_variable+0x36>

	// Find '?' in rx buffer, if found '?' in rx buffer then let's find variable key (val_key)
	for ( ; data_p<dlength; data_p++ )
	{
		if ( rxtx_buffer [ data_p ] == '?' )
    132a:	81 91       	ld	r24, Z+
    132c:	8f 33       	cpi	r24, 0x3F	; 63
    132e:	29 f0       	breq	.+10     	; 0x133a <http_get_variable+0x3c>
	
	// get data position
	data_p = tcp_get_hlength( rxtx_buffer ) + sizeof(ETH_HEADER) + sizeof(IP_HEADER);

	// Find '?' in rx buffer, if found '?' in rx buffer then let's find variable key (val_key)
	for ( ; data_p<dlength; data_p++ )
    1330:	2f 5f       	subi	r18, 0xFF	; 255
    1332:	3f 4f       	sbci	r19, 0xFF	; 255
    1334:	20 17       	cp	r18, r16
    1336:	31 07       	cpc	r19, r17
    1338:	c0 f3       	brcs	.-16     	; 0x132a <http_get_variable+0x2c>
	{
		if ( rxtx_buffer [ data_p ] == '?' )
			break;
	}
	// not found '?' in buffer
	if ( data_p == dlength )
    133a:	20 17       	cp	r18, r16
    133c:	31 07       	cpc	r19, r17
    133e:	a9 f1       	breq	.+106    	; 0x13aa <http_get_variable+0xac>
    1340:	de 01       	movw	r26, r28
    1342:	a2 0f       	add	r26, r18
    1344:	b3 1f       	adc	r27, r19
    1346:	f6 01       	movw	r30, r12
    1348:	80 e0       	ldi	r24, 0x00	; 0
    134a:	15 c0       	rjmp	.+42     	; 0x1376 <http_get_variable+0x78>
		return 0;
	
	// find variable key in buffer 
	for ( ; data_p<dlength; data_p++ )
	{
		temp = pgm_read_byte ( key );
    134c:	44 91       	lpm	r20, Z+

		// end of variable keyword
		if ( rxtx_buffer [ data_p ] == '=' && match != 0 )
    134e:	9c 91       	ld	r25, X
    1350:	9d 33       	cpi	r25, 0x3D	; 61
    1352:	39 f4       	brne	.+14     	; 0x1362 <http_get_variable+0x64>
    1354:	88 23       	and	r24, r24
    1356:	29 f0       	breq	.+10     	; 0x1362 <http_get_variable+0x64>
		{
			if ( temp == '\0' )
    1358:	44 23       	and	r20, r20
    135a:	19 f4       	brne	.+6      	; 0x1362 <http_get_variable+0x64>
			{
				data_p++;
    135c:	2f 5f       	subi	r18, 0xFF	; 255
    135e:	3f 4f       	sbci	r19, 0xFF	; 255
    1360:	0f c0       	rjmp	.+30     	; 0x1380 <http_get_variable+0x82>
				break;
			}
		}
		// variable keyword match with rx buffer
		if ( rxtx_buffer [ data_p ] == temp )
    1362:	94 17       	cp	r25, r20
    1364:	19 f0       	breq	.+6      	; 0x136c <http_get_variable+0x6e>
    1366:	f6 01       	movw	r30, r12
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	02 c0       	rjmp	.+4      	; 0x1370 <http_get_variable+0x72>
		{
			key++;
    136c:	31 96       	adiw	r30, 0x01	; 1
			match++;
    136e:	8f 5f       	subi	r24, 0xFF	; 255
	// not found '?' in buffer
	if ( data_p == dlength )
		return 0;
	
	// find variable key in buffer 
	for ( ; data_p<dlength; data_p++ )
    1370:	2f 5f       	subi	r18, 0xFF	; 255
    1372:	3f 4f       	sbci	r19, 0xFF	; 255
    1374:	11 96       	adiw	r26, 0x01	; 1
    1376:	20 17       	cp	r18, r16
    1378:	31 07       	cpc	r19, r17
    137a:	40 f3       	brcs	.-48     	; 0x134c <http_get_variable+0x4e>
			match = 0;
		}
	}
	
	// if found variable keyword, then store variable value in destination buffer ( dest )
	if ( match != 0 )
    137c:	88 23       	and	r24, r24
    137e:	b1 f0       	breq	.+44     	; 0x13ac <http_get_variable+0xae>
    1380:	de 01       	movw	r26, r28
    1382:	a2 0f       	add	r26, r18
    1384:	b3 1f       	adc	r27, r19
    1386:	80 e0       	ldi	r24, 0x00	; 0
		match = 0;

		for ( ;; )
		{
			// end of variable value break from loop
			if ( rxtx_buffer [ data_p ] == '&' || rxtx_buffer [ data_p ] == ' ' )
    1388:	9c 91       	ld	r25, X
    138a:	96 32       	cpi	r25, 0x26	; 38
    138c:	19 f0       	breq	.+6      	; 0x1394 <http_get_variable+0x96>
    138e:	11 96       	adiw	r26, 0x01	; 1
    1390:	90 32       	cpi	r25, 0x20	; 32
    1392:	29 f4       	brne	.+10     	; 0x139e <http_get_variable+0xa0>
			{
				dest [ match ] = '\0';
    1394:	e8 0e       	add	r14, r24
    1396:	f1 1c       	adc	r15, r1
    1398:	f7 01       	movw	r30, r14
    139a:	10 82       	st	Z, r1
    139c:	07 c0       	rjmp	.+14     	; 0x13ac <http_get_variable+0xae>
				break;
			}
			dest [ match ] = rxtx_buffer [ data_p ];
    139e:	f7 01       	movw	r30, r14
    13a0:	e8 0f       	add	r30, r24
    13a2:	f1 1d       	adc	r31, r1
    13a4:	90 83       	st	Z, r25
			match++;
    13a6:	8f 5f       	subi	r24, 0xFF	; 255
    13a8:	ef cf       	rjmp	.-34     	; 0x1388 <http_get_variable+0x8a>
			data_p++;
		}
    13aa:	80 e0       	ldi	r24, 0x00	; 0
	}

	// return with variable value length
	return match;
}
    13ac:	df 91       	pop	r29
    13ae:	cf 91       	pop	r28
    13b0:	1f 91       	pop	r17
    13b2:	0f 91       	pop	r16
    13b4:	ff 90       	pop	r15
    13b6:	ef 90       	pop	r14
    13b8:	df 90       	pop	r13
    13ba:	cf 90       	pop	r12
    13bc:	08 95       	ret

000013be <http_webserver_process>:
// Function : http_webserver_process
// Description : Initial connection to web server
//
//********************************************************************************************
void http_webserver_process ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    13be:	2f 92       	push	r2
    13c0:	3f 92       	push	r3
    13c2:	4f 92       	push	r4
    13c4:	5f 92       	push	r5
    13c6:	6f 92       	push	r6
    13c8:	7f 92       	push	r7
    13ca:	8f 92       	push	r8
    13cc:	9f 92       	push	r9
    13ce:	af 92       	push	r10
    13d0:	bf 92       	push	r11
    13d2:	cf 92       	push	r12
    13d4:	df 92       	push	r13
    13d6:	ef 92       	push	r14
    13d8:	0f 93       	push	r16
    13da:	1f 93       	push	r17
    13dc:	df 93       	push	r29
    13de:	cf 93       	push	r28
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	c4 54       	subi	r28, 0x44	; 68
    13e6:	d1 40       	sbci	r29, 0x01	; 1
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	de bf       	out	0x3e, r29	; 62
    13ee:	0f be       	out	0x3f, r0	; 63
    13f0:	cd bf       	out	0x3d, r28	; 61
    13f2:	2c 01       	movw	r4, r24
    13f4:	cf 5b       	subi	r28, 0xBF	; 191
    13f6:	de 4f       	sbci	r29, 0xFE	; 254
    13f8:	79 83       	std	Y+1, r23	; 0x01
    13fa:	68 83       	st	Y, r22
    13fc:	c1 54       	subi	r28, 0x41	; 65
    13fe:	d1 40       	sbci	r29, 0x01	; 1
    1400:	cd 5b       	subi	r28, 0xBD	; 189
    1402:	de 4f       	sbci	r29, 0xFE	; 254
    1404:	59 83       	std	Y+1, r21	; 0x01
    1406:	48 83       	st	Y, r20
    1408:	c3 54       	subi	r28, 0x43	; 67
    140a:	d1 40       	sbci	r29, 0x01	; 1

	static unsigned int numCount = 0;

	unsigned char page;
	
	dest_port = (rxtx_buffer[TCP_SRC_PORT_H_P]<<8)|rxtx_buffer[TCP_SRC_PORT_L_P];
    140c:	fc 01       	movw	r30, r24
    140e:	22 a1       	ldd	r18, Z+34	; 0x22
    1410:	63 a1       	ldd	r22, Z+35	; 0x23
	// tcp port 80 start for web server
	if ( rxtx_buffer [ IP_PROTO_P ] == IP_PROTO_TCP_V && rxtx_buffer[ TCP_DST_PORT_H_P ] == 0 && rxtx_buffer[ TCP_DST_PORT_L_P ] == 80 )
    1412:	87 89       	ldd	r24, Z+23	; 0x17
    1414:	86 30       	cpi	r24, 0x06	; 6
    1416:	09 f0       	breq	.+2      	; 0x141a <http_webserver_process+0x5c>
    1418:	73 c1       	rjmp	.+742    	; 0x1700 <http_webserver_process+0x342>
    141a:	84 a1       	ldd	r24, Z+36	; 0x24
    141c:	88 23       	and	r24, r24
    141e:	09 f0       	breq	.+2      	; 0x1422 <http_webserver_process+0x64>
    1420:	6f c1       	rjmp	.+734    	; 0x1700 <http_webserver_process+0x342>
    1422:	85 a1       	ldd	r24, Z+37	; 0x25
    1424:	80 35       	cpi	r24, 0x50	; 80
    1426:	09 f0       	breq	.+2      	; 0x142a <http_webserver_process+0x6c>
    1428:	6b c1       	rjmp	.+726    	; 0x1700 <http_webserver_process+0x342>

	static unsigned int numCount = 0;

	unsigned char page;
	
	dest_port = (rxtx_buffer[TCP_SRC_PORT_H_P]<<8)|rxtx_buffer[TCP_SRC_PORT_L_P];
    142a:	92 2f       	mov	r25, r18
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	26 2e       	mov	r2, r22
    1430:	33 24       	eor	r3, r3
    1432:	28 2a       	or	r2, r24
    1434:	39 2a       	or	r3, r25
	// tcp port 80 start for web server
	if ( rxtx_buffer [ IP_PROTO_P ] == IP_PROTO_TCP_V && rxtx_buffer[ TCP_DST_PORT_H_P ] == 0 && rxtx_buffer[ TCP_DST_PORT_L_P ] == 80 )
	{
		// received packet with flags "SYN", let's send "SYNACK"
		if ( (rxtx_buffer[ TCP_FLAGS_P ] & TCP_FLAG_SYN_V) )
    1436:	87 a5       	ldd	r24, Z+47	; 0x2f
    1438:	81 ff       	sbrs	r24, 1
    143a:	1d c0       	rjmp	.+58     	; 0x1476 <http_webserver_process+0xb8>
		{
//			tcp_send_synack ( rxtx_buffer, dest_mac, dest_ip );
			tcp_send_packet (
    143c:	00 d0       	rcall	.+0      	; 0x143e <http_webserver_process+0x80>
    143e:	ed b7       	in	r30, 0x3d	; 61
    1440:	fe b7       	in	r31, 0x3e	; 62
    1442:	52 83       	std	Z+2, r21	; 0x02
    1444:	41 83       	std	Z+1, r20	; 0x01
    1446:	c2 01       	movw	r24, r4
    1448:	b1 01       	movw	r22, r2
    144a:	40 e5       	ldi	r20, 0x50	; 80
    144c:	50 e0       	ldi	r21, 0x00	; 0
    144e:	22 e1       	ldi	r18, 0x12	; 18
    1450:	01 e0       	ldi	r16, 0x01	; 1
    1452:	ee 24       	eor	r14, r14
    1454:	f1 e0       	ldi	r31, 0x01	; 1
    1456:	cf 2e       	mov	r12, r31
    1458:	d1 2c       	mov	r13, r1
    145a:	aa 24       	eor	r10, r10
    145c:	bb 24       	eor	r11, r11
    145e:	cf 5b       	subi	r28, 0xBF	; 191
    1460:	de 4f       	sbci	r29, 0xFE	; 254
    1462:	88 80       	ld	r8, Y
    1464:	99 80       	ldd	r9, Y+1	; 0x01
    1466:	c1 54       	subi	r28, 0x41	; 65
    1468:	d1 40       	sbci	r29, 0x01	; 1
    146a:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <tcp_send_packet>
				0,						// (bool)clear sequence ack number
				1,						// (bool)calculate new seq and seqack number
				0,						// tcp data length
				dest_mac,		// server mac address
				dest_ip );		// server ip address
			flag1.bits.syn_is_received = 1;
    146e:	80 91 ba 00 	lds	r24, 0x00BA
    1472:	80 64       	ori	r24, 0x40	; 64
    1474:	41 c1       	rjmp	.+642    	; 0x16f8 <http_webserver_process+0x33a>
			return;
		}

		if ( (rxtx_buffer [ TCP_FLAGS_P ] & TCP_FLAG_ACK_V) )
    1476:	84 ff       	sbrs	r24, 4
    1478:	43 c1       	rjmp	.+646    	; 0x1700 <http_webserver_process+0x342>
		{
			// get tcp data length
			dlength = tcp_get_dlength( rxtx_buffer );
    147a:	c2 01       	movw	r24, r4
    147c:	0e 94 93 0c 	call	0x1926	; 0x1926 <tcp_get_dlength>
    1480:	3c 01       	movw	r6, r24
			if ( dlength == 0 )
    1482:	00 97       	sbiw	r24, 0x00	; 0
    1484:	21 f5       	brne	.+72     	; 0x14ce <http_webserver_process+0x110>
			{
				// finack, answer with ack
				if ( (rxtx_buffer[TCP_FLAGS_P] & TCP_FLAG_FIN_V) )
    1486:	f2 01       	movw	r30, r4
    1488:	87 a5       	ldd	r24, Z+47	; 0x2f
    148a:	80 ff       	sbrs	r24, 0
    148c:	39 c1       	rjmp	.+626    	; 0x1700 <http_webserver_process+0x342>
				{
//					tcp_send_ack ( rxtx_buffer, dest_mac, dest_ip );
					tcp_send_packet (
    148e:	00 d0       	rcall	.+0      	; 0x1490 <http_webserver_process+0xd2>
    1490:	cd 5b       	subi	r28, 0xBD	; 189
    1492:	de 4f       	sbci	r29, 0xFE	; 254
    1494:	88 81       	ld	r24, Y
    1496:	99 81       	ldd	r25, Y+1	; 0x01
    1498:	c3 54       	subi	r28, 0x43	; 67
    149a:	d1 40       	sbci	r29, 0x01	; 1
    149c:	ed b7       	in	r30, 0x3d	; 61
    149e:	fe b7       	in	r31, 0x3e	; 62
    14a0:	92 83       	std	Z+2, r25	; 0x02
    14a2:	81 83       	std	Z+1, r24	; 0x01
    14a4:	c2 01       	movw	r24, r4
    14a6:	b1 01       	movw	r22, r2
    14a8:	40 e5       	ldi	r20, 0x50	; 80
    14aa:	50 e0       	ldi	r21, 0x00	; 0
    14ac:	20 e1       	ldi	r18, 0x10	; 16
    14ae:	00 e0       	ldi	r16, 0x00	; 0
    14b0:	ee 24       	eor	r14, r14
    14b2:	e1 e0       	ldi	r30, 0x01	; 1
    14b4:	ce 2e       	mov	r12, r30
    14b6:	d1 2c       	mov	r13, r1
    14b8:	aa 24       	eor	r10, r10
    14ba:	bb 24       	eor	r11, r11
    14bc:	cf 5b       	subi	r28, 0xBF	; 191
    14be:	de 4f       	sbci	r29, 0xFE	; 254
    14c0:	88 80       	ld	r8, Y
    14c2:	99 80       	ldd	r9, Y+1	; 0x01
    14c4:	c1 54       	subi	r28, 0x41	; 65
    14c6:	d1 40       	sbci	r29, 0x01	; 1
    14c8:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <tcp_send_packet>
    14cc:	17 c1       	rjmp	.+558    	; 0x16fc <http_webserver_process+0x33e>
						dest_ip );		// server ip address
				}
				return;
			}

			if ( http_get_variable ( rxtx_buffer, dlength, PSTR( "reg_send_msg" ), generic_buf ) ) {
    14ce:	c2 01       	movw	r24, r4
    14d0:	b3 01       	movw	r22, r6
    14d2:	4b ef       	ldi	r20, 0xFB	; 251
    14d4:	58 e0       	ldi	r21, 0x08	; 8
    14d6:	6e 01       	movw	r12, r28
    14d8:	08 94       	sec
    14da:	c1 1c       	adc	r12, r1
    14dc:	d1 1c       	adc	r13, r1
    14de:	96 01       	movw	r18, r12
    14e0:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    14e4:	88 23       	and	r24, r24
    14e6:	29 f1       	breq	.+74     	; 0x1532 <http_webserver_process+0x174>
			//	USART_SendString("data received");
				if(generic_buf[0] == '1') {
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	81 33       	cpi	r24, 0x31	; 49
    14ec:	09 f0       	breq	.+2      	; 0x14f0 <http_webserver_process+0x132>
    14ee:	c8 c0       	rjmp	.+400    	; 0x1680 <http_webserver_process+0x2c2>
					if( http_get_variable ( rxtx_buffer, dlength, PSTR( "mobNum" ), mob_num ) ) {
    14f0:	c2 01       	movw	r24, r4
    14f2:	b3 01       	movw	r22, r6
    14f4:	44 ef       	ldi	r20, 0xF4	; 244
    14f6:	58 e0       	ldi	r21, 0x08	; 8
    14f8:	9e 01       	movw	r18, r28
    14fa:	2f 5b       	subi	r18, 0xBF	; 191
    14fc:	3f 4f       	sbci	r19, 0xFF	; 255
    14fe:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    1502:	88 23       	and	r24, r24
    1504:	09 f4       	brne	.+2      	; 0x1508 <http_webserver_process+0x14a>
    1506:	4d c0       	rjmp	.+154    	; 0x15a2 <http_webserver_process+0x1e4>
						if( http_get_variable ( rxtx_buffer, dlength, PSTR( "secCode" ), sec_code ) ) {
    1508:	c2 01       	movw	r24, r4
    150a:	b3 01       	movw	r22, r6
    150c:	4c ee       	ldi	r20, 0xEC	; 236
    150e:	58 e0       	ldi	r21, 0x08	; 8
    1510:	9e 01       	movw	r18, r28
    1512:	2f 57       	subi	r18, 0x7F	; 127
    1514:	3f 4f       	sbci	r19, 0xFF	; 255
    1516:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    151a:	88 23       	and	r24, r24
    151c:	09 f4       	brne	.+2      	; 0x1520 <http_webserver_process+0x162>
    151e:	41 c0       	rjmp	.+130    	; 0x15a2 <http_webserver_process+0x1e4>
							//USART_SendString("sms sending");
							//sprintf(msg,"emBank verification code: %s",sec_code);
							GSM_SendMessage(mob_num,sec_code);
    1520:	ce 01       	movw	r24, r28
    1522:	8f 5b       	subi	r24, 0xBF	; 191
    1524:	9f 4f       	sbci	r25, 0xFF	; 255
    1526:	be 01       	movw	r22, r28
    1528:	6f 57       	subi	r22, 0x7F	; 127
    152a:	7f 4f       	sbci	r23, 0xFF	; 255
    152c:	0e 94 25 10 	call	0x204a	; 0x204a <GSM_SendMessage>
    1530:	38 c0       	rjmp	.+112    	; 0x15a2 <http_webserver_process+0x1e4>
						}
					}

					dlength = http_test( rxtx_buffer );
				}
			} else if ( http_get_variable ( rxtx_buffer, dlength, PSTR( "bal_trf" ), generic_buf ) ) {
    1532:	c2 01       	movw	r24, r4
    1534:	b3 01       	movw	r22, r6
    1536:	44 ee       	ldi	r20, 0xE4	; 228
    1538:	58 e0       	ldi	r21, 0x08	; 8
    153a:	96 01       	movw	r18, r12
    153c:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    1540:	88 23       	and	r24, r24
    1542:	11 f1       	breq	.+68     	; 0x1588 <http_webserver_process+0x1ca>
			//	USART_SendString("data received");
				if(generic_buf[0] == '1') {
    1544:	89 81       	ldd	r24, Y+1	; 0x01
    1546:	81 33       	cpi	r24, 0x31	; 49
    1548:	09 f0       	breq	.+2      	; 0x154c <http_webserver_process+0x18e>
    154a:	9a c0       	rjmp	.+308    	; 0x1680 <http_webserver_process+0x2c2>
					if( http_get_variable ( rxtx_buffer, dlength, PSTR( "receiver" ), receiver ) ) {
    154c:	c2 01       	movw	r24, r4
    154e:	b3 01       	movw	r22, r6
    1550:	4b ed       	ldi	r20, 0xDB	; 219
    1552:	58 e0       	ldi	r21, 0x08	; 8
    1554:	9e 01       	movw	r18, r28
    1556:	2f 53       	subi	r18, 0x3F	; 63
    1558:	3f 4f       	sbci	r19, 0xFF	; 255
    155a:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    155e:	88 23       	and	r24, r24
    1560:	01 f1       	breq	.+64     	; 0x15a2 <http_webserver_process+0x1e4>
						if( http_get_variable ( rxtx_buffer, dlength, PSTR( "ammount" ), ammount ) ) {
    1562:	8e 01       	movw	r16, r28
    1564:	0f 5f       	subi	r16, 0xFF	; 255
    1566:	1e 4f       	sbci	r17, 0xFE	; 254
    1568:	c2 01       	movw	r24, r4
    156a:	b3 01       	movw	r22, r6
    156c:	43 ed       	ldi	r20, 0xD3	; 211
    156e:	58 e0       	ldi	r21, 0x08	; 8
    1570:	98 01       	movw	r18, r16
    1572:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    1576:	88 23       	and	r24, r24
    1578:	a1 f0       	breq	.+40     	; 0x15a2 <http_webserver_process+0x1e4>
							//USART_SendString("sms sending");
							//sprintf(msg,"emBank verification code: %s",sec_code);
							GSM_TrfBalance(receiver,ammount);
    157a:	ce 01       	movw	r24, r28
    157c:	8f 53       	subi	r24, 0x3F	; 63
    157e:	9f 4f       	sbci	r25, 0xFF	; 255
    1580:	b8 01       	movw	r22, r16
    1582:	0e 94 00 10 	call	0x2000	; 0x2000 <GSM_TrfBalance>
    1586:	0d c0       	rjmp	.+26     	; 0x15a2 <http_webserver_process+0x1e4>
						}
					}

					dlength = http_test( rxtx_buffer );
				}
			} else if( http_get_variable ( rxtx_buffer, dlength, PSTR( "check" ), generic_buf ) ) {
    1588:	c2 01       	movw	r24, r4
    158a:	b3 01       	movw	r22, r6
    158c:	4d ec       	ldi	r20, 0xCD	; 205
    158e:	58 e0       	ldi	r21, 0x08	; 8
    1590:	96 01       	movw	r18, r12
    1592:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    1596:	88 23       	and	r24, r24
    1598:	41 f0       	breq	.+16     	; 0x15aa <http_webserver_process+0x1ec>
				if(generic_buf[0] == '1') {
    159a:	89 81       	ldd	r24, Y+1	; 0x01
    159c:	81 33       	cpi	r24, 0x31	; 49
    159e:	09 f0       	breq	.+2      	; 0x15a2 <http_webserver_process+0x1e4>
    15a0:	6f c0       	rjmp	.+222    	; 0x1680 <http_webserver_process+0x2c2>
					dlength = http_test( rxtx_buffer );
    15a2:	c2 01       	movw	r24, r4
    15a4:	0e 94 1a 09 	call	0x1234	; 0x1234 <http_test>
    15a8:	6a c0       	rjmp	.+212    	; 0x167e <http_webserver_process+0x2c0>
				}
			} else if (http_get_variable ( rxtx_buffer, dlength, PSTR( "control" ), generic_buf )) {
    15aa:	c2 01       	movw	r24, r4
    15ac:	b3 01       	movw	r22, r6
    15ae:	45 ec       	ldi	r20, 0xC5	; 197
    15b0:	58 e0       	ldi	r21, 0x08	; 8
    15b2:	96 01       	movw	r18, r12
    15b4:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    15b8:	88 23       	and	r24, r24
    15ba:	09 f4       	brne	.+2      	; 0x15be <http_webserver_process+0x200>
    15bc:	59 c0       	rjmp	.+178    	; 0x1670 <http_webserver_process+0x2b2>
				if(generic_buf[0] == '1') {
    15be:	89 81       	ldd	r24, Y+1	; 0x01
    15c0:	81 33       	cpi	r24, 0x31	; 49
    15c2:	09 f0       	breq	.+2      	; 0x15c6 <http_webserver_process+0x208>
    15c4:	5d c0       	rjmp	.+186    	; 0x1680 <http_webserver_process+0x2c2>
					if (http_get_variable ( rxtx_buffer, dlength, PSTR( "bulb1" ), generic_buf )) {
    15c6:	c2 01       	movw	r24, r4
    15c8:	b3 01       	movw	r22, r6
    15ca:	4f eb       	ldi	r20, 0xBF	; 191
    15cc:	58 e0       	ldi	r21, 0x08	; 8
    15ce:	9e 01       	movw	r18, r28
    15d0:	2f 5f       	subi	r18, 0xFF	; 255
    15d2:	3f 4f       	sbci	r19, 0xFF	; 255
    15d4:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    15d8:	88 23       	and	r24, r24
    15da:	81 f0       	breq	.+32     	; 0x15fc <http_webserver_process+0x23e>
						if(generic_buf[0] == '1') {
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	81 33       	cpi	r24, 0x31	; 49
    15e0:	41 f4       	brne	.+16     	; 0x15f2 <http_webserver_process+0x234>
							bulb_1 = 1;
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	90 93 b4 00 	sts	0x00B4, r25
    15ea:	80 93 b3 00 	sts	0x00B3, r24
							CONTROL_PORT |= (1<<BULB_1_PIN);
    15ee:	ab 9a       	sbi	0x15, 3	; 21
    15f0:	05 c0       	rjmp	.+10     	; 0x15fc <http_webserver_process+0x23e>
						} else {
							bulb_1 = 0;
    15f2:	10 92 b4 00 	sts	0x00B4, r1
    15f6:	10 92 b3 00 	sts	0x00B3, r1
							CONTROL_PORT &= ~(1<<BULB_1_PIN);
    15fa:	ab 98       	cbi	0x15, 3	; 21
						}
					}
					if (http_get_variable ( rxtx_buffer, dlength, PSTR( "bulb2" ), generic_buf )) {
    15fc:	c2 01       	movw	r24, r4
    15fe:	b3 01       	movw	r22, r6
    1600:	49 eb       	ldi	r20, 0xB9	; 185
    1602:	58 e0       	ldi	r21, 0x08	; 8
    1604:	9e 01       	movw	r18, r28
    1606:	2f 5f       	subi	r18, 0xFF	; 255
    1608:	3f 4f       	sbci	r19, 0xFF	; 255
    160a:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    160e:	88 23       	and	r24, r24
    1610:	81 f0       	breq	.+32     	; 0x1632 <http_webserver_process+0x274>
						if(generic_buf[0] == '1') {
    1612:	89 81       	ldd	r24, Y+1	; 0x01
    1614:	81 33       	cpi	r24, 0x31	; 49
    1616:	41 f4       	brne	.+16     	; 0x1628 <http_webserver_process+0x26a>
							bulb_2 = 1;
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	90 93 b6 00 	sts	0x00B6, r25
    1620:	80 93 b5 00 	sts	0x00B5, r24
							CONTROL_PORT |= (1<<BULB_2_PIN);
    1624:	ac 9a       	sbi	0x15, 4	; 21
    1626:	05 c0       	rjmp	.+10     	; 0x1632 <http_webserver_process+0x274>
						} else {
							bulb_2 = 0;
    1628:	10 92 b6 00 	sts	0x00B6, r1
    162c:	10 92 b5 00 	sts	0x00B5, r1
							CONTROL_PORT &= ~(1<<BULB_2_PIN);
    1630:	ac 98       	cbi	0x15, 4	; 21
						}
					}
					if (http_get_variable ( rxtx_buffer, dlength, PSTR( "fan" ), generic_buf )) {
    1632:	c2 01       	movw	r24, r4
    1634:	b3 01       	movw	r22, r6
    1636:	45 eb       	ldi	r20, 0xB5	; 181
    1638:	58 e0       	ldi	r21, 0x08	; 8
    163a:	9e 01       	movw	r18, r28
    163c:	2f 5f       	subi	r18, 0xFF	; 255
    163e:	3f 4f       	sbci	r19, 0xFF	; 255
    1640:	0e 94 7f 09 	call	0x12fe	; 0x12fe <http_get_variable>
    1644:	88 23       	and	r24, r24
    1646:	81 f0       	breq	.+32     	; 0x1668 <http_webserver_process+0x2aa>
						if(generic_buf[0] == '1') {
    1648:	89 81       	ldd	r24, Y+1	; 0x01
    164a:	81 33       	cpi	r24, 0x31	; 49
    164c:	41 f4       	brne	.+16     	; 0x165e <http_webserver_process+0x2a0>
							fan = 1;
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	90 93 b8 00 	sts	0x00B8, r25
    1656:	80 93 b7 00 	sts	0x00B7, r24
							CONTROL_PORT |= (1<<FAN_PIN);
    165a:	ad 9a       	sbi	0x15, 5	; 21
    165c:	05 c0       	rjmp	.+10     	; 0x1668 <http_webserver_process+0x2aa>
						} else {
							fan = 0;
    165e:	10 92 b8 00 	sts	0x00B8, r1
    1662:	10 92 b7 00 	sts	0x00B7, r1
							CONTROL_PORT &= ~(1<<FAN_PIN);
    1666:	ad 98       	cbi	0x15, 5	; 21
						}
					}
					dlength = http_control( rxtx_buffer );
    1668:	c2 01       	movw	r24, r4
    166a:	0e 94 15 08 	call	0x102a	; 0x102a <http_control>
    166e:	07 c0       	rjmp	.+14     	; 0x167e <http_webserver_process+0x2c0>
WORD http_home( BYTE *rxtx_buffer )
{
	WORD dlen;
	BYTE generic_buf[64];

	dlen = tcp_puts_data_p ( rxtx_buffer, PSTR ( "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n" ), 0 );
    1670:	c2 01       	movw	r24, r4
    1672:	68 ee       	ldi	r22, 0xE8	; 232
    1674:	77 e0       	ldi	r23, 0x07	; 7
    1676:	40 e0       	ldi	r20, 0x00	; 0
    1678:	50 e0       	ldi	r21, 0x00	; 0
    167a:	0e 94 b3 0c 	call	0x1966	; 0x1966 <tcp_puts_data_p>
    167e:	3c 01       	movw	r6, r24

			// print webpage
			//dlength = http_page( rxtx_buffer );
			// send ack before send data
//			tcp_send_ack ( rxtx_buffer, dest_mac, dest_ip );
			tcp_send_packet (
    1680:	00 d0       	rcall	.+0      	; 0x1682 <http_webserver_process+0x2c4>
    1682:	cd 5b       	subi	r28, 0xBD	; 189
    1684:	de 4f       	sbci	r29, 0xFE	; 254
    1686:	88 81       	ld	r24, Y
    1688:	99 81       	ldd	r25, Y+1	; 0x01
    168a:	c3 54       	subi	r28, 0x43	; 67
    168c:	d1 40       	sbci	r29, 0x01	; 1
    168e:	ed b7       	in	r30, 0x3d	; 61
    1690:	fe b7       	in	r31, 0x3e	; 62
    1692:	92 83       	std	Z+2, r25	; 0x02
    1694:	81 83       	std	Z+1, r24	; 0x01
    1696:	c2 01       	movw	r24, r4
    1698:	b1 01       	movw	r22, r2
    169a:	40 e5       	ldi	r20, 0x50	; 80
    169c:	50 e0       	ldi	r21, 0x00	; 0
    169e:	20 e1       	ldi	r18, 0x10	; 16
    16a0:	00 e0       	ldi	r16, 0x00	; 0
    16a2:	ee 24       	eor	r14, r14
    16a4:	31 e0       	ldi	r19, 0x01	; 1
    16a6:	c3 2e       	mov	r12, r19
    16a8:	d1 2c       	mov	r13, r1
    16aa:	aa 24       	eor	r10, r10
    16ac:	bb 24       	eor	r11, r11
    16ae:	cf 5b       	subi	r28, 0xBF	; 191
    16b0:	de 4f       	sbci	r29, 0xFE	; 254
    16b2:	88 80       	ld	r8, Y
    16b4:	99 80       	ldd	r9, Y+1	; 0x01
    16b6:	c1 54       	subi	r28, 0x41	; 65
    16b8:	d1 40       	sbci	r29, 0x01	; 1
    16ba:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <tcp_send_packet>
						0,						// tcp data length
						dest_mac,		// server mac address
						dest_ip );		// server ip address
			// send tcp data
//			tcp_send_data ( rxtx_buffer, dest_mac, dest_ip, dlength );
			tcp_send_packet (
    16be:	cd 5b       	subi	r28, 0xBD	; 189
    16c0:	de 4f       	sbci	r29, 0xFE	; 254
    16c2:	88 81       	ld	r24, Y
    16c4:	99 81       	ldd	r25, Y+1	; 0x01
    16c6:	c3 54       	subi	r28, 0x43	; 67
    16c8:	d1 40       	sbci	r29, 0x01	; 1
    16ca:	ed b7       	in	r30, 0x3d	; 61
    16cc:	fe b7       	in	r31, 0x3e	; 62
    16ce:	92 83       	std	Z+2, r25	; 0x02
    16d0:	81 83       	std	Z+1, r24	; 0x01
    16d2:	c2 01       	movw	r24, r4
    16d4:	b1 01       	movw	r22, r2
    16d6:	40 e5       	ldi	r20, 0x50	; 80
    16d8:	50 e0       	ldi	r21, 0x00	; 0
    16da:	29 e1       	ldi	r18, 0x19	; 25
    16dc:	cc 24       	eor	r12, r12
    16de:	dd 24       	eor	r13, r13
    16e0:	53 01       	movw	r10, r6
    16e2:	cf 5b       	subi	r28, 0xBF	; 191
    16e4:	de 4f       	sbci	r29, 0xFE	; 254
    16e6:	88 80       	ld	r8, Y
    16e8:	99 80       	ldd	r9, Y+1	; 0x01
    16ea:	c1 54       	subi	r28, 0x41	; 65
    16ec:	d1 40       	sbci	r29, 0x01	; 1
    16ee:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <tcp_send_packet>
						0,						// (bool)clear sequence ack number
						0,						// (bool)calculate new seq and seqack number
						dlength,				// tcp data length
						dest_mac,		// server mac address
						dest_ip );		// server ip address
			flag1.bits.syn_is_received = 0;
    16f2:	80 91 ba 00 	lds	r24, 0x00BA
    16f6:	8f 7b       	andi	r24, 0xBF	; 191
    16f8:	80 93 ba 00 	sts	0x00BA, r24
    16fc:	0f 90       	pop	r0
    16fe:	0f 90       	pop	r0
		}		
	}
}
    1700:	cc 5b       	subi	r28, 0xBC	; 188
    1702:	de 4f       	sbci	r29, 0xFE	; 254
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	f8 94       	cli
    1708:	de bf       	out	0x3e, r29	; 62
    170a:	0f be       	out	0x3f, r0	; 63
    170c:	cd bf       	out	0x3d, r28	; 61
    170e:	cf 91       	pop	r28
    1710:	df 91       	pop	r29
    1712:	1f 91       	pop	r17
    1714:	0f 91       	pop	r16
    1716:	ef 90       	pop	r14
    1718:	df 90       	pop	r13
    171a:	cf 90       	pop	r12
    171c:	bf 90       	pop	r11
    171e:	af 90       	pop	r10
    1720:	9f 90       	pop	r9
    1722:	8f 90       	pop	r8
    1724:	7f 90       	pop	r7
    1726:	6f 90       	pop	r6
    1728:	5f 90       	pop	r5
    172a:	4f 90       	pop	r4
    172c:	3f 90       	pop	r3
    172e:	2f 90       	pop	r2
    1730:	08 95       	ret

00001732 <arp_generate_packet>:
// Function : arp_generate_packet
// Description : generate arp packet
//
//********************************************************************************************
void arp_generate_packet ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
    1736:	dc 01       	movw	r26, r24
	unsigned char i;
	
	// setup hardware type to ethernet 0x0001
	rxtx_buffer[ ARP_HARDWARE_TYPE_H_P ] = ARP_HARDWARE_TYPE_H_V;
    1738:	1e 96       	adiw	r26, 0x0e	; 14
    173a:	1c 92       	st	X, r1
    173c:	1e 97       	sbiw	r26, 0x0e	; 14
	rxtx_buffer[ ARP_HARDWARE_TYPE_L_P ] = ARP_HARDWARE_TYPE_L_V;
    173e:	81 e0       	ldi	r24, 0x01	; 1
    1740:	1f 96       	adiw	r26, 0x0f	; 15
    1742:	8c 93       	st	X, r24
    1744:	1f 97       	sbiw	r26, 0x0f	; 15
	
	// setup protocol type to ip 0x0800
	rxtx_buffer[ ARP_PROTOCOL_H_P ] = ARP_PROTOCOL_H_V;
    1746:	88 e0       	ldi	r24, 0x08	; 8
    1748:	50 96       	adiw	r26, 0x10	; 16
    174a:	8c 93       	st	X, r24
    174c:	50 97       	sbiw	r26, 0x10	; 16
	rxtx_buffer[ ARP_PROTOCOL_L_P ] = ARP_PROTOCOL_L_V;
    174e:	51 96       	adiw	r26, 0x11	; 17
    1750:	1c 92       	st	X, r1
    1752:	51 97       	sbiw	r26, 0x11	; 17

	// setup hardware length to 0x06
	rxtx_buffer[ ARP_HARDWARE_SIZE_P ] = ARP_HARDWARE_SIZE_V;
    1754:	86 e0       	ldi	r24, 0x06	; 6
    1756:	52 96       	adiw	r26, 0x12	; 18
    1758:	8c 93       	st	X, r24
    175a:	52 97       	sbiw	r26, 0x12	; 18

	// setup protocol length to 0x04
	rxtx_buffer[ ARP_PROTOCOL_SIZE_P ] = ARP_PROTOCOL_SIZE_V;
    175c:	84 e0       	ldi	r24, 0x04	; 4
    175e:	53 96       	adiw	r26, 0x13	; 19
    1760:	8c 93       	st	X, r24
    1762:	53 97       	sbiw	r26, 0x13	; 19
    1764:	ed 01       	movw	r28, r26
    1766:	20 e0       	ldi	r18, 0x00	; 0
    1768:	30 e0       	ldi	r19, 0x00	; 0

	// setup arp destination and source mac address
	for ( i=0; i<sizeof(MAC_ADDR); i++)
	{
		rxtx_buffer[ ARP_DST_MAC_P + i ] = dest_mac[i];
    176a:	fb 01       	movw	r30, r22
    176c:	e2 0f       	add	r30, r18
    176e:	f3 1f       	adc	r31, r19
    1770:	80 81       	ld	r24, Z
    1772:	88 a3       	std	Y+32, r24	; 0x20
		rxtx_buffer[ ARP_SRC_MAC_P + i ] = avr_mac.byte[i];
    1774:	f9 01       	movw	r30, r18
    1776:	e5 54       	subi	r30, 0x45	; 69
    1778:	ff 4f       	sbci	r31, 0xFF	; 255
    177a:	80 81       	ld	r24, Z
    177c:	8e 8b       	std	Y+22, r24	; 0x16
    177e:	2f 5f       	subi	r18, 0xFF	; 255
    1780:	3f 4f       	sbci	r19, 0xFF	; 255
    1782:	21 96       	adiw	r28, 0x01	; 1

	// setup protocol length to 0x04
	rxtx_buffer[ ARP_PROTOCOL_SIZE_P ] = ARP_PROTOCOL_SIZE_V;

	// setup arp destination and source mac address
	for ( i=0; i<sizeof(MAC_ADDR); i++)
    1784:	26 30       	cpi	r18, 0x06	; 6
    1786:	31 05       	cpc	r19, r1
    1788:	81 f7       	brne	.-32     	; 0x176a <arp_generate_packet+0x38>
    178a:	5c 96       	adiw	r26, 0x1c	; 28
    178c:	20 e0       	ldi	r18, 0x00	; 0
    178e:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	// setup arp destination and source ip address
	for ( i=0; i<sizeof(IP_ADDR); i++)
	{
		rxtx_buffer[ ARP_DST_IP_P + i ] = dest_ip[i];
    1790:	fa 01       	movw	r30, r20
    1792:	e2 0f       	add	r30, r18
    1794:	f3 1f       	adc	r31, r19
    1796:	80 81       	ld	r24, Z
    1798:	1a 96       	adiw	r26, 0x0a	; 10
    179a:	8c 93       	st	X, r24
    179c:	1a 97       	sbiw	r26, 0x0a	; 10
		rxtx_buffer[ ARP_SRC_IP_P + i ] = avr_ip.byte[i];
    179e:	f9 01       	movw	r30, r18
    17a0:	eb 53       	subi	r30, 0x3B	; 59
    17a2:	ff 4f       	sbci	r31, 0xFF	; 255
    17a4:	80 81       	ld	r24, Z
    17a6:	8d 93       	st	X+, r24
    17a8:	2f 5f       	subi	r18, 0xFF	; 255
    17aa:	3f 4f       	sbci	r19, 0xFF	; 255
		rxtx_buffer[ ARP_DST_MAC_P + i ] = dest_mac[i];
		rxtx_buffer[ ARP_SRC_MAC_P + i ] = avr_mac.byte[i];
	}
	
	// setup arp destination and source ip address
	for ( i=0; i<sizeof(IP_ADDR); i++)
    17ac:	24 30       	cpi	r18, 0x04	; 4
    17ae:	31 05       	cpc	r19, r1
    17b0:	79 f7       	brne	.-34     	; 0x1790 <arp_generate_packet+0x5e>
	{
		rxtx_buffer[ ARP_DST_IP_P + i ] = dest_ip[i];
		rxtx_buffer[ ARP_SRC_IP_P + i ] = avr_ip.byte[i];
	}
}
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	08 95       	ret

000017b8 <arp_packet_is_arp>:
// Function : arp_packet_is_arp
// Description : check received packet, that packet is match with arp and avr ip or not?
//
//*******************************************************************************************
BYTE arp_packet_is_arp ( BYTE *rxtx_buffer, WORD_BYTES opcode )
{
    17b8:	fc 01       	movw	r30, r24
	BYTE i;

	// if packet type is not arp packet exit from function
	if( rxtx_buffer[ ETH_TYPE_H_P ] != ETH_TYPE_ARP_H_V || rxtx_buffer[ ETH_TYPE_L_P ] != ETH_TYPE_ARP_L_V)
    17ba:	84 85       	ldd	r24, Z+12	; 0x0c
    17bc:	88 30       	cpi	r24, 0x08	; 8
    17be:	c9 f4       	brne	.+50     	; 0x17f2 <arp_packet_is_arp+0x3a>
    17c0:	85 85       	ldd	r24, Z+13	; 0x0d
    17c2:	86 30       	cpi	r24, 0x06	; 6
    17c4:	b1 f4       	brne	.+44     	; 0x17f2 <arp_packet_is_arp+0x3a>
		return 0;
	// check arp request opcode
	if ( rxtx_buffer[ ARP_OPCODE_H_P ] != opcode.byte.high || rxtx_buffer[ ARP_OPCODE_L_P ] != opcode.byte.low )
    17c6:	84 89       	ldd	r24, Z+20	; 0x14
    17c8:	87 17       	cp	r24, r23
    17ca:	99 f4       	brne	.+38     	; 0x17f2 <arp_packet_is_arp+0x3a>
    17cc:	85 89       	ldd	r24, Z+21	; 0x15
    17ce:	86 17       	cp	r24, r22
    17d0:	81 f4       	brne	.+32     	; 0x17f2 <arp_packet_is_arp+0x3a>
    17d2:	df 01       	movw	r26, r30
    17d4:	96 96       	adiw	r26, 0x26	; 38
    17d6:	e5 ec       	ldi	r30, 0xC5	; 197
    17d8:	f0 e0       	ldi	r31, 0x00	; 0
		return 0;
	// if destination ip address in arp packet not match with avr ip address
	for ( i=0; i<sizeof(IP_ADDR); i++ )
	{
		if ( rxtx_buffer[ ARP_DST_IP_P + i] != avr_ip.byte[i] )
    17da:	9c 91       	ld	r25, X
    17dc:	80 81       	ld	r24, Z
    17de:	98 17       	cp	r25, r24
    17e0:	41 f4       	brne	.+16     	; 0x17f2 <arp_packet_is_arp+0x3a>
    17e2:	11 96       	adiw	r26, 0x01	; 1
    17e4:	31 96       	adiw	r30, 0x01	; 1
		return 0;
	// check arp request opcode
	if ( rxtx_buffer[ ARP_OPCODE_H_P ] != opcode.byte.high || rxtx_buffer[ ARP_OPCODE_L_P ] != opcode.byte.low )
		return 0;
	// if destination ip address in arp packet not match with avr ip address
	for ( i=0; i<sizeof(IP_ADDR); i++ )
    17e6:	80 e0       	ldi	r24, 0x00	; 0
    17e8:	e9 3c       	cpi	r30, 0xC9	; 201
    17ea:	f8 07       	cpc	r31, r24
    17ec:	b1 f7       	brne	.-20     	; 0x17da <arp_packet_is_arp+0x22>
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	08 95       	ret
    17f2:	80 e0       	ldi	r24, 0x00	; 0
	{
		if ( rxtx_buffer[ ARP_DST_IP_P + i] != avr_ip.byte[i] )
			return 0;
	}
	return 1;
}
    17f4:	08 95       	ret

000017f6 <arp_send_reply>:
// Function : arp_send_reply
// Description : Send reply if recieved packet is ARP and IP address is match with avr_ip
//
//*******************************************************************************************
void arp_send_reply ( BYTE *rxtx_buffer, BYTE *dest_mac )
{
    17f6:	ef 92       	push	r14
    17f8:	ff 92       	push	r15
    17fa:	0f 93       	push	r16
    17fc:	1f 93       	push	r17
    17fe:	8c 01       	movw	r16, r24
    1800:	7b 01       	movw	r14, r22
	// generate ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_ARP_V}, dest_mac );
    1802:	66 e0       	ldi	r22, 0x06	; 6
    1804:	78 e0       	ldi	r23, 0x08	; 8
    1806:	a7 01       	movw	r20, r14
    1808:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <eth_generate_header>

	// change packet type to echo reply
	rxtx_buffer[ ARP_OPCODE_H_P ] = ARP_OPCODE_REPLY_H_V;
    180c:	f8 01       	movw	r30, r16
    180e:	14 8a       	std	Z+20, r1	; 0x14
	rxtx_buffer[ ARP_OPCODE_L_P ] = ARP_OPCODE_REPLY_L_V;
    1810:	82 e0       	ldi	r24, 0x02	; 2
    1812:	85 8b       	std	Z+21, r24	; 0x15
	arp_generate_packet ( rxtx_buffer, dest_mac, &rxtx_buffer[ ARP_SRC_IP_P ] );
    1814:	a8 01       	movw	r20, r16
    1816:	44 5e       	subi	r20, 0xE4	; 228
    1818:	5f 4f       	sbci	r21, 0xFF	; 255
    181a:	c8 01       	movw	r24, r16
    181c:	b7 01       	movw	r22, r14
    181e:	0e 94 99 0b 	call	0x1732	; 0x1732 <arp_generate_packet>
	
	// send arp packet
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(ARP_PACKET) );
    1822:	c8 01       	movw	r24, r16
    1824:	6a e2       	ldi	r22, 0x2A	; 42
    1826:	70 e0       	ldi	r23, 0x00	; 0
    1828:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    182c:	1f 91       	pop	r17
    182e:	0f 91       	pop	r16
    1830:	ff 90       	pop	r15
    1832:	ef 90       	pop	r14
    1834:	08 95       	ret

00001836 <arp_send_request>:
// Function : arp_send_request
// Description : send arp request packet (who is?) to network.
//
//********************************************************************************************
void arp_send_request ( BYTE *rxtx_buffer, BYTE *dest_ip )
{
    1836:	cf 92       	push	r12
    1838:	df 92       	push	r13
    183a:	ef 92       	push	r14
    183c:	ff 92       	push	r15
    183e:	0f 93       	push	r16
    1840:	1f 93       	push	r17
    1842:	df 93       	push	r29
    1844:	cf 93       	push	r28
    1846:	00 d0       	rcall	.+0      	; 0x1848 <arp_send_request+0x12>
    1848:	00 d0       	rcall	.+0      	; 0x184a <arp_send_request+0x14>
    184a:	00 d0       	rcall	.+0      	; 0x184c <arp_send_request+0x16>
    184c:	cd b7       	in	r28, 0x3d	; 61
    184e:	de b7       	in	r29, 0x3e	; 62
    1850:	8c 01       	movw	r16, r24
    1852:	6b 01       	movw	r12, r22
	unsigned char i;
	MAC_ADDR dest_mac;

	// generate ethernet header
	for ( i=0; i<sizeof(MAC_ADDR); i++)
		dest_mac.byte[i] = 0xff;
    1854:	8f ef       	ldi	r24, 0xFF	; 255
    1856:	89 83       	std	Y+1, r24	; 0x01
    1858:	8a 83       	std	Y+2, r24	; 0x02
    185a:	8b 83       	std	Y+3, r24	; 0x03
    185c:	8c 83       	std	Y+4, r24	; 0x04
    185e:	8d 83       	std	Y+5, r24	; 0x05
    1860:	8e 83       	std	Y+6, r24	; 0x06
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_ARP_V}, (BYTE*)&dest_mac );
    1862:	c8 01       	movw	r24, r16
    1864:	66 e0       	ldi	r22, 0x06	; 6
    1866:	78 e0       	ldi	r23, 0x08	; 8
    1868:	7e 01       	movw	r14, r28
    186a:	08 94       	sec
    186c:	e1 1c       	adc	r14, r1
    186e:	f1 1c       	adc	r15, r1
    1870:	a7 01       	movw	r20, r14
    1872:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <eth_generate_header>

	// generate arp packet
	for ( i=0; i<sizeof(MAC_ADDR); i++)
		dest_mac.byte[i] = 0x00;
    1876:	19 82       	std	Y+1, r1	; 0x01
    1878:	1a 82       	std	Y+2, r1	; 0x02
    187a:	1b 82       	std	Y+3, r1	; 0x03
    187c:	1c 82       	std	Y+4, r1	; 0x04
    187e:	1d 82       	std	Y+5, r1	; 0x05
    1880:	1e 82       	std	Y+6, r1	; 0x06
	
	// set arp opcode is request
	rxtx_buffer[ ARP_OPCODE_H_P ] = ARP_OPCODE_REQUEST_H_V;
    1882:	f8 01       	movw	r30, r16
    1884:	14 8a       	std	Z+20, r1	; 0x14
	rxtx_buffer[ ARP_OPCODE_L_P ] = ARP_OPCODE_REQUEST_L_V;
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	85 8b       	std	Z+21, r24	; 0x15
	arp_generate_packet ( rxtx_buffer, (BYTE*)&dest_mac, dest_ip );
    188a:	c8 01       	movw	r24, r16
    188c:	b7 01       	movw	r22, r14
    188e:	a6 01       	movw	r20, r12
    1890:	0e 94 99 0b 	call	0x1732	; 0x1732 <arp_generate_packet>
	
	// send arp packet to network
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(ARP_PACKET) );
    1894:	c8 01       	movw	r24, r16
    1896:	6a e2       	ldi	r22, 0x2A	; 42
    1898:	70 e0       	ldi	r23, 0x00	; 0
    189a:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    189e:	26 96       	adiw	r28, 0x06	; 6
    18a0:	0f b6       	in	r0, 0x3f	; 63
    18a2:	f8 94       	cli
    18a4:	de bf       	out	0x3e, r29	; 62
    18a6:	0f be       	out	0x3f, r0	; 63
    18a8:	cd bf       	out	0x3d, r28	; 61
    18aa:	cf 91       	pop	r28
    18ac:	df 91       	pop	r29
    18ae:	1f 91       	pop	r17
    18b0:	0f 91       	pop	r16
    18b2:	ff 90       	pop	r15
    18b4:	ef 90       	pop	r14
    18b6:	df 90       	pop	r13
    18b8:	cf 90       	pop	r12
    18ba:	08 95       	ret

000018bc <arp_who_is>:
// Description : send arp request to destination ip, and save destination mac to dest_mac.
// call this function to find the destination mac address before send other packet.
//
//*******************************************************************************************
BYTE arp_who_is ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    18bc:	ff 92       	push	r15
    18be:	0f 93       	push	r16
    18c0:	1f 93       	push	r17
    18c2:	cf 93       	push	r28
    18c4:	df 93       	push	r29
    18c6:	ec 01       	movw	r28, r24
    18c8:	06 2f       	mov	r16, r22
    18ca:	f7 2e       	mov	r15, r23
	BYTE i;
	WORD dlength;

	// send arp request packet to network
	arp_send_request ( rxtx_buffer, dest_ip );
    18cc:	ba 01       	movw	r22, r20
    18ce:	0e 94 1b 0c 	call	0x1836	; 0x1836 <arp_send_request>
    18d2:	10 e0       	ldi	r17, 0x00	; 0

	for ( i=0; i<10; i++ )
	{
		// Time out 10x10ms = 100ms
		_delay_ms ( 10 );
    18d4:	8a e0       	ldi	r24, 0x0A	; 10
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>
		dlength = enc28j60_packet_receive( rxtx_buffer, MAX_RXTX_BUFFER );
    18dc:	ce 01       	movw	r24, r28
    18de:	6c ed       	ldi	r22, 0xDC	; 220
    18e0:	75 e0       	ldi	r23, 0x05	; 5
    18e2:	0e 94 82 05 	call	0xb04	; 0xb04 <enc28j60_packet_receive>

		// destination ip address was found on network
		if ( dlength )
    18e6:	89 2b       	or	r24, r25
    18e8:	a1 f0       	breq	.+40     	; 0x1912 <arp_who_is+0x56>
		{
			if ( arp_packet_is_arp ( rxtx_buffer, (WORD_BYTES){ARP_OPCODE_REPLY_V} ) )
    18ea:	ce 01       	movw	r24, r28
    18ec:	62 e0       	ldi	r22, 0x02	; 2
    18ee:	70 e0       	ldi	r23, 0x00	; 0
    18f0:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <arp_packet_is_arp>
    18f4:	88 23       	and	r24, r24
    18f6:	69 f0       	breq	.+26     	; 0x1912 <arp_who_is+0x56>
			{
				// copy destination mac address from arp reply packet to destination mac address
				memcpy ( dest_mac, &rxtx_buffer[ ETH_SRC_MAC_P ], sizeof(MAC_ADDR) );
    18f8:	80 2f       	mov	r24, r16
    18fa:	9f 2d       	mov	r25, r15
    18fc:	9c 01       	movw	r18, r24
    18fe:	d9 01       	movw	r26, r18
    1900:	fe 01       	movw	r30, r28
    1902:	36 96       	adiw	r30, 0x06	; 6
    1904:	86 e0       	ldi	r24, 0x06	; 6
    1906:	01 90       	ld	r0, Z+
    1908:	0d 92       	st	X+, r0
    190a:	81 50       	subi	r24, 0x01	; 1
    190c:	e1 f7       	brne	.-8      	; 0x1906 <arp_who_is+0x4a>
    190e:	81 e0       	ldi	r24, 0x01	; 1
    1910:	04 c0       	rjmp	.+8      	; 0x191a <arp_who_is+0x5e>
	WORD dlength;

	// send arp request packet to network
	arp_send_request ( rxtx_buffer, dest_ip );

	for ( i=0; i<10; i++ )
    1912:	1f 5f       	subi	r17, 0xFF	; 255
    1914:	1a 30       	cpi	r17, 0x0A	; 10
    1916:	f1 f6       	brne	.-68     	; 0x18d4 <arp_who_is+0x18>
    1918:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	// destination ip was not found on network
	return 0;
}
    191a:	df 91       	pop	r29
    191c:	cf 91       	pop	r28
    191e:	1f 91       	pop	r17
    1920:	0f 91       	pop	r16
    1922:	ff 90       	pop	r15
    1924:	08 95       	ret

00001926 <tcp_get_dlength>:
// Function : tcp_get_dlength
// Description : claculate tcp received data length
//
//*****************************************************************************************
WORD tcp_get_dlength ( BYTE *rxtx_buffer )
{
    1926:	fc 01       	movw	r30, r24
	int dlength, hlength;

	dlength = ( rxtx_buffer[ IP_TOTLEN_H_P ] <<8 ) | ( rxtx_buffer[ IP_TOTLEN_L_P ] );
	dlength -= sizeof(IP_HEADER);
    1928:	90 89       	ldd	r25, Z+16	; 0x10
    192a:	80 e0       	ldi	r24, 0x00	; 0
    192c:	21 89       	ldd	r18, Z+17	; 0x11
    192e:	30 e0       	ldi	r19, 0x00	; 0
    1930:	28 2b       	or	r18, r24
    1932:	39 2b       	or	r19, r25
    1934:	24 51       	subi	r18, 0x14	; 20
    1936:	30 40       	sbci	r19, 0x00	; 0
	hlength = (rxtx_buffer[ TCP_HEADER_LEN_P ]>>4) * 4; // generate len in bytes;
	dlength -= hlength;
    1938:	86 a5       	ldd	r24, Z+46	; 0x2e
    193a:	82 95       	swap	r24
    193c:	8f 70       	andi	r24, 0x0F	; 15
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	88 0f       	add	r24, r24
    1942:	99 1f       	adc	r25, r25
    1944:	88 0f       	add	r24, r24
    1946:	99 1f       	adc	r25, r25
    1948:	28 1b       	sub	r18, r24
    194a:	39 0b       	sbc	r19, r25
    194c:	37 ff       	sbrs	r19, 7
    194e:	02 c0       	rjmp	.+4      	; 0x1954 <tcp_get_dlength+0x2e>
    1950:	20 e0       	ldi	r18, 0x00	; 0
    1952:	30 e0       	ldi	r19, 0x00	; 0
	if ( dlength <= 0 )
		dlength=0;
	
	return ((WORD)dlength);
}
    1954:	c9 01       	movw	r24, r18
    1956:	08 95       	ret

00001958 <tcp_get_hlength>:
// Function : tcp_get_hlength
// Description : claculate tcp received header length
//
//*****************************************************************************************
BYTE tcp_get_hlength ( BYTE *rxtx_buffer )
{
    1958:	fc 01       	movw	r30, r24
    195a:	86 a5       	ldd	r24, Z+46	; 0x2e
    195c:	82 95       	swap	r24
    195e:	8f 70       	andi	r24, 0x0F	; 15
	return ((rxtx_buffer[ TCP_HEADER_LEN_P ]>>4) * 4); // generate len in bytes;
}
    1960:	88 0f       	add	r24, r24
    1962:	88 0f       	add	r24, r24
    1964:	08 95       	ret

00001966 <tcp_puts_data_p>:
// Function : tcp_puts_data_p
// Description : puts data from program memory to tx buffer
//
//********************************************************************************************
WORD tcp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
    1966:	4a 5c       	subi	r20, 0xCA	; 202
    1968:	5f 4f       	sbci	r21, 0xFF	; 255
    196a:	dc 01       	movw	r26, r24
    196c:	a4 0f       	add	r26, r20
    196e:	b5 1f       	adc	r27, r21
    1970:	46 53       	subi	r20, 0x36	; 54
    1972:	50 40       	sbci	r21, 0x00	; 0
    1974:	03 c0       	rjmp	.+6      	; 0x197c <tcp_puts_data_p+0x16>
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
	{
		rxtx_buffer[ TCP_DATA_P + offset ] = ch;
    1976:	8d 93       	st	X+, r24
		offset++;
    1978:	4f 5f       	subi	r20, 0xFF	; 255
    197a:	5f 4f       	sbci	r21, 0xFF	; 255
    197c:	fb 01       	movw	r30, r22
//********************************************************************************************
WORD tcp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
    197e:	6f 5f       	subi	r22, 0xFF	; 255
    1980:	7f 4f       	sbci	r23, 0xFF	; 255
    1982:	84 91       	lpm	r24, Z+
    1984:	88 23       	and	r24, r24
    1986:	b9 f7       	brne	.-18     	; 0x1976 <tcp_puts_data_p+0x10>
		rxtx_buffer[ TCP_DATA_P + offset ] = ch;
		offset++;
	}

	return offset;
}
    1988:	ca 01       	movw	r24, r20
    198a:	08 95       	ret

0000198c <tcp_puts_data>:
// Function : tcp_puts_data
// Description : puts data from RAM to tx buffer
//
//********************************************************************************************
WORD tcp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
    198c:	fb 01       	movw	r30, r22
    198e:	4a 5c       	subi	r20, 0xCA	; 202
    1990:	5f 4f       	sbci	r21, 0xFF	; 255
    1992:	dc 01       	movw	r26, r24
    1994:	a4 0f       	add	r26, r20
    1996:	b5 1f       	adc	r27, r21
    1998:	46 53       	subi	r20, 0x36	; 54
    199a:	50 40       	sbci	r21, 0x00	; 0
    199c:	04 c0       	rjmp	.+8      	; 0x19a6 <tcp_puts_data+0x1a>
	while( *data )
	{
		rxtx_buffer[ TCP_DATA_P + offset ] = *data++;
    199e:	8d 93       	st	X+, r24
    19a0:	31 96       	adiw	r30, 0x01	; 1
		offset++;
    19a2:	4f 5f       	subi	r20, 0xFF	; 255
    19a4:	5f 4f       	sbci	r21, 0xFF	; 255
// Description : puts data from RAM to tx buffer
//
//********************************************************************************************
WORD tcp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
	while( *data )
    19a6:	80 81       	ld	r24, Z
    19a8:	88 23       	and	r24, r24
    19aa:	c9 f7       	brne	.-14     	; 0x199e <tcp_puts_data+0x12>
		rxtx_buffer[ TCP_DATA_P + offset ] = *data++;
		offset++;
	}

	return offset;
}
    19ac:	ca 01       	movw	r24, r20
    19ae:	08 95       	ret

000019b0 <tcp_send_packet>:
	BYTE clear_seqack,
	WORD next_ack_num,
	WORD dlength,
	BYTE *dest_mac,
	BYTE *dest_ip )
{
    19b0:	2f 92       	push	r2
    19b2:	3f 92       	push	r3
    19b4:	4f 92       	push	r4
    19b6:	5f 92       	push	r5
    19b8:	6f 92       	push	r6
    19ba:	7f 92       	push	r7
    19bc:	8f 92       	push	r8
    19be:	9f 92       	push	r9
    19c0:	af 92       	push	r10
    19c2:	bf 92       	push	r11
    19c4:	cf 92       	push	r12
    19c6:	df 92       	push	r13
    19c8:	ef 92       	push	r14
    19ca:	ff 92       	push	r15
    19cc:	0f 93       	push	r16
    19ce:	1f 93       	push	r17
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	0f 92       	push	r0
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    19da:	3c 01       	movw	r6, r24
    19dc:	26 2e       	mov	r2, r22
    19de:	47 2e       	mov	r4, r23
    19e0:	49 83       	std	Y+1, r20	; 0x01
    19e2:	35 2e       	mov	r3, r21
    19e4:	52 2e       	mov	r5, r18
    19e6:	f0 2e       	mov	r15, r16
    19e8:	85 01       	movw	r16, r10
    19ea:	a4 01       	movw	r20, r8
	BYTE i, tseq;
	WORD_BYTES ck;
	
	// generate ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );		
    19ec:	60 e0       	ldi	r22, 0x00	; 0
    19ee:	78 e0       	ldi	r23, 0x08	; 8
    19f0:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <eth_generate_header>

	// sequence numbers:
	// add the rel ack num to SEQACK
	if ( next_ack_num )
    19f4:	c1 14       	cp	r12, r1
    19f6:	d1 04       	cpc	r13, r1
    19f8:	89 f0       	breq	.+34     	; 0x1a1c <tcp_send_packet+0x6c>
    19fa:	f3 01       	movw	r30, r6
    19fc:	b9 96       	adiw	r30, 0x29	; 41
    19fe:	34 e0       	ldi	r19, 0x04	; 4
	{
		for( i=4; i>0; i-- )
		{
			next_ack_num = rxtx_buffer [ TCP_SEQ_P + i - 1] + next_ack_num;
    1a00:	80 81       	ld	r24, Z
    1a02:	a6 01       	movw	r20, r12
    1a04:	48 0f       	add	r20, r24
    1a06:	51 1d       	adc	r21, r1
    1a08:	ca 01       	movw	r24, r20
			tseq = rxtx_buffer [ TCP_SEQACK_P + i - 1];
    1a0a:	24 81       	ldd	r18, Z+4	; 0x04
			rxtx_buffer [ TCP_SEQACK_P + i - 1] = 0xff & next_ack_num;
    1a0c:	44 83       	std	Z+4, r20	; 0x04

			// copy the acknum sent to us into the sequence number
			rxtx_buffer[ TCP_SEQ_P + i - 1 ] = tseq;
    1a0e:	20 83       	st	Z, r18

			next_ack_num >>= 8;
    1a10:	c9 2e       	mov	r12, r25
    1a12:	dd 24       	eor	r13, r13

	// sequence numbers:
	// add the rel ack num to SEQACK
	if ( next_ack_num )
	{
		for( i=4; i>0; i-- )
    1a14:	31 50       	subi	r19, 0x01	; 1
    1a16:	31 97       	sbiw	r30, 0x01	; 1
    1a18:	33 23       	and	r19, r19
    1a1a:	91 f7       	brne	.-28     	; 0x1a00 <tcp_send_packet+0x50>
	}
	
	// initial tcp sequence number
	// setup maximum segment size
	// require to setup first packet is receive or transmit only
	if ( max_segment_size )
    1a1c:	ff 20       	and	r15, r15
    1a1e:	b9 f0       	breq	.+46     	; 0x1a4e <tcp_send_packet+0x9e>
	{
		// initial sequence number
		rxtx_buffer[ TCP_SEQ_P + 0 ] = 0;
    1a20:	f3 01       	movw	r30, r6
    1a22:	16 a2       	std	Z+38, r1	; 0x26
		rxtx_buffer[ TCP_SEQ_P + 1 ] = 0;
    1a24:	17 a2       	std	Z+39, r1	; 0x27
		rxtx_buffer[ TCP_SEQ_P + 2 ] = seqnum;
    1a26:	80 91 60 00 	lds	r24, 0x0060
    1a2a:	80 a7       	std	Z+40, r24	; 0x28
		rxtx_buffer[ TCP_SEQ_P + 3 ] = 0;
    1a2c:	11 a6       	std	Z+41, r1	; 0x29
		seqnum += 2;
    1a2e:	8e 5f       	subi	r24, 0xFE	; 254
    1a30:	80 93 60 00 	sts	0x0060, r24

		// setup maximum segment size
		rxtx_buffer[ TCP_OPTIONS_P + 0 ] = 2;
    1a34:	82 e0       	ldi	r24, 0x02	; 2
    1a36:	86 ab       	std	Z+54, r24	; 0x36
		rxtx_buffer[ TCP_OPTIONS_P + 1 ] = 4;
    1a38:	84 e0       	ldi	r24, 0x04	; 4
    1a3a:	87 ab       	std	Z+55, r24	; 0x37
		rxtx_buffer[ TCP_OPTIONS_P + 2 ] = HIGH(1408);
    1a3c:	85 e0       	ldi	r24, 0x05	; 5
    1a3e:	80 af       	std	Z+56, r24	; 0x38
		rxtx_buffer[ TCP_OPTIONS_P + 3 ] = LOW(1408);
    1a40:	80 e8       	ldi	r24, 0x80	; 128
    1a42:	81 af       	std	Z+57, r24	; 0x39
		// setup tcp header length 24 bytes: 6*32/8 = 24
		rxtx_buffer[ TCP_HEADER_LEN_P ] = 0x60;
    1a44:	80 e6       	ldi	r24, 0x60	; 96
    1a46:	86 a7       	std	Z+46, r24	; 0x2e
		dlength += 4;
    1a48:	0c 5f       	subi	r16, 0xFC	; 252
    1a4a:	1f 4f       	sbci	r17, 0xFF	; 255
    1a4c:	03 c0       	rjmp	.+6      	; 0x1a54 <tcp_send_packet+0xa4>
	}
	else
	{
		// no options: 20 bytes: 5*32/8 = 20
		rxtx_buffer[ TCP_HEADER_LEN_P ] = 0x50;
    1a4e:	80 e5       	ldi	r24, 0x50	; 80
    1a50:	f3 01       	movw	r30, r6
    1a52:	86 a7       	std	Z+46, r24	; 0x2e
	}

	// generate ip header and checksum
	ip_generate_header ( rxtx_buffer, (WORD_BYTES){(sizeof(IP_HEADER) + sizeof(TCP_HEADER) + dlength)}, IP_PROTO_TCP_V, dest_ip );
    1a54:	b8 01       	movw	r22, r16
    1a56:	68 5d       	subi	r22, 0xD8	; 216
    1a58:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5a:	c3 01       	movw	r24, r6
    1a5c:	46 e0       	ldi	r20, 0x06	; 6
    1a5e:	2e 89       	ldd	r18, Y+22	; 0x16
    1a60:	3f 89       	ldd	r19, Y+23	; 0x17
    1a62:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <ip_generate_header>
	
	// clear sequence ack number before send tcp SYN packet
	if ( clear_seqack )
    1a66:	ee 20       	and	r14, r14
    1a68:	29 f0       	breq	.+10     	; 0x1a74 <tcp_send_packet+0xc4>
	{
		rxtx_buffer[ TCP_SEQACK_P + 0 ] = 0;
    1a6a:	f3 01       	movw	r30, r6
    1a6c:	12 a6       	std	Z+42, r1	; 0x2a
		rxtx_buffer[ TCP_SEQACK_P + 1 ] = 0;
    1a6e:	13 a6       	std	Z+43, r1	; 0x2b
		rxtx_buffer[ TCP_SEQACK_P + 2 ] = 0;
    1a70:	14 a6       	std	Z+44, r1	; 0x2c
		rxtx_buffer[ TCP_SEQACK_P + 3 ] = 0;
    1a72:	15 a6       	std	Z+45, r1	; 0x2d
	}
		
	// setup tcp flags
	rxtx_buffer [ TCP_FLAGS_P ] = flags;
    1a74:	f3 01       	movw	r30, r6
    1a76:	57 a6       	std	Z+47, r5	; 0x2f
	
	// setup destination port
	rxtx_buffer [ TCP_DST_PORT_H_P ] = dest_port.byte.high;
    1a78:	44 a2       	std	Z+36, r4	; 0x24
	rxtx_buffer [ TCP_DST_PORT_L_P ] = dest_port.byte.low;
    1a7a:	25 a2       	std	Z+37, r2	; 0x25

	// setup source port
	rxtx_buffer [ TCP_SRC_PORT_H_P ] = src_port.byte.high;
    1a7c:	32 a2       	std	Z+34, r3	; 0x22
	rxtx_buffer [ TCP_SRC_PORT_L_P ] = src_port.byte.low;
    1a7e:	49 81       	ldd	r20, Y+1	; 0x01
    1a80:	43 a3       	std	Z+35, r20	; 0x23

	// setup maximum windows size
	rxtx_buffer [ TCP_WINDOWSIZE_H_P ] = HIGH((MAX_RX_BUFFER-sizeof(IP_HEADER)-sizeof(ETH_HEADER)));
    1a82:	85 e0       	ldi	r24, 0x05	; 5
    1a84:	80 ab       	std	Z+48, r24	; 0x30
	rxtx_buffer [ TCP_WINDOWSIZE_L_P ] = LOW((MAX_RX_BUFFER-sizeof(IP_HEADER)-sizeof(ETH_HEADER)));
    1a86:	8a eb       	ldi	r24, 0xBA	; 186
    1a88:	81 ab       	std	Z+49, r24	; 0x31
	
	// setup urgend pointer (not used -> 0)
	rxtx_buffer[ TCP_URGENT_PTR_H_P ] = 0;
    1a8a:	14 aa       	std	Z+52, r1	; 0x34
	rxtx_buffer[ TCP_URGENT_PTR_L_P ] = 0;
    1a8c:	15 aa       	std	Z+53, r1	; 0x35

	// clear old checksum and calculate new checksum
	rxtx_buffer[ TCP_CHECKSUM_H_P ] = 0;
    1a8e:	12 aa       	std	Z+50, r1	; 0x32
	rxtx_buffer[ TCP_CHECKSUM_L_P ] = 0;
    1a90:	13 aa       	std	Z+51, r1	; 0x33
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	// +                                     Destination IP address                                    +
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	// +           0           +      IP Protocol      +                    Total length               +
	// +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	ck.word = software_checksum( &rxtx_buffer[IP_SRC_IP_P], sizeof(TCP_HEADER)+dlength+8, IP_PROTO_TCP_V + sizeof(TCP_HEADER) + dlength );
    1a92:	06 5e       	subi	r16, 0xE6	; 230
    1a94:	1f 4f       	sbci	r17, 0xFF	; 255
    1a96:	98 01       	movw	r18, r16
    1a98:	40 e0       	ldi	r20, 0x00	; 0
    1a9a:	50 e0       	ldi	r21, 0x00	; 0
    1a9c:	c3 01       	movw	r24, r6
    1a9e:	4a 96       	adiw	r24, 0x1a	; 26
    1aa0:	0e 5f       	subi	r16, 0xFE	; 254
    1aa2:	1f 4f       	sbci	r17, 0xFF	; 255
    1aa4:	b8 01       	movw	r22, r16
    1aa6:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <software_checksum>
	rxtx_buffer[ TCP_CHECKSUM_H_P ] = ck.byte.high;
    1aaa:	f3 01       	movw	r30, r6
    1aac:	92 ab       	std	Z+50, r25	; 0x32
	rxtx_buffer[ TCP_CHECKSUM_L_P ] = ck.byte.low;
    1aae:	83 ab       	std	Z+51, r24	; 0x33

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+dlength );
    1ab0:	06 5e       	subi	r16, 0xE6	; 230
    1ab2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ab4:	c3 01       	movw	r24, r6
    1ab6:	b8 01       	movw	r22, r16
    1ab8:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    1abc:	0f 90       	pop	r0
    1abe:	cf 91       	pop	r28
    1ac0:	df 91       	pop	r29
    1ac2:	1f 91       	pop	r17
    1ac4:	0f 91       	pop	r16
    1ac6:	ff 90       	pop	r15
    1ac8:	ef 90       	pop	r14
    1aca:	df 90       	pop	r13
    1acc:	cf 90       	pop	r12
    1ace:	bf 90       	pop	r11
    1ad0:	af 90       	pop	r10
    1ad2:	9f 90       	pop	r9
    1ad4:	8f 90       	pop	r8
    1ad6:	7f 90       	pop	r7
    1ad8:	6f 90       	pop	r6
    1ada:	5f 90       	pop	r5
    1adc:	4f 90       	pop	r4
    1ade:	3f 90       	pop	r3
    1ae0:	2f 90       	pop	r2
    1ae2:	08 95       	ret

00001ae4 <ip_packet_is_ip>:
// Function : ip_check_ip
// Description : Check incoming packet
//
//********************************************************************************************
BYTE ip_packet_is_ip ( BYTE *rxtx_buffer )
{
    1ae4:	fc 01       	movw	r30, r24
	unsigned char i;
	
	// if ethernet type is not ip
	if ( rxtx_buffer[ ETH_TYPE_H_P ] != ETH_TYPE_IP_H_V || rxtx_buffer[ ETH_TYPE_L_P ] != ETH_TYPE_IP_L_V)
    1ae6:	84 85       	ldd	r24, Z+12	; 0x0c
    1ae8:	88 30       	cpi	r24, 0x08	; 8
    1aea:	a1 f4       	brne	.+40     	; 0x1b14 <ip_packet_is_ip+0x30>
    1aec:	85 85       	ldd	r24, Z+13	; 0x0d
    1aee:	88 23       	and	r24, r24
    1af0:	89 f4       	brne	.+34     	; 0x1b14 <ip_packet_is_ip+0x30>
    1af2:	df 01       	movw	r26, r30
    1af4:	e5 ec       	ldi	r30, 0xC5	; 197
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
		return 0;
	
	// if ip packet not send to avr
	for ( i=0; i<sizeof(IP_ADDR); i++ )
	{
		if ( rxtx_buffer[ IP_DST_IP_P + i ] != avr_ip.byte[i] )
    1af8:	5e 96       	adiw	r26, 0x1e	; 30
    1afa:	9c 91       	ld	r25, X
    1afc:	5e 97       	sbiw	r26, 0x1e	; 30
    1afe:	80 81       	ld	r24, Z
    1b00:	98 17       	cp	r25, r24
    1b02:	41 f4       	brne	.+16     	; 0x1b14 <ip_packet_is_ip+0x30>
    1b04:	11 96       	adiw	r26, 0x01	; 1
    1b06:	31 96       	adiw	r30, 0x01	; 1
	// if ethernet type is not ip
	if ( rxtx_buffer[ ETH_TYPE_H_P ] != ETH_TYPE_IP_H_V || rxtx_buffer[ ETH_TYPE_L_P ] != ETH_TYPE_IP_L_V)
		return 0;
	
	// if ip packet not send to avr
	for ( i=0; i<sizeof(IP_ADDR); i++ )
    1b08:	80 e0       	ldi	r24, 0x00	; 0
    1b0a:	e9 3c       	cpi	r30, 0xC9	; 201
    1b0c:	f8 07       	cpc	r31, r24
    1b0e:	a1 f7       	brne	.-24     	; 0x1af8 <ip_packet_is_ip+0x14>
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	08 95       	ret
    1b14:	80 e0       	ldi	r24, 0x00	; 0
			return 0;
	}
	
	// destination ip address match with avr ip address
	return 1;
}
    1b16:	08 95       	ret

00001b18 <ip_generate_header>:
// Function : ip_generate_packet
// Description : generate all ip header
//
//********************************************************************************************
void ip_generate_header ( BYTE *rxtx_buffer, WORD_BYTES total_length, BYTE protocol, BYTE *dest_ip )
{
    1b18:	0f 93       	push	r16
    1b1a:	1f 93       	push	r17
    1b1c:	cf 93       	push	r28
    1b1e:	df 93       	push	r29
    1b20:	ec 01       	movw	r28, r24
	BYTE i;
	WORD_BYTES ck;
	
	// set ipv4 and header length
	rxtx_buffer[ IP_P ] = IP_V4_V | IP_HEADER_LENGTH_V;
    1b22:	8c 01       	movw	r16, r24
    1b24:	02 5f       	subi	r16, 0xF2	; 242
    1b26:	1f 4f       	sbci	r17, 0xFF	; 255
    1b28:	85 e4       	ldi	r24, 0x45	; 69
    1b2a:	8e 87       	std	Y+14, r24	; 0x0e

	// set TOS to default 0x00
	rxtx_buffer[ IP_TOS_P ] = 0x00;
    1b2c:	1f 86       	std	Y+15, r1	; 0x0f

	// set total length
	rxtx_buffer [ IP_TOTLEN_H_P ] = total_length.byte.high;
    1b2e:	78 8b       	std	Y+16, r23	; 0x10
	rxtx_buffer [ IP_TOTLEN_L_P ] = total_length.byte.low;
    1b30:	69 8b       	std	Y+17, r22	; 0x11
	
	// set packet identification
	rxtx_buffer [ IP_ID_H_P ] = ip_identfier.byte.high;
    1b32:	80 91 62 00 	lds	r24, 0x0062
    1b36:	8a 8b       	std	Y+18, r24	; 0x12
	rxtx_buffer [ IP_ID_L_P ] = ip_identfier.byte.low;
    1b38:	80 91 61 00 	lds	r24, 0x0061
    1b3c:	8b 8b       	std	Y+19, r24	; 0x13
	ip_identfier.word++;
    1b3e:	80 91 61 00 	lds	r24, 0x0061
    1b42:	90 91 62 00 	lds	r25, 0x0062
    1b46:	01 96       	adiw	r24, 0x01	; 1
    1b48:	90 93 62 00 	sts	0x0062, r25
    1b4c:	80 93 61 00 	sts	0x0061, r24
	
	// set fragment flags	
	rxtx_buffer [ IP_FLAGS_H_P ] = 0x00;
    1b50:	1c 8a       	std	Y+20, r1	; 0x14
	rxtx_buffer [ IP_FLAGS_L_P ] = 0x00;
    1b52:	1d 8a       	std	Y+21, r1	; 0x15
	
	// set Time To Live
	rxtx_buffer [ IP_TTL_P ] = 128;
    1b54:	80 e8       	ldi	r24, 0x80	; 128
    1b56:	8e 8b       	std	Y+22, r24	; 0x16
	
	// set ip packettype to tcp/udp/icmp...
	rxtx_buffer [ IP_PROTO_P ] = protocol;
    1b58:	4f 8b       	std	Y+23, r20	; 0x17
    1b5a:	de 01       	movw	r26, r28
    1b5c:	40 e0       	ldi	r20, 0x00	; 0
    1b5e:	50 e0       	ldi	r21, 0x00	; 0
	
	// set source and destination ip address
	for ( i=0; i<4; i++ )
	{
		rxtx_buffer[ IP_DST_IP_P + i ] = dest_ip[i];
    1b60:	f9 01       	movw	r30, r18
    1b62:	e4 0f       	add	r30, r20
    1b64:	f5 1f       	adc	r31, r21
    1b66:	80 81       	ld	r24, Z
    1b68:	5e 96       	adiw	r26, 0x1e	; 30
    1b6a:	8c 93       	st	X, r24
    1b6c:	5e 97       	sbiw	r26, 0x1e	; 30
		rxtx_buffer[ IP_SRC_IP_P + i ] = avr_ip.byte[ i ];
    1b6e:	fa 01       	movw	r30, r20
    1b70:	eb 53       	subi	r30, 0x3B	; 59
    1b72:	ff 4f       	sbci	r31, 0xFF	; 255
    1b74:	80 81       	ld	r24, Z
    1b76:	5a 96       	adiw	r26, 0x1a	; 26
    1b78:	8c 93       	st	X, r24
    1b7a:	5a 97       	sbiw	r26, 0x1a	; 26
    1b7c:	4f 5f       	subi	r20, 0xFF	; 255
    1b7e:	5f 4f       	sbci	r21, 0xFF	; 255
    1b80:	11 96       	adiw	r26, 0x01	; 1
	
	// set ip packettype to tcp/udp/icmp...
	rxtx_buffer [ IP_PROTO_P ] = protocol;
	
	// set source and destination ip address
	for ( i=0; i<4; i++ )
    1b82:	44 30       	cpi	r20, 0x04	; 4
    1b84:	51 05       	cpc	r21, r1
    1b86:	61 f7       	brne	.-40     	; 0x1b60 <ip_generate_header+0x48>
		rxtx_buffer[ IP_DST_IP_P + i ] = dest_ip[i];
		rxtx_buffer[ IP_SRC_IP_P + i ] = avr_ip.byte[ i ];
	}
	
	// clear the 2 byte checksum
	rxtx_buffer[ IP_CHECKSUM_H_P ] = 0;
    1b88:	18 8e       	std	Y+24, r1	; 0x18
	rxtx_buffer[ IP_CHECKSUM_L_P ] = 0;
    1b8a:	19 8e       	std	Y+25, r1	; 0x19

	// fill checksum value
	// calculate the checksum:
	ck.word = software_checksum ( &rxtx_buffer[ IP_P ], sizeof(IP_HEADER), 0 );
    1b8c:	c8 01       	movw	r24, r16
    1b8e:	64 e1       	ldi	r22, 0x14	; 20
    1b90:	70 e0       	ldi	r23, 0x00	; 0
    1b92:	20 e0       	ldi	r18, 0x00	; 0
    1b94:	30 e0       	ldi	r19, 0x00	; 0
    1b96:	40 e0       	ldi	r20, 0x00	; 0
    1b98:	50 e0       	ldi	r21, 0x00	; 0
    1b9a:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <software_checksum>
	rxtx_buffer[ IP_CHECKSUM_H_P ] = ck.byte.high;
    1b9e:	98 8f       	std	Y+24, r25	; 0x18
	rxtx_buffer[ IP_CHECKSUM_L_P ] = ck.byte.low;
    1ba0:	89 8f       	std	Y+25, r24	; 0x19
}
    1ba2:	df 91       	pop	r29
    1ba4:	cf 91       	pop	r28
    1ba6:	1f 91       	pop	r17
    1ba8:	0f 91       	pop	r16
    1baa:	08 95       	ret

00001bac <eth_generate_header>:
// Description : generarete ethernet header, contain destination and source MAC address,
// ethernet type.
//
//********************************************************************************************
void eth_generate_header ( BYTE *rxtx_buffer, WORD_BYTES type, BYTE *dest_mac )
{
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	ec 01       	movw	r28, r24
    1bb2:	dc 01       	movw	r26, r24
    1bb4:	20 e0       	ldi	r18, 0x00	; 0
    1bb6:	30 e0       	ldi	r19, 0x00	; 0
	BYTE i;
	//copy the destination mac from the source and fill my mac into src
	for ( i=0; i<sizeof(MAC_ADDR); i++)
	{
		rxtx_buffer[ ETH_DST_MAC_P + i ] = dest_mac[i];
    1bb8:	fa 01       	movw	r30, r20
    1bba:	e2 0f       	add	r30, r18
    1bbc:	f3 1f       	adc	r31, r19
    1bbe:	80 81       	ld	r24, Z
    1bc0:	8c 93       	st	X, r24
		rxtx_buffer[ ETH_SRC_MAC_P + i ] = avr_mac.byte[i];
    1bc2:	f9 01       	movw	r30, r18
    1bc4:	e5 54       	subi	r30, 0x45	; 69
    1bc6:	ff 4f       	sbci	r31, 0xFF	; 255
    1bc8:	80 81       	ld	r24, Z
    1bca:	16 96       	adiw	r26, 0x06	; 6
    1bcc:	8c 93       	st	X, r24
    1bce:	16 97       	sbiw	r26, 0x06	; 6
    1bd0:	2f 5f       	subi	r18, 0xFF	; 255
    1bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    1bd4:	11 96       	adiw	r26, 0x01	; 1
//********************************************************************************************
void eth_generate_header ( BYTE *rxtx_buffer, WORD_BYTES type, BYTE *dest_mac )
{
	BYTE i;
	//copy the destination mac from the source and fill my mac into src
	for ( i=0; i<sizeof(MAC_ADDR); i++)
    1bd6:	26 30       	cpi	r18, 0x06	; 6
    1bd8:	31 05       	cpc	r19, r1
    1bda:	71 f7       	brne	.-36     	; 0x1bb8 <eth_generate_header+0xc>
	{
		rxtx_buffer[ ETH_DST_MAC_P + i ] = dest_mac[i];
		rxtx_buffer[ ETH_SRC_MAC_P + i ] = avr_mac.byte[i];
	}
	rxtx_buffer[ ETH_TYPE_H_P ] = type.byte.high;//HIGH(type);
    1bdc:	7c 87       	std	Y+12, r23	; 0x0c
	rxtx_buffer[ ETH_TYPE_L_P ] = type.byte.low;//LOW(type);
    1bde:	6d 87       	std	Y+13, r22	; 0x0d
}
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	08 95       	ret

00001be6 <software_checksum>:
// http://www.msc.uky.edu/ken/cs471/notes/chap3.htm
// The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
//
//********************************************************************************************
WORD software_checksum(BYTE *rxtx_buffer, WORD len, DWORD sum)
{
    1be6:	ef 92       	push	r14
    1be8:	ff 92       	push	r15
    1bea:	0f 93       	push	r16
    1bec:	1f 93       	push	r17
    1bee:	cf 93       	push	r28
    1bf0:	df 93       	push	r29
    1bf2:	7c 01       	movw	r14, r24
    1bf4:	8b 01       	movw	r16, r22
    1bf6:	ec 01       	movw	r28, r24
    1bf8:	0f c0       	rjmp	.+30     	; 0x1c18 <software_checksum+0x32>
	// build the sum of 16bit words
	while(len>1)
	{
		sum += 0xFFFF & (*rxtx_buffer<<8|*(rxtx_buffer+1));
    1bfa:	f8 81       	ld	r31, Y
    1bfc:	e0 e0       	ldi	r30, 0x00	; 0
    1bfe:	89 81       	ldd	r24, Y+1	; 0x01
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	8e 2b       	or	r24, r30
    1c04:	9f 2b       	or	r25, r31
    1c06:	a0 e0       	ldi	r26, 0x00	; 0
    1c08:	b0 e0       	ldi	r27, 0x00	; 0
    1c0a:	28 0f       	add	r18, r24
    1c0c:	39 1f       	adc	r19, r25
    1c0e:	4a 1f       	adc	r20, r26
    1c10:	5b 1f       	adc	r21, r27
		rxtx_buffer+=2;
    1c12:	22 96       	adiw	r28, 0x02	; 2
		len-=2;
    1c14:	62 50       	subi	r22, 0x02	; 2
    1c16:	70 40       	sbci	r23, 0x00	; 0
//
//********************************************************************************************
WORD software_checksum(BYTE *rxtx_buffer, WORD len, DWORD sum)
{
	// build the sum of 16bit words
	while(len>1)
    1c18:	62 30       	cpi	r22, 0x02	; 2
    1c1a:	71 05       	cpc	r23, r1
    1c1c:	70 f7       	brcc	.-36     	; 0x1bfa <software_checksum+0x14>
    1c1e:	f8 01       	movw	r30, r16
    1c20:	ee 7f       	andi	r30, 0xFE	; 254
    1c22:	ee 0d       	add	r30, r14
    1c24:	ff 1d       	adc	r31, r15
		sum += 0xFFFF & (*rxtx_buffer<<8|*(rxtx_buffer+1));
		rxtx_buffer+=2;
		len-=2;
	}
	// if there is a byte left then add it (padded with zero)
	if (len)
    1c26:	00 ff       	sbrs	r16, 0
    1c28:	0d c0       	rjmp	.+26     	; 0x1c44 <software_checksum+0x5e>
	{
		sum += (0xFF & *rxtx_buffer)<<8;
    1c2a:	90 81       	ld	r25, Z
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	aa 27       	eor	r26, r26
    1c30:	97 fd       	sbrc	r25, 7
    1c32:	a0 95       	com	r26
    1c34:	ba 2f       	mov	r27, r26
    1c36:	02 c0       	rjmp	.+4      	; 0x1c3c <software_checksum+0x56>
	}
	// now calculate the sum over the bytes in the sum
	// until the result is only 16bit long
	while (sum>>16)
	{
		sum = (sum & 0xFFFF)+(sum >> 16);
    1c38:	40 70       	andi	r20, 0x00	; 0
    1c3a:	50 70       	andi	r21, 0x00	; 0
    1c3c:	28 0f       	add	r18, r24
    1c3e:	39 1f       	adc	r19, r25
    1c40:	4a 1f       	adc	r20, r26
    1c42:	5b 1f       	adc	r21, r27
	{
		sum += (0xFF & *rxtx_buffer)<<8;
	}
	// now calculate the sum over the bytes in the sum
	// until the result is only 16bit long
	while (sum>>16)
    1c44:	ca 01       	movw	r24, r20
    1c46:	aa 27       	eor	r26, r26
    1c48:	bb 27       	eor	r27, r27
    1c4a:	00 97       	sbiw	r24, 0x00	; 0
    1c4c:	a1 05       	cpc	r26, r1
    1c4e:	b1 05       	cpc	r27, r1
    1c50:	99 f7       	brne	.-26     	; 0x1c38 <software_checksum+0x52>
    1c52:	20 95       	com	r18
    1c54:	30 95       	com	r19
	{
		sum = (sum & 0xFFFF)+(sum >> 16);
	}
	// build 1's complement:
	return( (WORD) sum ^ 0xFFFF);
}
    1c56:	c9 01       	movw	r24, r18
    1c58:	df 91       	pop	r29
    1c5a:	cf 91       	pop	r28
    1c5c:	1f 91       	pop	r17
    1c5e:	0f 91       	pop	r16
    1c60:	ff 90       	pop	r15
    1c62:	ef 90       	pop	r14
    1c64:	08 95       	ret

00001c66 <icmp_generate_packet>:
// Function : icmp_send_reply
// Description : Send ARP reply packet from ARP request packet
//
//*******************************************************************************************
void icmp_generate_packet ( BYTE *rxtx_buffer )
{
    1c66:	cf 93       	push	r28
    1c68:	df 93       	push	r29
    1c6a:	ec 01       	movw	r28, r24
	BYTE i;
	WORD_BYTES ck;
	
	// In send ICMP request case, generate new ICMP data.
	if ( rxtx_buffer[ ICMP_TYPE_P ] == ICMP_TYPE_ECHOREQUEST_V )
    1c6c:	9c 01       	movw	r18, r24
    1c6e:	2e 5d       	subi	r18, 0xDE	; 222
    1c70:	3f 4f       	sbci	r19, 0xFF	; 255
    1c72:	8a a1       	ldd	r24, Y+34	; 0x22
    1c74:	88 30       	cpi	r24, 0x08	; 8
    1c76:	39 f4       	brne	.+14     	; 0x1c86 <icmp_generate_packet+0x20>
    1c78:	fe 01       	movw	r30, r28
    1c7a:	ba 96       	adiw	r30, 0x2a	; 42
    1c7c:	81 e4       	ldi	r24, 0x41	; 65
	{
		for ( i=0; i<ICMP_MAX_DATA; i++ )
		{
			rxtx_buffer[ ICMP_DATA_P + i ] = 'A' + i;
    1c7e:	81 93       	st	Z+, r24
    1c80:	8f 5f       	subi	r24, 0xFF	; 255
	WORD_BYTES ck;
	
	// In send ICMP request case, generate new ICMP data.
	if ( rxtx_buffer[ ICMP_TYPE_P ] == ICMP_TYPE_ECHOREQUEST_V )
	{
		for ( i=0; i<ICMP_MAX_DATA; i++ )
    1c82:	81 36       	cpi	r24, 0x61	; 97
    1c84:	e1 f7       	brne	.-8      	; 0x1c7e <icmp_generate_packet+0x18>
		{
			rxtx_buffer[ ICMP_DATA_P + i ] = 'A' + i;
		}
	}
	// clear icmp checksum
	rxtx_buffer[ ICMP_CHECKSUM_H_P ] = 0;
    1c86:	1c a2       	std	Y+36, r1	; 0x24
	rxtx_buffer[ ICMP_CHECKSUM_L_P ] = 0;
    1c88:	1d a2       	std	Y+37, r1	; 0x25

	// calculate new checksum.
	// ICMP checksum calculation begin at ICMP type to ICMP data.
	// Before calculate new checksum the checksum field must be zero.
	ck.word = software_checksum ( &rxtx_buffer[ ICMP_TYPE_P ], sizeof(ICMP_PACKET), 0 );
    1c8a:	c9 01       	movw	r24, r18
    1c8c:	68 e2       	ldi	r22, 0x28	; 40
    1c8e:	70 e0       	ldi	r23, 0x00	; 0
    1c90:	20 e0       	ldi	r18, 0x00	; 0
    1c92:	30 e0       	ldi	r19, 0x00	; 0
    1c94:	40 e0       	ldi	r20, 0x00	; 0
    1c96:	50 e0       	ldi	r21, 0x00	; 0
    1c98:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <software_checksum>
	rxtx_buffer[ ICMP_CHECKSUM_H_P ] = ck.byte.high;
    1c9c:	9c a3       	std	Y+36, r25	; 0x24
	rxtx_buffer[ ICMP_CHECKSUM_L_P ] = ck.byte.low;
    1c9e:	8d a3       	std	Y+37, r24	; 0x25
}
    1ca0:	df 91       	pop	r29
    1ca2:	cf 91       	pop	r28
    1ca4:	08 95       	ret

00001ca6 <icmp_send_reply>:
// Function : icmp_send_reply
// Description : Send ARP reply packet to destination.
//
//*******************************************************************************************
BYTE icmp_send_reply ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1ca6:	0f 93       	push	r16
    1ca8:	1f 93       	push	r17
    1caa:	cf 93       	push	r28
    1cac:	df 93       	push	r29
    1cae:	ec 01       	movw	r28, r24
    1cb0:	9b 01       	movw	r18, r22
    1cb2:	8a 01       	movw	r16, r20
	
	// check protocol is icmp or not?
	if ( rxtx_buffer [ IP_PROTO_P ] != IP_PROTO_ICMP_V )
    1cb4:	8f 89       	ldd	r24, Y+23	; 0x17
    1cb6:	81 30       	cpi	r24, 0x01	; 1
    1cb8:	f9 f4       	brne	.+62     	; 0x1cf8 <icmp_send_reply+0x52>
		return 0;
	
	// check icmp packet type is echo request or not?
	if ( rxtx_buffer [ ICMP_TYPE_P ] != ICMP_TYPE_ECHOREQUEST_V )
    1cba:	8a a1       	ldd	r24, Y+34	; 0x22
    1cbc:	88 30       	cpi	r24, 0x08	; 8
    1cbe:	e1 f4       	brne	.+56     	; 0x1cf8 <icmp_send_reply+0x52>
		return 0;

	// set ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );
    1cc0:	ce 01       	movw	r24, r28
    1cc2:	60 e0       	ldi	r22, 0x00	; 0
    1cc4:	78 e0       	ldi	r23, 0x08	; 8
    1cc6:	a9 01       	movw	r20, r18
    1cc8:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <eth_generate_header>
	
	// generate ip header and checksum
	ip_generate_header ( rxtx_buffer, (WORD_BYTES){(rxtx_buffer[IP_TOTLEN_H_P]<<8)|rxtx_buffer[IP_TOTLEN_L_P]}, IP_PROTO_ICMP_V, dest_ip );
    1ccc:	78 89       	ldd	r23, Y+16	; 0x10
    1cce:	60 e0       	ldi	r22, 0x00	; 0
    1cd0:	89 89       	ldd	r24, Y+17	; 0x11
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	68 2b       	or	r22, r24
    1cd6:	79 2b       	or	r23, r25
    1cd8:	ce 01       	movw	r24, r28
    1cda:	41 e0       	ldi	r20, 0x01	; 1
    1cdc:	98 01       	movw	r18, r16
    1cde:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <ip_generate_header>

	// generate icmp packet
	rxtx_buffer[ ICMP_TYPE_P ] = ICMP_TYPE_ECHOREPLY_V;
    1ce2:	1a a2       	std	Y+34, r1	; 0x22
	icmp_generate_packet ( rxtx_buffer );
    1ce4:	ce 01       	movw	r24, r28
    1ce6:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <icmp_generate_packet>

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(IP_HEADER) + sizeof(ICMP_PACKET) );
    1cea:	ce 01       	movw	r24, r28
    1cec:	6a e4       	ldi	r22, 0x4A	; 74
    1cee:	70 e0       	ldi	r23, 0x00	; 0
    1cf0:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	01 c0       	rjmp	.+2      	; 0x1cfa <icmp_send_reply+0x54>
	return 1;
    1cf8:	80 e0       	ldi	r24, 0x00	; 0
}
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	1f 91       	pop	r17
    1d00:	0f 91       	pop	r16
    1d02:	08 95       	ret

00001d04 <icmp_send_request>:
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void icmp_send_request ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{	
    1d04:	ef 92       	push	r14
    1d06:	ff 92       	push	r15
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	8c 01       	movw	r16, r24
    1d0e:	9b 01       	movw	r18, r22
    1d10:	7a 01       	movw	r14, r20
	// set ethernet header
	eth_generate_header ( rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );
    1d12:	60 e0       	ldi	r22, 0x00	; 0
    1d14:	78 e0       	ldi	r23, 0x08	; 8
    1d16:	a9 01       	movw	r20, r18
    1d18:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <eth_generate_header>
	
	// generate ip header and checksum
	ip_generate_header (	rxtx_buffer, (WORD_BYTES){sizeof(IP_HEADER) + sizeof(ICMP_PACKET)}, IP_PROTO_ICMP_V, dest_ip );
    1d1c:	c8 01       	movw	r24, r16
    1d1e:	6c e3       	ldi	r22, 0x3C	; 60
    1d20:	70 e0       	ldi	r23, 0x00	; 0
    1d22:	41 e0       	ldi	r20, 0x01	; 1
    1d24:	97 01       	movw	r18, r14
    1d26:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <ip_generate_header>

	// generate icmp packet and checksum
	rxtx_buffer[ ICMP_TYPE_P ] = ICMP_TYPE_ECHOREQUEST_V;
    1d2a:	88 e0       	ldi	r24, 0x08	; 8
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	82 a3       	std	Z+34, r24	; 0x22
	rxtx_buffer[ ICMP_CODE_P ] = 0;
    1d30:	13 a2       	std	Z+35, r1	; 0x23
	rxtx_buffer[ ICMP_IDENTIFIER_H_P ] = icmp_id;
    1d32:	80 91 63 00 	lds	r24, 0x0063
    1d36:	86 a3       	std	Z+38, r24	; 0x26
	rxtx_buffer[ ICMP_IDENTIFIER_L_P ] = 0;
    1d38:	17 a2       	std	Z+39, r1	; 0x27
	rxtx_buffer[ ICMP_SEQUENCE_H_P ] = icmp_seq;
    1d3a:	80 91 64 00 	lds	r24, 0x0064
    1d3e:	80 a7       	std	Z+40, r24	; 0x28
	rxtx_buffer[ ICMP_SEQUENCE_L_P ] = 0;
    1d40:	11 a6       	std	Z+41, r1	; 0x29
	icmp_id++;
    1d42:	80 91 63 00 	lds	r24, 0x0063
    1d46:	8f 5f       	subi	r24, 0xFF	; 255
    1d48:	80 93 63 00 	sts	0x0063, r24
	icmp_seq++;
    1d4c:	80 91 64 00 	lds	r24, 0x0064
    1d50:	8f 5f       	subi	r24, 0xFF	; 255
    1d52:	80 93 64 00 	sts	0x0064, r24
	icmp_generate_packet ( rxtx_buffer );	
    1d56:	c8 01       	movw	r24, r16
    1d58:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <icmp_generate_packet>

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER) + sizeof(IP_HEADER) + sizeof(ICMP_PACKET) );
    1d5c:	c8 01       	movw	r24, r16
    1d5e:	6a e4       	ldi	r22, 0x4A	; 74
    1d60:	70 e0       	ldi	r23, 0x00	; 0
    1d62:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
}
    1d66:	1f 91       	pop	r17
    1d68:	0f 91       	pop	r16
    1d6a:	ff 90       	pop	r15
    1d6c:	ef 90       	pop	r14
    1d6e:	08 95       	ret

00001d70 <icmp_ping>:
// Function : icmp_ping_server
// Description : Send ARP reply packet to destination.
//
//*******************************************************************************************
BYTE icmp_ping ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1d70:	0f 93       	push	r16
    1d72:	1f 93       	push	r17
    1d74:	cf 93       	push	r28
    1d76:	df 93       	push	r29
    1d78:	ec 01       	movw	r28, r24
    1d7a:	8a 01       	movw	r16, r20
	BYTE i;
	WORD dlength;
	
	// destination ip was not found on network.
	if ( arp_who_is ( rxtx_buffer, dest_mac, dest_ip ) == 0 )
    1d7c:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <arp_who_is>
    1d80:	88 23       	and	r24, r24
    1d82:	e9 f0       	breq	.+58     	; 0x1dbe <icmp_ping+0x4e>
		return 0;

	// send icmp request packet (ping) to server
	icmp_send_request ( rxtx_buffer, (BYTE*)&server_mac, dest_ip );
    1d84:	ce 01       	movw	r24, r28
    1d86:	69 ec       	ldi	r22, 0xC9	; 201
    1d88:	70 e0       	ldi	r23, 0x00	; 0
    1d8a:	a8 01       	movw	r20, r16
    1d8c:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <icmp_send_request>
    1d90:	10 e0       	ldi	r17, 0x00	; 0

	for ( i=0; i<10; i++ )
	{
		_delay_ms( 10 );
    1d92:	8a e0       	ldi	r24, 0x0A	; 10
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>
		dlength = enc28j60_packet_receive( rxtx_buffer, MAX_RXTX_BUFFER );
    1d9a:	ce 01       	movw	r24, r28
    1d9c:	6c ed       	ldi	r22, 0xDC	; 220
    1d9e:	75 e0       	ldi	r23, 0x05	; 5
    1da0:	0e 94 82 05 	call	0xb04	; 0xb04 <enc28j60_packet_receive>

		if ( dlength )
    1da4:	89 2b       	or	r24, r25
    1da6:	41 f0       	breq	.+16     	; 0x1db8 <icmp_ping+0x48>
		{
			// check protocol is icmp or not?
			if ( rxtx_buffer [ IP_PROTO_P ] != IP_PROTO_ICMP_V )
    1da8:	8f 89       	ldd	r24, Y+23	; 0x17
    1daa:	81 30       	cpi	r24, 0x01	; 1
    1dac:	29 f4       	brne	.+10     	; 0x1db8 <icmp_ping+0x48>
				continue;
	
			// check icmp packet type is echo reply or not?
			if ( rxtx_buffer [ ICMP_TYPE_P ] != ICMP_TYPE_ECHOREPLY_V )
    1dae:	8a a1       	ldd	r24, Y+34	; 0x22
    1db0:	88 23       	and	r24, r24
    1db2:	11 f4       	brne	.+4      	; 0x1db8 <icmp_ping+0x48>
				continue;
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	04 c0       	rjmp	.+8      	; 0x1dc0 <icmp_ping+0x50>
		return 0;

	// send icmp request packet (ping) to server
	icmp_send_request ( rxtx_buffer, (BYTE*)&server_mac, dest_ip );

	for ( i=0; i<10; i++ )
    1db8:	1f 5f       	subi	r17, 0xFF	; 255
    1dba:	1a 30       	cpi	r17, 0x0A	; 10
    1dbc:	51 f7       	brne	.-44     	; 0x1d92 <icmp_ping+0x22>
    1dbe:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	// time out
	return 0;
}
    1dc0:	df 91       	pop	r29
    1dc2:	cf 91       	pop	r28
    1dc4:	1f 91       	pop	r17
    1dc6:	0f 91       	pop	r16
    1dc8:	08 95       	ret

00001dca <udp_puts_data>:
// Function : udp_puts_data
// Description : puts data from RAM to UDP tx buffer
//
//********************************************************************************************
WORD udp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
    1dca:	fb 01       	movw	r30, r22
    1dcc:	46 5d       	subi	r20, 0xD6	; 214
    1dce:	5f 4f       	sbci	r21, 0xFF	; 255
    1dd0:	dc 01       	movw	r26, r24
    1dd2:	a4 0f       	add	r26, r20
    1dd4:	b5 1f       	adc	r27, r21
    1dd6:	4a 52       	subi	r20, 0x2A	; 42
    1dd8:	50 40       	sbci	r21, 0x00	; 0
    1dda:	04 c0       	rjmp	.+8      	; 0x1de4 <udp_puts_data+0x1a>
	while( *data )
	{
		rxtx_buffer[ UDP_DATA_P + offset ] = *data++;
    1ddc:	8d 93       	st	X+, r24
    1dde:	31 96       	adiw	r30, 0x01	; 1
		offset++;
    1de0:	4f 5f       	subi	r20, 0xFF	; 255
    1de2:	5f 4f       	sbci	r21, 0xFF	; 255
// Description : puts data from RAM to UDP tx buffer
//
//********************************************************************************************
WORD udp_puts_data ( BYTE *rxtx_buffer, BYTE *data, WORD offset )
{
	while( *data )
    1de4:	80 81       	ld	r24, Z
    1de6:	88 23       	and	r24, r24
    1de8:	c9 f7       	brne	.-14     	; 0x1ddc <udp_puts_data+0x12>
		rxtx_buffer[ UDP_DATA_P + offset ] = *data++;
		offset++;
	}

	return offset;
}
    1dea:	ca 01       	movw	r24, r20
    1dec:	08 95       	ret

00001dee <udp_puts_data_p>:
// Function : udp_puts_data_p
// Description : puts data from program memory to tx buffer
//
//********************************************************************************************
WORD udp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
    1dee:	46 5d       	subi	r20, 0xD6	; 214
    1df0:	5f 4f       	sbci	r21, 0xFF	; 255
    1df2:	dc 01       	movw	r26, r24
    1df4:	a4 0f       	add	r26, r20
    1df6:	b5 1f       	adc	r27, r21
    1df8:	4a 52       	subi	r20, 0x2A	; 42
    1dfa:	50 40       	sbci	r21, 0x00	; 0
    1dfc:	03 c0       	rjmp	.+6      	; 0x1e04 <udp_puts_data_p+0x16>
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
	{
		rxtx_buffer[ UDP_DATA_P + offset ] = ch;
    1dfe:	8d 93       	st	X+, r24
		offset++;
    1e00:	4f 5f       	subi	r20, 0xFF	; 255
    1e02:	5f 4f       	sbci	r21, 0xFF	; 255
    1e04:	fb 01       	movw	r30, r22
//********************************************************************************************
WORD udp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
    1e06:	6f 5f       	subi	r22, 0xFF	; 255
    1e08:	7f 4f       	sbci	r23, 0xFF	; 255
    1e0a:	84 91       	lpm	r24, Z+
    1e0c:	88 23       	and	r24, r24
    1e0e:	b9 f7       	brne	.-18     	; 0x1dfe <udp_puts_data_p+0x10>
		rxtx_buffer[ UDP_DATA_P + offset ] = ch;
		offset++;
	}

	return offset;
}
    1e10:	ca 01       	movw	r24, r20
    1e12:	08 95       	ret

00001e14 <udp_generate_header>:
//
// Description : generate udp header
//
//********************************************************************************************
void udp_generate_header ( BYTE *rxtx_buffer, WORD_BYTES dest_port, WORD_BYTES length )
{
    1e14:	0f 93       	push	r16
    1e16:	1f 93       	push	r17
    1e18:	8c 01       	movw	r16, r24
	WORD_BYTES ck;

	// setup source port, default value is 3000
	rxtx_buffer[UDP_SRC_PORT_H_P] = UDP_AVR_PORT_H_V;
    1e1a:	8b e0       	ldi	r24, 0x0B	; 11
    1e1c:	f8 01       	movw	r30, r16
    1e1e:	82 a3       	std	Z+34, r24	; 0x22
	rxtx_buffer[UDP_SRC_PORT_L_P] = UDP_AVR_PORT_L_V;
    1e20:	88 eb       	ldi	r24, 0xB8	; 184
    1e22:	83 a3       	std	Z+35, r24	; 0x23

	// setup destination port
	rxtx_buffer[UDP_DST_PORT_H_P] = dest_port.byte.high;
    1e24:	74 a3       	std	Z+36, r23	; 0x24
	rxtx_buffer[UDP_DST_PORT_L_P] = dest_port.byte.low;
    1e26:	65 a3       	std	Z+37, r22	; 0x25

	// setup udp length
	rxtx_buffer[UDP_LENGTH_H_P] = length.byte.high;
    1e28:	56 a3       	std	Z+38, r21	; 0x26
	rxtx_buffer[UDP_LENGTH_L_P] = length.byte.low;
    1e2a:	47 a3       	std	Z+39, r20	; 0x27

	// setup udp checksum
	rxtx_buffer[UDP_CHECKSUM_H_P] = 0;
    1e2c:	10 a6       	std	Z+40, r1	; 0x28
	rxtx_buffer[UDP_CHECKSUM_L_P] = 0;
    1e2e:	11 a6       	std	Z+41, r1	; 0x29
	// length+8 for source/destination IP address length (8-bytes)
	ck.word = software_checksum ( (BYTE*)&rxtx_buffer[IP_SRC_IP_P], length.word+8, length.word+IP_PROTO_UDP_V);
    1e30:	ba 01       	movw	r22, r20
    1e32:	6f 5e       	subi	r22, 0xEF	; 239
    1e34:	7f 4f       	sbci	r23, 0xFF	; 255
    1e36:	9b 01       	movw	r18, r22
    1e38:	40 e0       	ldi	r20, 0x00	; 0
    1e3a:	50 e0       	ldi	r21, 0x00	; 0
    1e3c:	c8 01       	movw	r24, r16
    1e3e:	4a 96       	adiw	r24, 0x1a	; 26
    1e40:	69 50       	subi	r22, 0x09	; 9
    1e42:	70 40       	sbci	r23, 0x00	; 0
    1e44:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <software_checksum>
	rxtx_buffer[UDP_CHECKSUM_H_P] = ck.byte.high;
    1e48:	f8 01       	movw	r30, r16
    1e4a:	90 a7       	std	Z+40, r25	; 0x28
	rxtx_buffer[UDP_CHECKSUM_L_P] = ck.byte.low;
    1e4c:	81 a7       	std	Z+41, r24	; 0x29
}
    1e4e:	1f 91       	pop	r17
    1e50:	0f 91       	pop	r16
    1e52:	08 95       	ret

00001e54 <udp_receive>:
//
// Description : check received packet and process UDP command.
//
//********************************************************************************************
BYTE udp_receive ( BYTE *rxtx_buffer, BYTE *dest_mac, BYTE *dest_ip )
{
    1e54:	ef 92       	push	r14
    1e56:	ff 92       	push	r15
    1e58:	0f 93       	push	r16
    1e5a:	1f 93       	push	r17
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29
    1e60:	8c 01       	movw	r16, r24
    1e62:	9b 01       	movw	r18, r22
    1e64:	7a 01       	movw	r14, r20
	WORD_BYTES dlength, adc0;
	BYTE generic_buf[64], temp, count_time_temp[3], tmp;

	// check UDP packet and check destination port
	if ( rxtx_buffer[IP_PROTO_P] != IP_PROTO_UDP_V || rxtx_buffer[UDP_DST_PORT_H_P] != UDP_AVR_PORT_H_V || rxtx_buffer[ UDP_DST_PORT_L_P ] != UDP_AVR_PORT_L_V )
    1e66:	fc 01       	movw	r30, r24
    1e68:	87 89       	ldd	r24, Z+23	; 0x17
    1e6a:	81 31       	cpi	r24, 0x11	; 17
    1e6c:	99 f5       	brne	.+102    	; 0x1ed4 <udp_receive+0x80>
    1e6e:	84 a1       	ldd	r24, Z+36	; 0x24
    1e70:	8b 30       	cpi	r24, 0x0B	; 11
    1e72:	81 f5       	brne	.+96     	; 0x1ed4 <udp_receive+0x80>
    1e74:	85 a1       	ldd	r24, Z+37	; 0x25
    1e76:	88 3b       	cpi	r24, 0xB8	; 184
    1e78:	69 f5       	brne	.+90     	; 0x1ed4 <udp_receive+0x80>
    1e7a:	d8 01       	movw	r26, r16
    1e7c:	9a 96       	adiw	r26, 0x2a	; 42
    1e7e:	c0 e0       	ldi	r28, 0x00	; 0
    1e80:	d0 e0       	ldi	r29, 0x00	; 0
    1e82:	02 c0       	rjmp	.+4      	; 0x1e88 <udp_receive+0x34>
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
	{
		rxtx_buffer[ UDP_DATA_P + offset ] = ch;
    1e84:	8d 93       	st	X+, r24
		offset++;
    1e86:	21 96       	adiw	r28, 0x01	; 1
//********************************************************************************************
WORD udp_puts_data_p ( BYTE *rxtx_buffer, PGM_P data, WORD offset )
{
	BYTE ch;
	
	while( (ch = pgm_read_byte(data++)) )
    1e88:	fe 01       	movw	r30, r28
    1e8a:	e8 5f       	subi	r30, 0xF8	; 248
    1e8c:	f6 4f       	sbci	r31, 0xF6	; 246
    1e8e:	84 91       	lpm	r24, Z+
    1e90:	88 23       	and	r24, r24
    1e92:	c1 f7       	brne	.-16     	; 0x1e84 <udp_receive+0x30>
	
	// unknown command, send "ERROR" to client
	dlength.word = udp_puts_data_p ( rxtx_buffer, PSTR("ERROR\r\n"), 0 );

	// set ethernet header
	eth_generate_header (rxtx_buffer, (WORD_BYTES){ETH_TYPE_IP_V}, dest_mac );
    1e94:	c8 01       	movw	r24, r16
    1e96:	60 e0       	ldi	r22, 0x00	; 0
    1e98:	78 e0       	ldi	r23, 0x08	; 8
    1e9a:	a9 01       	movw	r20, r18
    1e9c:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <eth_generate_header>
	
	// generate ip header and checksum
	ip_generate_header (rxtx_buffer, (WORD_BYTES){sizeof(IP_HEADER)+sizeof(UDP_HEADER)+dlength.word}, IP_PROTO_UDP_V, dest_ip );
    1ea0:	6c 96       	adiw	r28, 0x1c	; 28
    1ea2:	c8 01       	movw	r24, r16
    1ea4:	be 01       	movw	r22, r28
    1ea6:	41 e1       	ldi	r20, 0x11	; 17
    1ea8:	97 01       	movw	r18, r14
    1eaa:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <ip_generate_header>

	// generate UDP header
	udp_generate_header (rxtx_buffer, (WORD_BYTES){(rxtx_buffer[UDP_SRC_PORT_H_P]<<8)|rxtx_buffer[UDP_SRC_PORT_L_P]}, (WORD_BYTES){sizeof(UDP_HEADER)+dlength.word});
    1eae:	f8 01       	movw	r30, r16
    1eb0:	72 a1       	ldd	r23, Z+34	; 0x22
    1eb2:	60 e0       	ldi	r22, 0x00	; 0
    1eb4:	83 a1       	ldd	r24, Z+35	; 0x23
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	68 2b       	or	r22, r24
    1eba:	79 2b       	or	r23, r25
    1ebc:	64 97       	sbiw	r28, 0x14	; 20
    1ebe:	c8 01       	movw	r24, r16
    1ec0:	ae 01       	movw	r20, r28
    1ec2:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <udp_generate_header>

	// send packet to ethernet media
	enc28j60_packet_send ( rxtx_buffer, sizeof(ETH_HEADER)+sizeof(IP_HEADER)+sizeof(UDP_HEADER)+dlength.word );
    1ec6:	a2 96       	adiw	r28, 0x22	; 34
    1ec8:	c8 01       	movw	r24, r16
    1eca:	be 01       	movw	r22, r28
    1ecc:	0e 94 2f 05 	call	0xa5e	; 0xa5e <enc28j60_packet_send>
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	01 c0       	rjmp	.+2      	; 0x1ed6 <udp_receive+0x82>

	return 1;
    1ed4:	80 e0       	ldi	r24, 0x00	; 0
}
    1ed6:	df 91       	pop	r29
    1ed8:	cf 91       	pop	r28
    1eda:	1f 91       	pop	r17
    1edc:	0f 91       	pop	r16
    1ede:	ff 90       	pop	r15
    1ee0:	ef 90       	pop	r14
    1ee2:	08 95       	ret

00001ee4 <_delay_ms>:
void _delay_ms(int delayIn_MS);
void _delay_us(int delayIn_uS);

//function to give delay of X Milli-seconds
void _delay_ms(int delayIn_MS)
{	int i;
    1ee4:	40 e0       	ldi	r20, 0x00	; 0
    1ee6:	50 e0       	ldi	r21, 0x00	; 0
    1ee8:	09 c0       	rjmp	.+18     	; 0x1efc <_delay_ms+0x18>
	double j=0;
	for (i=0; i<delayIn_MS; i++)
    1eea:	20 e0       	ldi	r18, 0x00	; 0
    1eec:	30 e0       	ldi	r19, 0x00	; 0
    1eee:	2f 5f       	subi	r18, 0xFF	; 255
    1ef0:	3f 4f       	sbci	r19, 0xFF	; 255
		for (j=0; j<MS_DelayCnt; j++);
    1ef2:	26 33       	cpi	r18, 0x36	; 54
    1ef4:	31 05       	cpc	r19, r1
    1ef6:	d9 f7       	brne	.-10     	; 0x1eee <_delay_ms+0xa>

//function to give delay of X Milli-seconds
void _delay_ms(int delayIn_MS)
{	int i;
	double j=0;
	for (i=0; i<delayIn_MS; i++)
    1ef8:	4f 5f       	subi	r20, 0xFF	; 255
    1efa:	5f 4f       	sbci	r21, 0xFF	; 255
    1efc:	48 17       	cp	r20, r24
    1efe:	59 07       	cpc	r21, r25
    1f00:	a4 f3       	brlt	.-24     	; 0x1eea <_delay_ms+0x6>
		for (j=0; j<MS_DelayCnt; j++);
}
    1f02:	08 95       	ret

00001f04 <_delay_us>:

//function to give delay of X micro-seconds
void _delay_us(int delayIn_uS)
{	int i;
    1f04:	40 e0       	ldi	r20, 0x00	; 0
    1f06:	50 e0       	ldi	r21, 0x00	; 0
    1f08:	09 c0       	rjmp	.+18     	; 0x1f1c <_delay_us+0x18>
	double j=0;
	for (i=0; i<delayIn_uS; i++)
    1f0a:	20 e0       	ldi	r18, 0x00	; 0
    1f0c:	30 e0       	ldi	r19, 0x00	; 0
    1f0e:	2f 5f       	subi	r18, 0xFF	; 255
    1f10:	3f 4f       	sbci	r19, 0xFF	; 255
		for (j=0; j<uS_DelayCnt; j++);
    1f12:	2a 30       	cpi	r18, 0x0A	; 10
    1f14:	31 05       	cpc	r19, r1
    1f16:	d9 f7       	brne	.-10     	; 0x1f0e <_delay_us+0xa>

//function to give delay of X micro-seconds
void _delay_us(int delayIn_uS)
{	int i;
	double j=0;
	for (i=0; i<delayIn_uS; i++)
    1f18:	4f 5f       	subi	r20, 0xFF	; 255
    1f1a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f1c:	48 17       	cp	r20, r24
    1f1e:	59 07       	cpc	r21, r25
    1f20:	a4 f3       	brlt	.-24     	; 0x1f0a <_delay_us+0x6>
		for (j=0; j<uS_DelayCnt; j++);
}
    1f22:	08 95       	ret

00001f24 <initTimer_heartBeat>:
			1		1		1		-->		External Clock Source on PIN T0.
											Clock On Rising Edge			 */
	 /************************************************************************/
	 
	// Prescaler = FCPU/1024
	TCCR0 |= (1 << CS02) | (1 << CS00);
    1f24:	83 b7       	in	r24, 0x33	; 51
    1f26:	85 60       	ori	r24, 0x05	; 5
    1f28:	83 bf       	out	0x33, r24	; 51
   
	//Enable Overflow Interrupt Enable
	TIMSK |= 1 << TOIE0;
    1f2a:	89 b7       	in	r24, 0x39	; 57
    1f2c:	81 60       	ori	r24, 0x01	; 1
    1f2e:	89 bf       	out	0x39, r24	; 57
   
	//Initialize Counter
	TCNT0 = 0;
    1f30:	12 be       	out	0x32, r1	; 50
   
	//Initialize our variable
	count = 0;
    1f32:	10 92 d0 00 	sts	0x00D0, r1
	flag = 0;
    1f36:	10 92 cf 00 	sts	0x00CF, r1
   
	//Set Port as output
	heartBeatDDR |= (1 << heartBeatPIN);
    1f3a:	a0 9a       	sbi	0x14, 0	; 20

	sei();
    1f3c:	78 94       	sei
 }
    1f3e:	08 95       	ret

00001f40 <__vector_11>:
 
//Interrupt Service Routine for TIMER0 Overflow Interrupt
ISR(TIMER0_OVF_vect)
{
    1f40:	1f 92       	push	r1
    1f42:	0f 92       	push	r0
    1f44:	0f b6       	in	r0, 0x3f	; 63
    1f46:	0f 92       	push	r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	8f 93       	push	r24
	//This is the interrupt service routine for TIMER0 OVERFLOW Interrupt.
	//CPU automatically call this when TIMER0 overflows.

	//Increment our variable
	count++;
    1f4c:	80 91 d0 00 	lds	r24, 0x00D0
    1f50:	8f 5f       	subi	r24, 0xFF	; 255
    1f52:	80 93 d0 00 	sts	0x00D0, r24
	if(count == 16)	//toggle in every 500ms
    1f56:	80 91 d0 00 	lds	r24, 0x00D0
    1f5a:	80 31       	cpi	r24, 0x10	; 16
    1f5c:	81 f4       	brne	.+32     	; 0x1f7e <__vector_11+0x3e>
	{
		count = 0;
    1f5e:	10 92 d0 00 	sts	0x00D0, r1
		if (flag == 0)
    1f62:	80 91 cf 00 	lds	r24, 0x00CF
    1f66:	88 23       	and	r24, r24
    1f68:	29 f4       	brne	.+10     	; 0x1f74 <__vector_11+0x34>
		{
			heartBeatPORT |= (1 << heartBeatPIN);
    1f6a:	a8 9a       	sbi	0x15, 0	; 21
			flag = 1;
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
    1f6e:	80 93 cf 00 	sts	0x00CF, r24
    1f72:	05 c0       	rjmp	.+10     	; 0x1f7e <__vector_11+0x3e>
		}
		else if (flag == 1)
    1f74:	81 30       	cpi	r24, 0x01	; 1
    1f76:	19 f4       	brne	.+6      	; 0x1f7e <__vector_11+0x3e>
		{
			heartBeatPORT &= ~(1 << heartBeatPIN);
    1f78:	a8 98       	cbi	0x15, 0	; 21
			flag = 0;
    1f7a:	10 92 cf 00 	sts	0x00CF, r1
		so in 1 sec there are 31 interrupts. Therefore counter is set to 0 
		every 1 sec.that means heartBeatPORT will toggled every 1 sec. 
		That means it is ON for 1 sec and OFF for 1 sec. So time period 
		is 2 sec and freq is 1/2 = 0.5Hz									*/
	/************************************************************************/
}//end of ISR
    1f7e:	8f 91       	pop	r24
    1f80:	0f 90       	pop	r0
    1f82:	0f be       	out	0x3f, r0	; 63
    1f84:	0f 90       	pop	r0
    1f86:	1f 90       	pop	r1
    1f88:	18 95       	reti

00001f8a <Init_USART>:

#include "usart.h"

//Function to initialize the USART
void Init_USART(uint16_t ubrr){
	UCSRB =  (1 << RXEN) | (1 << TXEN);      // Enable receiver and transmitter              
    1f8a:	88 e1       	ldi	r24, 0x18	; 24
    1f8c:	8a b9       	out	0x0a, r24	; 10
   // UCSRC = (1 << URSEL) | (3 << UCSZ0);     // Set frame format: 8-bit data, 1-stop bit
	UCSRC |= (1 << URSEL ) | (1 << UCSZ0 ) | (1 << UCSZ1 ); // Use 8- bit character sizes
    1f8e:	80 b5       	in	r24, 0x20	; 32
    1f90:	86 68       	ori	r24, 0x86	; 134
    1f92:	80 bd       	out	0x20, r24	; 32
    // Set baud rate
	UBRRL = (uint8_t)BAUD_PRESCALE;          // Load lower 8-bits of the baud rate value into the low byte of the UBRR register
    1f94:	8d e4       	ldi	r24, 0x4D	; 77
    1f96:	89 b9       	out	0x09, r24	; 9
	UBRRH = (uint8_t)(BAUD_PRESCALE >> 8);   // Load higher 8-bits of the baud rate value into the higher byte of the UBRR register                      
    1f98:	10 bc       	out	0x20, r1	; 32
    //UCSRB |= (1 << RXCIE );                  // Enable the USART Recieve Complete interrupt ( USART_RXC )
    //sei ();                                  // Enable the Global Interrupt Enable flag so that interrupts can be processed
}
    1f9a:	08 95       	ret

00001f9c <USART_Send8BitData>:

//Function that Sends Frames with 5 to 8 Data Bit
void USART_Send8BitData(unsigned char data){
	while ( !( UCSRA & (1<<UDRE)) );        //Wait for empty transmit buffer
    1f9c:	5d 9b       	sbis	0x0b, 5	; 11
    1f9e:	fe cf       	rjmp	.-4      	; 0x1f9c <USART_Send8BitData>
	UDR = data;                             //Put data into buffer, sends the data
    1fa0:	8c b9       	out	0x0c, r24	; 12
}
    1fa2:	08 95       	ret

00001fa4 <USART_Send9BitData>:

//Function that Sends Frames with 9 Data Bit
void USART_Send9BitData(unsigned int data){	
	while ( !( UCSRA & (1<<UDRE)) );       //Wait for empty transmit buffer
    1fa4:	5d 9b       	sbis	0x0b, 5	; 11
    1fa6:	fe cf       	rjmp	.-4      	; 0x1fa4 <USART_Send9BitData>
	UCSRB &= ~(1<<TXB8);                   //Copy 9th bit to TXB8
    1fa8:	50 98       	cbi	0x0a, 0	; 10
	if ( data & 0x0100 )
    1faa:	90 fd       	sbrc	r25, 0
		UCSRB |= (1<<TXB8);	
    1fac:	50 9a       	sbi	0x0a, 0	; 10
	UDR = data;                           //Put data into buffer, sends the data
    1fae:	8c b9       	out	0x0c, r24	; 12
}
    1fb0:	08 95       	ret

00001fb2 <USART_Receive8BitData>:

//Function that Receives Frames with 5 to 8 Data Bits
unsigned char USART_Receive8BitData(void){	
	while ( !(UCSRA & (1<<RXC)) );       //Wait for data to be received	
    1fb2:	5f 9b       	sbis	0x0b, 7	; 11
    1fb4:	fe cf       	rjmp	.-4      	; 0x1fb2 <USART_Receive8BitData>
	return UDR;                          //Get and return received data from buffer
    1fb6:	8c b1       	in	r24, 0x0c	; 12
}
    1fb8:	08 95       	ret

00001fba <USART_Receive9BitData>:

//Function that Receives Frames with 9 Data Bits
unsigned int USART_Receive9BitData(void){
	unsigned char status, resh, resl;	
	while ( !(UCSRA & (1<<RXC)) );        //Wait for data to be received	
    1fba:	5f 9b       	sbis	0x0b, 7	; 11
    1fbc:	fe cf       	rjmp	.-4      	; 0x1fba <USART_Receive9BitData>
	//Get status and 9th bit, then data from buffer
	status = UCSRA;
    1fbe:	8b b1       	in	r24, 0x0b	; 11
	resh = UCSRB;
    1fc0:	2a b1       	in	r18, 0x0a	; 10
	resl = UDR;	
    1fc2:	3c b1       	in	r19, 0x0c	; 12
	//If error, return -1
	if ( status & ((1<<FE)|(1<<DOR)|(1<<PE)) )
    1fc4:	8c 71       	andi	r24, 0x1C	; 28
    1fc6:	19 f0       	breq	.+6      	; 0x1fce <USART_Receive9BitData+0x14>
    1fc8:	2f ef       	ldi	r18, 0xFF	; 255
    1fca:	3f ef       	ldi	r19, 0xFF	; 255
    1fcc:	08 c0       	rjmp	.+16     	; 0x1fde <USART_Receive9BitData+0x24>
		return -1;
	//Filter the 9th bit, then return
	resh = (resh >> 1) & 0x01;
    1fce:	26 95       	lsr	r18
	return ((resh << 8) | resl);
    1fd0:	92 2f       	mov	r25, r18
    1fd2:	91 70       	andi	r25, 0x01	; 1
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	23 2f       	mov	r18, r19
    1fd8:	30 e0       	ldi	r19, 0x00	; 0
    1fda:	28 2b       	or	r18, r24
    1fdc:	39 2b       	or	r19, r25
}
    1fde:	c9 01       	movw	r24, r18
    1fe0:	08 95       	ret

00001fe2 <USART_Flush>:

//Function that Flush the Receive Buffer
void USART_Flush(void){
    1fe2:	01 c0       	rjmp	.+2      	; 0x1fe6 <USART_Flush+0x4>
	unsigned char dummy;
	while ( UCSRA & (1<<RXC) ) 
	  dummy = UDR;
    1fe4:	8c b1       	in	r24, 0x0c	; 12
}

//Function that Flush the Receive Buffer
void USART_Flush(void){
	unsigned char dummy;
	while ( UCSRA & (1<<RXC) ) 
    1fe6:	5f 99       	sbic	0x0b, 7	; 11
    1fe8:	fd cf       	rjmp	.-6      	; 0x1fe4 <USART_Flush+0x2>
	  dummy = UDR;
}
    1fea:	08 95       	ret

00001fec <USART_SendString>:

//Function that sends the string via USART
void USART_SendString(char *str) {
    1fec:	fc 01       	movw	r30, r24
    1fee:	04 c0       	rjmp	.+8      	; 0x1ff8 <USART_SendString+0xc>
    //sei ();                                  // Enable the Global Interrupt Enable flag so that interrupts can be processed
}

//Function that Sends Frames with 5 to 8 Data Bit
void USART_Send8BitData(unsigned char data){
	while ( !( UCSRA & (1<<UDRE)) );        //Wait for empty transmit buffer
    1ff0:	5d 9b       	sbis	0x0b, 5	; 11
    1ff2:	fe cf       	rjmp	.-4      	; 0x1ff0 <USART_SendString+0x4>

//Function that sends the string via USART
void USART_SendString(char *str) {
	int h;
	while(*str)         
		USART_Send8BitData(*str++);       // send message
    1ff4:	31 96       	adiw	r30, 0x01	; 1
}

//Function that Sends Frames with 5 to 8 Data Bit
void USART_Send8BitData(unsigned char data){
	while ( !( UCSRA & (1<<UDRE)) );        //Wait for empty transmit buffer
	UDR = data;                             //Put data into buffer, sends the data
    1ff6:	8c b9       	out	0x0c, r24	; 12
}

//Function that sends the string via USART
void USART_SendString(char *str) {
	int h;
	while(*str)         
    1ff8:	80 81       	ld	r24, Z
    1ffa:	88 23       	and	r24, r24
    1ffc:	c9 f7       	brne	.-14     	; 0x1ff0 <USART_SendString+0x4>
		USART_Send8BitData(*str++);       // send message
	for(h=0;h<=200;h++); 
}
    1ffe:	08 95       	ret

00002000 <GSM_TrfBalance>:
//	USART_SendString(number);
//	USART_SendString(";\r");
}

// function to transfer balance
void GSM_TrfBalance(char *number,char *balance) {
    2000:	ef 92       	push	r14
    2002:	ff 92       	push	r15
    2004:	0f 93       	push	r16
    2006:	1f 93       	push	r17
    2008:	8c 01       	movw	r16, r24
    200a:	7b 01       	movw	r14, r22
	USART_SendString("AT+CMGF=0\r");
    200c:	85 e6       	ldi	r24, 0x65	; 101
    200e:	90 e0       	ldi	r25, 0x00	; 0
    2010:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	_delay_ms(10000);
    2014:	80 e1       	ldi	r24, 0x10	; 16
    2016:	97 e2       	ldi	r25, 0x27	; 39
    2018:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>
	USART_SendString("AT+CUSD=1,\"*422*23456781*");
    201c:	80 e7       	ldi	r24, 0x70	; 112
    201e:	90 e0       	ldi	r25, 0x00	; 0
    2020:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString(number);
    2024:	c8 01       	movw	r24, r16
    2026:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString("*");
    202a:	8a e8       	ldi	r24, 0x8A	; 138
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString(balance);
    2032:	c7 01       	movw	r24, r14
    2034:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString("00#\",15\r");
    2038:	8c e8       	ldi	r24, 0x8C	; 140
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>

}
    2040:	1f 91       	pop	r17
    2042:	0f 91       	pop	r16
    2044:	ff 90       	pop	r15
    2046:	ef 90       	pop	r14
    2048:	08 95       	ret

0000204a <GSM_SendMessage>:
	USART_SendString("AT+CMGF=1\r");
	_delay_ms(20);
}

//function to send message from SIM900 GSM Modem
void GSM_SendMessage(char *number,char *msg){
    204a:	ef 92       	push	r14
    204c:	ff 92       	push	r15
    204e:	0f 93       	push	r16
    2050:	1f 93       	push	r17
    2052:	8c 01       	movw	r16, r24
    2054:	7b 01       	movw	r14, r22
	USART_SendString("AT+CMGS=\"");
    2056:	85 e9       	ldi	r24, 0x95	; 149
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString(number);
    205e:	c8 01       	movw	r24, r16
    2060:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString("\"\r");
    2064:	8f e9       	ldi	r24, 0x9F	; 159
    2066:	90 e0       	ldi	r25, 0x00	; 0
    2068:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	_delay_ms(6000);
    206c:	80 e7       	ldi	r24, 0x70	; 112
    206e:	97 e1       	ldi	r25, 0x17	; 23
    2070:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>

//	USART_SendString("emBank verification code: ");
	USART_SendString(msg);
    2074:	c7 01       	movw	r24, r14
    2076:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	USART_SendString("\x1A");
    207a:	82 ea       	ldi	r24, 0xA2	; 162
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>

//	USART_SendString("ATD");
//	USART_SendString(number);
//	USART_SendString(";\r");
}
    2082:	1f 91       	pop	r17
    2084:	0f 91       	pop	r16
    2086:	ff 90       	pop	r15
    2088:	ef 90       	pop	r14
    208a:	08 95       	ret

0000208c <Init_GSM>:

 #include "gsm.h"

//function to initialize SIM900 GSM Modem
void Init_GSM(){
	USART_SendString("AT+CMGF=1\r");
    208c:	84 ea       	ldi	r24, 0xA4	; 164
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <USART_SendString>
	_delay_ms(20);
    2094:	84 e1       	ldi	r24, 0x14	; 20
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_delay_ms>
}
    209c:	08 95       	ret

0000209e <__eerd_block>:
    209e:	a0 e0       	ldi	r26, 0x00	; 0
    20a0:	b0 e0       	ldi	r27, 0x00	; 0
    20a2:	e5 e5       	ldi	r30, 0x55	; 85
    20a4:	f0 e1       	ldi	r31, 0x10	; 16
    20a6:	0c 94 75 10 	jmp	0x20ea	; 0x20ea <__prologue_saves__+0x14>
    20aa:	7c 01       	movw	r14, r24
    20ac:	eb 01       	movw	r28, r22
    20ae:	8a 01       	movw	r16, r20
    20b0:	69 01       	movw	r12, r18
    20b2:	09 c0       	rjmp	.+18     	; 0x20c6 <__eerd_block+0x28>
    20b4:	ce 01       	movw	r24, r28
    20b6:	21 96       	adiw	r28, 0x01	; 1
    20b8:	f6 01       	movw	r30, r12
    20ba:	09 95       	icall
    20bc:	f7 01       	movw	r30, r14
    20be:	81 93       	st	Z+, r24
    20c0:	7f 01       	movw	r14, r30
    20c2:	01 50       	subi	r16, 0x01	; 1
    20c4:	10 40       	sbci	r17, 0x00	; 0
    20c6:	01 15       	cp	r16, r1
    20c8:	11 05       	cpc	r17, r1
    20ca:	a1 f7       	brne	.-24     	; 0x20b4 <__eerd_block+0x16>
    20cc:	cd b7       	in	r28, 0x3d	; 61
    20ce:	de b7       	in	r29, 0x3e	; 62
    20d0:	e8 e0       	ldi	r30, 0x08	; 8
    20d2:	0c 94 91 10 	jmp	0x2122	; 0x2122 <__epilogue_restores__+0x14>

000020d6 <__prologue_saves__>:
    20d6:	2f 92       	push	r2
    20d8:	3f 92       	push	r3
    20da:	4f 92       	push	r4
    20dc:	5f 92       	push	r5
    20de:	6f 92       	push	r6
    20e0:	7f 92       	push	r7
    20e2:	8f 92       	push	r8
    20e4:	9f 92       	push	r9
    20e6:	af 92       	push	r10
    20e8:	bf 92       	push	r11
    20ea:	cf 92       	push	r12
    20ec:	df 92       	push	r13
    20ee:	ef 92       	push	r14
    20f0:	ff 92       	push	r15
    20f2:	0f 93       	push	r16
    20f4:	1f 93       	push	r17
    20f6:	cf 93       	push	r28
    20f8:	df 93       	push	r29
    20fa:	cd b7       	in	r28, 0x3d	; 61
    20fc:	de b7       	in	r29, 0x3e	; 62
    20fe:	ca 1b       	sub	r28, r26
    2100:	db 0b       	sbc	r29, r27
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	de bf       	out	0x3e, r29	; 62
    2108:	0f be       	out	0x3f, r0	; 63
    210a:	cd bf       	out	0x3d, r28	; 61
    210c:	09 94       	ijmp

0000210e <__epilogue_restores__>:
    210e:	2a 88       	ldd	r2, Y+18	; 0x12
    2110:	39 88       	ldd	r3, Y+17	; 0x11
    2112:	48 88       	ldd	r4, Y+16	; 0x10
    2114:	5f 84       	ldd	r5, Y+15	; 0x0f
    2116:	6e 84       	ldd	r6, Y+14	; 0x0e
    2118:	7d 84       	ldd	r7, Y+13	; 0x0d
    211a:	8c 84       	ldd	r8, Y+12	; 0x0c
    211c:	9b 84       	ldd	r9, Y+11	; 0x0b
    211e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2120:	b9 84       	ldd	r11, Y+9	; 0x09
    2122:	c8 84       	ldd	r12, Y+8	; 0x08
    2124:	df 80       	ldd	r13, Y+7	; 0x07
    2126:	ee 80       	ldd	r14, Y+6	; 0x06
    2128:	fd 80       	ldd	r15, Y+5	; 0x05
    212a:	0c 81       	ldd	r16, Y+4	; 0x04
    212c:	1b 81       	ldd	r17, Y+3	; 0x03
    212e:	aa 81       	ldd	r26, Y+2	; 0x02
    2130:	b9 81       	ldd	r27, Y+1	; 0x01
    2132:	ce 0f       	add	r28, r30
    2134:	d1 1d       	adc	r29, r1
    2136:	0f b6       	in	r0, 0x3f	; 63
    2138:	f8 94       	cli
    213a:	de bf       	out	0x3e, r29	; 62
    213c:	0f be       	out	0x3f, r0	; 63
    213e:	cd bf       	out	0x3d, r28	; 61
    2140:	ed 01       	movw	r28, r26
    2142:	08 95       	ret

00002144 <_exit>:
    2144:	f8 94       	cli

00002146 <__stop_program>:
    2146:	ff cf       	rjmp	.-2      	; 0x2146 <__stop_program>
